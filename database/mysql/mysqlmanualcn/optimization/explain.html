<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->

<!--end of htmlmiddle-->



<h1>7.2.1. EXPLAIN语法（获取SELECT相关信息）</h1>

          
        
      
      
      <pre>EXPLAIN <i>tbl_name</i></pre>
      <p> 或：</p>
      <pre>EXPLAIN [EXTENDED] SELECT <i>select_options</i></pre>
      <p> EXPLAIN语句可以用作DESCRIBE的一个同义词，或获得关于MySQL如何执行SELECT语句的信息：</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        
        EXPLAIN <i>tbl_name</i>是DESCRIBE <i>tbl_name</i>或SHOW 
        COLUMNS FROM <i>tbl_name</i>的一个同义词。</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        如果在SELECT语句前放上关键词EXPLAIN，MySQL将解释它如何处理SELECT，提供有关表如何联接和联接的次序。</p>
      <p> 该节解释EXPLAIN的第2个用法。</p>
      <p> 借助于EXPLAIN，可以知道什么时候必须为表加入索引以得到一个使用索引来寻找记录的更快的SELECT。</p>
      <p> 如果由于使用不正确的索引出现了问题，应运行ANALYZE 
        TABLE更新表的统计（例如关键字集的势），这样会影响优化器进行的选择。参见<a href="explain.html" title="13.5.2.1. ANALYZE TABLE Syntax">13.5.2.1节，“ANALYZE 
        TABLE语法”</a>。</p>
      <p> 还可以知道优化器是否以一个最佳次序联接表。为了强制优化器让一个SELECT语句按照表命名顺序的联接次序，语句应以STRAIGHT_JOIN而不只是SELECT开头。</p>
      <p> EXPLAIN为用于SELECT语句中的每个表返回一行信息。表以它们在处理查询过程中将被MySQL读入的顺序被列出。MySQL用一遍扫描多次联接（<em>single-sweep 
        multi-join</em>）的方式解决所有联接。这意味着MySQL从第一个表中读一行，然后找到在第二个表中的一个匹配行，然后在第3个表中等等。当所有的表处理完后，它输出选中的列并且返回表清单直到找到一个有更多的匹配行的表。从该表读入下一行并继续处理下一个表。</p>
      <p> 当使用EXTENDED关键字时，EXPLAIN产生附加信息，可以用SHOW 
        WARNINGS浏览。该信息显示优化器限定SELECT语句中的表和列名，重写并且执行优化规则后SELECT语句是什么样子，并且还可能包括优化过程的其它注解。</p>
      <p> EXPLAIN的每个输出行提供一个表的相关信息，并且每个行包括下面的列：</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        
        id</p>
      <p> SELECT识别符。这是SELECT的查询序列号。</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        
        select_type</p>
      <p> SELECT类型，可以为以下任何一种：</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        SIMPLE</p>
      <p> 简单SELECT(不使用UNION或子查询) </p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        PRIMARY</p>
      <p> 最外面的SELECT</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        UNION</p>
      <p> UNION中的第二个或后面的SELECT语句</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        DEPENDENT UNION</p>
      <p> UNION中的第二个或后面的SELECT语句，取决于外面的查询</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        UNION RESULT</p>
      <p> UNION的结果。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        SUBQUERY</p>
      <p> 子查询中的第一个SELECT</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        DEPENDENT SUBQUERY</p>
      <p> 子查询中的第一个SELECT，取决于外面的查询</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        DERIVED</p>
      <p> 导出表的SELECT(FROM子句的子查询)</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        table</p>
      <p> 输出的行所引用的表。</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        
        type</p>
      <p> 联接类型。下面给出各种联接类型，按照从最佳类型到最坏类型进行排序：</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        system</p>
      <p> 表仅有一行(=系统表)。这是const联接类型的一个特例。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        const</p>
      <p> 表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。const表很快，因为它们只读取一次！</p>
      <p> const用于用常数值比较PRIMARY 
        KEY或UNIQUE索引的所有部分时。在下面的查询中，<i>tbl_name</i>可以用于const表：</p>
      <pre>SELECT * from <i>tbl_name</i> WHERE <i>primary_key</i>=1；
&nbsp;
SELECT * from <i>tbl_name</i>
WHERE <i>primary_key_part1</i>=1和 <i>primary_key_part2</i>=2；</pre>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        eq_ref</p>
      <p> 对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY 
        KEY。</p>
      <p> eq_ref可以用于使用=
        操作符比较的带索引的列。比较值可以为常量或一个使用在该表前面所读取的表的列的表达式。</p>
      <p> 在下面的例子中，MySQL可以使用eq_ref联接来处理<i>ref_tables</i>：</p>
      <pre>SELECT * FROM <i>ref_table</i>,<i>other_table</i>
&nbsp; WHERE <i>ref_table</i>.<i>key_column</i>=<i>other_table</i>.<i>column</i>;
&nbsp;
SELECT * FROM <i>ref_table</i>,<i>other_table</i>
&nbsp; WHERE <i>ref_table</i>.<i>key_column_part1</i>=<i>other_table</i>.<i>column</i>
&nbsp;&nbsp;&nbsp; AND <i>ref_table</i>.<i>key_column_part2</i>=1;</pre>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        ref</p>
      <p> 对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是UNIQUE或PRIMARY 
        KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。</p>
      <p> ref可以用于使用=或&lt;=&gt;操作符的带索引的列。</p>
      <p> 在下面的例子中，MySQL可以使用ref联接来处理<i>ref_tables</i>：</p>
      <pre>SELECT * FROM <i>ref_table</i> WHERE <i>key_column</i>=<i>expr</i>;
&nbsp;
SELECT * FROM <i>ref_table</i>,<i>other_table</i>
&nbsp; WHERE <i>ref_table</i>.<i>key_column</i>=<i>other_table</i>.<i>column</i>;
&nbsp;
SELECT * FROM <i>ref_table</i>,<i>other_table</i>
&nbsp; WHERE <i>ref_table</i>.<i>key_column_part1</i>=<i>other_table</i>.<i>column</i>
&nbsp;&nbsp;&nbsp; AND <i>ref_table</i>.<i>key_column_part2</i>=1;</pre>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        ref_or_null</p>
      <p> 该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。</p>
      <p> 在下面的例子中，MySQL可以使用ref_or_null联接来处理<i>ref_tables</i>：</p>
      <pre>SELECT * FROM <i>ref_table</i>
WHERE <i>key_column</i>=<i>expr</i> OR <i>key_column</i> IS NULL;</pre>
      <p> 参见<a href="is-null-optimization.html" title="7.2.7. How MySQL Optimizes IS NULL">7.2.7节，“MySQL如何优化IS NULL”</a>。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        index_merge</p>
      <p> 该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。详细信息参见<a href="index-merge-optimization.html" title="7.2.6. Index Merge Optimization">7.2.6节，“索引合并优化”</a>。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        unique_subquery</p>
      <p> 该类型替换了下面形式的IN子查询的ref：</p>
      <pre><i>value</i> IN (SELECT <i>primary_key</i> FROM <i>single_table</i> WHERE <i>some_expr</i>)</pre>
      <p> unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        index_subquery</p>
      <p> 该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：</p>
      <pre><i>value</i> IN (SELECT <i>key_column</i> FROM <i>single_table</i> WHERE <i>some_expr</i>)</pre>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        range</p>
      <p> 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。在该类型中ref列为NULL。</p>
      <p> 当使用=、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS 
        NULL、&lt;=&gt;、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range：</p>
      <pre>SELECT * FROM <i>tbl_name</i>
WHERE <i>key_column</i> = 10;
&nbsp;
SELECT * FROM <i>tbl_name</i>
WHERE <i>key_column</i> BETWEEN 10 and 20;
&nbsp;
SELECT * FROM <i>tbl_name</i>
WHERE <i>key_column</i> IN (10,20,30);
&nbsp;
SELECT * FROM <i>tbl_name</i>
WHERE <i>key_part1</i>= 10 AND <i>key_part2 IN (10,20,30);</i></pre>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        index</p>
      <p> 该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小。</p>
      <p> 当查询只使用作为单索引一部分的列时，MySQL可以使用该联接类型。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        ALL</p>
      <p> 对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记const的表，这通常不好，并且通常在它情况下<i>很</i>差。通常可以增加更多的索引而不要使用ALL，使得行能基于前面的表中的常数值或列值被检索出。</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        
        possible_keys</p>
      <p> possible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着在possible_keys中的某些键实际上不能按生成的表次序使用。</p>
      <p> 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查WHERE子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用EXPLAIN检查查询。参见<a href="" title="13.1.2. ALTER TABLE Syntax">13.1.2节，“ALTER 
        TABLE语法”</a>。</p>
      <p> 为了看清一张表有什么索引，使用SHOW 
        INDEX FROM <i>tbl_name</i>。</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        
        key</p>
      <p> key列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE 
        INDEX、USE 
        INDEX或者IGNORE 
        INDEX。参见<a href="explain.html" title="13.2.7. SELECT Syntax">13.2.7节，“SELECT语法”</a>。</p>
      <p> 对于MyISAM和BDB表，运行ANALYZE 
        TABLE可以帮助优化器选择更好的索引。对于MyISAM表，可以使用myisamchk 
        --analyze。参见<a href="explain.html" title="13.5.2.1. ANALYZE TABLE Syntax">13.5.2.1节，“ANALYZE 
        TABLE语法”</a>和<a href="" title="5.9.4. Table Maintenance and Crash Recovery">5.9.4节，“表维护和崩溃恢复”</a>。</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        
        key_len</p>
      <p> key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。注意通过key_len值我们可以确定MySQL将实际使用一个多部关键字的几个部分。</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        
        ref</p>
      <p> ref列显示使用哪个列或常数与key一起从表中选择行。</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        rows</p>
      <p> rows列显示MySQL认为它执行查询时必须检查的行数。</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        
        Extra</p>
      <p> 该列包含MySQL解决查询的详细信息。下面解释了该列可以显示的不同的文本字符串：</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        
        Distinct</p>
      <p>MySQL发现第1个匹配行后，停止为当前的行组合搜索更多的行。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        Not exists</p>
      <p> MySQL能够对查询进行LEFT 
        JOIN优化，发现1个匹配LEFT 
        JOIN标准的行后，不再为前面的的行组合在该表内检查更多的行。</p>
      <p> 下面是一个可以这样优化的查询类型的例子：</p>
      <pre>SELECT * 从t1 LEFT JOIN t2 ON t1.id=t2.id
&nbsp; WHERE t2.id IS NULL；</pre>
      <p> 假定t2.id定义为NOT 
        NULL。在这种情况下，MySQL使用t1.id的值扫描t1并查找t2中的行。如果MySQL在t2中发现一个匹配的行，它知道t2.id绝不会为NULL，并且不再扫描t2内有相同的id值的行。换句话说，对于t1的每个行，MySQL只需要在t2中查找一次，无论t2内实际有多少匹配的行。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        range checked 
        for each record (index map: 
        #)</p>
      <p> MySQL没有发现好的可以使用的索引，但发现如果来自前面的表的列值已知，可能部分索引可以使用。对前面的表的每个行组合，MySQL检查是否可以使用range或index_merge访问方法来索取行。关于适用性标准的描述参见<a href="range-optimization.html" title="7.2.5. Range Optimization">7.2.5节，“范围优化”</a>和<a href="index-merge-optimization.html" title="7.2.6. Index Merge Optimization">7.2.6节，“索引合并优化”</a>，不同的是前面表的所有列值已知并且认为是常量。</p>
      <p>这并不很快，但比执行没有索引的联接要快得多。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        Using filesort</p>
      <p> MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。参见<a href="order-by-optimization.html" title="7.2.12. How MySQL Optimizes ORDER BY">7.2.12节，“MySQL如何优化ORDER BY”</a>。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        Using index</p>
      <p> 从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。当查询只使用作为单一索引一部分的列时，可以使用该策略。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        Using temporary</p>
      <p> 为了解决查询，MySQL需要创建一个临时表来容纳结果。典型情况如查询包含可以按不同情况列出列的GROUP 
        BY和ORDER 
        BY子句时。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        Using where</p>
      <p> WHERE子句用于限制哪一个行匹配下一个表或发送到客户。除非你专门从表中索取或检查所有行，如果Extra值不为Using 
        where并且表联接类型为ALL或index，查询可能会有一些错误。</p>
      <p> 如果想要使查询尽可能快，应找出Using 
        filesort 和Using 
        temporary的Extra值。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        Using 
        sort_union(...), 
        Using union(...),
        Using 
        intersect(...)</p>
      <p> 这些函数说明如何为index_merge联接类型合并索引扫描。详细信息参见<a href="index-merge-optimization.html" title="7.2.6. Index Merge Optimization">7.2.6节，“索引合并优化”</a>。</p>
      <p > o&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        Using index for 
        group-by</p>
      <p> 类似于访问表的Using 
        index方式，Using 
        index for group-by表示MySQL发现了一个索引，可以用来查询GROUP 
        BY或DISTINCT查询的所有列，而不要额外搜索硬盘访问实际的表。并且，按最有效的方式使用索引，以便对于每个组，只读取少量索引条目。详情参见<a href="group-by-optimization.html" title="7.2.13. How MySQL Optimizes GROUP BY">7.2.13节，“MySQL如何优化GROUP BY”</a>。</p>
      <p> 通过相乘EXPLAIN输出的rows列的所有值，你能得到一个关于一个联接如何的提示。这应该粗略地告诉你MySQL必须检查多少行以执行查询。当你使用max_join_size变量限制查询时，也用这个乘积来确定执行哪个多表SELECT语句。参见<a href="server-parameters.html" title="7.5.2. Tuning Server Parameters">7.5.2节，“调节服务器参数”</a>。</p>
      <p> 下列例子显示出一个多表JOIN如何能使用EXPLAIN提供的信息逐步被优化。</p>
      <p>假定你有下面所示的SELECT语句，计划使用EXPLAIN来检查它：</p>
      <pre>EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ProjectReference, tt.EstimatedShipDate,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ActualShipDate, tt.ClientID,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ServiceCodes, tt.RepetitiveID,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.CurrentProcess, tt.CurrentDPPerson,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; et_1.COUNTRY, do.CUSTNAME
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FROM tt, et, et AS et_1, do
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE tt.SubmitTime IS NULL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND tt.ActualPC = et.EMPLOYID
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND tt.AssignedPC = et_1.EMPLOYID
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AND tt.ClientID = do.CUSTNMBR;</pre>
      <p> 对于这个例子，假定：</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        被比较的列声明如下：</p>
      <table border="1" cellpadding="0" id="table1">
        <tr>
          <td><p>表</td>
          <td width="113"><p>列</td>
          <td width="105"><p> 列类型</td>
        </tr>
        <tr>
          <td><p> tt</td>
          <td width="113"><p> ActualPC</td>
          <td width="105"><p> CHAR(10)</td>
        </tr>
        <tr>
          <td><p> tt</td>
          <td width="113"><p> AssignedPC</td>
          <td width="105"><p> CHAR(10)</td>
        </tr>
        <tr>
          <td><p> tt</td>
          <td width="113"><p> ClientID</td>
          <td width="105"><p> CHAR(10)</td>
        </tr>
        <tr>
          <td><p> et</td>
          <td width="113"><p> EMPLOYID</td>
          <td width="105"><p> CHAR(15)</td>
        </tr>
        <tr>
          <td><p> do</td>
          <td width="113"><p> CUSTNMBR</td>
          <td width="105"><p> CHAR(15)</td>
        </tr>
      </table>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        表有下面的索引：</p>
      <table border="1" cellpadding="0" id="table2">
        <tr>
          <td><p>表</td>
          <td><p>索引</td>
        </tr>
        <tr>
          <td><p> tt</td>
          <td><p> ActualPC</td>
        </tr>
        <tr>
          <td><p> tt</td>
          <td><p> AssignedPC</td>
        </tr>
        <tr>
          <td><p> tt</td>
          <td><p> ClientID</td>
        </tr>
        <tr>
          <td><p> et</td>
          <td><p> EMPLOYID(主键)</td>
        </tr>
        <tr>
          <td><p> do</td>
          <td><p> CUSTNMBR(主键)</td>
        </tr>
      </table>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        
        tt.ActualPC值不是均匀分布的。</p>
      <p> 开始，在进行优化前，EXPLAIN语句产生下列信息：</p>
      <p>&nbsp; </p>
      <pre>table type possible_keys key&nbsp; key_len ref&nbsp; rows&nbsp; Extra
et&nbsp;&nbsp;&nbsp; ALL&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL NULL&nbsp;&nbsp;&nbsp; NULL 74
do&nbsp;&nbsp;&nbsp; ALL&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL NULL&nbsp;&nbsp;&nbsp; NULL 2135
et_1&nbsp; ALL&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL NULL&nbsp;&nbsp;&nbsp; NULL 74
tt&nbsp;&nbsp;&nbsp; ALL&nbsp; AssignedPC,&nbsp;&nbsp; NULL NULL&nbsp;&nbsp;&nbsp; NULL 3872
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientID,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActualPC
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range checked for each record (key map: 35)
&nbsp;</pre>
      <p> 因为type对每张表是ALL，这个输出显示MySQL正在对所有表产生一个笛卡尔乘积；即每一个行的组合！这将花相当长的时间，因为必须检查每张表的行数的乘积！对于一个实例，这是74 
        * 2135 * 74 * 3872 = 45,268,558,720行。如果表更大，你只能想象它将花多长时间…… </p>
      <p> 这里的一个问题是MySQL能更高效地在声明具有相同类型和尺寸的列上使用索引。在本文中，VARCHAR和CHAR是相同的，除非它们声明为不同的长度。因为tt.ActualPC被声明为CHAR(10)并且et.EMPLOYID被声明为CHAR(15)，长度不匹配。</p>
      <p> 为了修正在列长度上的不同，使用ALTER 
        TABLE将ActualPC的长度从10个字符变为15个字符：</p>
      <pre>mysql&gt; ALTER TABLE tt MODIFY ActualPC VARCHAR(15);</pre>
      <p> 现在tt.ActualPC和et.EMPLOYID都是VARCHAR(15)，再执行EXPLAIN语句产生这个结果：</p>
      <p>&nbsp; </p>
      <pre>table type&nbsp;&nbsp; possible_keys key&nbsp;&nbsp;&nbsp;&nbsp; key_len ref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows&nbsp;&nbsp;&nbsp; Extra
tt&nbsp;&nbsp;&nbsp; ALL &nbsp;&nbsp;&nbsp;AssignedPC,&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3872&nbsp;&nbsp;&nbsp; Using
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActualPC
do&nbsp;&nbsp;&nbsp; ALL&nbsp;&nbsp;&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2135
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range checked for each record (key map: 1)
et_1&nbsp; ALL&nbsp;&nbsp;&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 74
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; range checked for each record (key map: 1)
et&nbsp;&nbsp;&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ActualPC 1
&nbsp;</pre>
      <p> 这不是完美的，但是好一些了：rows值的乘积少了一个因子74。这个版本在几秒内执行完。</p>
      <p> 第2种方法能消除tt.AssignedPC 
        = et_1.EMPLOYID和tt.ClientID 
        = do.CUSTNMBR比较的列的长度失配问题：</p>
      <pre>mysql&gt; ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MODIFY ClientID&nbsp;&nbsp; VARCHAR(15);</pre>
      <p>EXPLAIN产生的输出显示在下面：</p>
      <pre>table type&nbsp;&nbsp; possible_keys key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key_len ref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows Extra
et&nbsp;&nbsp;&nbsp; ALL&nbsp;&nbsp;&nbsp; PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 74
tt&nbsp;&nbsp;&nbsp; ref&nbsp;&nbsp;&nbsp; AssignedPC,&nbsp;&nbsp; ActualPC 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; et.EMPLOYID&nbsp;&nbsp; 52&nbsp;&nbsp; Using
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActualPC
et_1&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.AssignedPC 1
do&nbsp;&nbsp;&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ClientID&nbsp;&nbsp; 1
&nbsp;</pre>
      <p> 这几乎很好了。 </p>
      <p> 剩下的问题是，默认情况，MySQL假设在tt.ActualPC列的值是均匀分布的，并且对tt表不是这样。幸好，很容易告诉MySQL来分析关键字分布：</p>
      <pre>mysql&gt; ANALYZE TABLE tt；</pre>
      <p> 现在联接是“完美”的了，而且EXPLAIN产生这个结果：</p>
      <pre>table type&nbsp;&nbsp; possible_keys key&nbsp;&nbsp;&nbsp;&nbsp; key_len ref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows Extra
tt&nbsp;&nbsp;&nbsp; ALL&nbsp;&nbsp;&nbsp; AssignedPC&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp; NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3872 Using
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientID,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ActualPC
et&nbsp;&nbsp;&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ActualPC&nbsp;&nbsp; 1
et_1&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.AssignedPC 1
do&nbsp;&nbsp;&nbsp; eq_ref PRIMARY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PRIMARY 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tt.ClientID&nbsp;&nbsp; 1</pre>
      <p>注意在从EXPLAIN输出的rows列是一个来自MySQL联接优化器的“教育猜测”。你应该检查数字是否接近事实。如果不是，可以通过在SELECT语句里面使用STRAIGHT_JOIN并且试着在FROM子句以不同的次序列出表，可能得到更好的性能。
    
    
      
        
          
            


<!--start of htmlend-->
<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->