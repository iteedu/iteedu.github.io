<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->

<!--end of htmlmiddle-->



<h1> 18.3.1.&nbsp;RANGE和LIST分区的管理</h1>

          
        
      
      
      <p>关于如何添加和删除分区的处理，RANGE和LIST分区非常相似。基于这个原因，我们在本节讨论这两种分区的管理。关于HASH和KEY分区管理的信息，请参见<a href="partitioning-management-hash-key.html" title="18.3.2. Management of HASH and KEY Partitions">18.3.2节，“HASH和KEY分区的管理”</a>。删除一个RANGE或LIST分区比增加一个分区要更加简单易懂，所以我们先讨论前者。</p>
      <p>从一个按照RANGE或LIST分区的表中删除一个分区，可以使用带一个DROP 
        PARTITION子句的ALTER 
        TABLE命令来实现。这里有一个非常基本的例子，假设已经使用下面的CREATE 
        TABLE和INSERT语句创建了一个按照RANGE分区的表，并且已经插入了10条记录：</p>
      <pre>mysql&gt; CREATE TABLE tr (id INT, name VARCHAR(50), purchased DATE)
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; PARTITION BY RANGE(YEAR(purchased))
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; (
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARTITION p0 VALUES LESS THAN (1990),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARTITION p1 VALUES LESS THAN (1995),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARTITION p2 VALUES LESS THAN (2000),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PARTITION p3 VALUES LESS THAN (2005)
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; );
Query OK, 0 rows affected (0.01 sec)
&nbsp;
mysql&gt; INSERT INTO tr VALUES
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; (1, &#39;desk organiser&#39;, &#39;2003-10-15&#39;),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; (2, &#39;CD player&#39;, &#39;1993-11-05&#39;),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; (3, &#39;TV set&#39;, &#39;1996-03-10&#39;),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; (4, &#39;bookcase&#39;, &#39;1982-01-10&#39;),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; (5, &#39;exercise bike&#39;, &#39;2004-05-09&#39;),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; (6, &#39;sofa&#39;, &#39;1987-06-05&#39;),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; (7, &#39;popcorn maker&#39;, &#39;2001-11-22&#39;),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; (8, &#39;aquarium&#39;, &#39;1992-08-04&#39;),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; (9, &#39;study desk&#39;, &#39;1984-09-16&#39;),
&nbsp;&nbsp;&nbsp; -&gt;&nbsp;&nbsp;&nbsp;&nbsp; (10, &#39;lava lamp&#39;, &#39;1998-12-25&#39;);
Query OK, 10 rows affected (0.01 sec)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre>
      <p>可以通过使用下面的命令查看那些记录已经插入到了分区p2中： </p>
      <pre>mysql&gt; SELECT * FROM tr
&nbsp;&nbsp;&nbsp; -&gt; WHERE purchased BETWEEN &#39;1995-01-01&#39; AND &#39;1999-12-31&#39;;
+------+-----------+------------+
| id&nbsp;&nbsp; | name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | purchased&nbsp; |
+------+-----------+------------+
|&nbsp;&nbsp;&nbsp; 3 | TV set&nbsp;&nbsp;&nbsp; | 1996-03-10 |
|&nbsp;&nbsp; 10 | lava lamp | 1998-12-25 |
+------+-----------+------------+
2 rows in set (0.00 sec)</pre>
      <p>要删除名字为p2的分区，执行下面的命令： </p>
      <pre>mysql&gt; ALTER TABLE tr DROP PARTITION p2;
Query OK, 0 rows affected (0.03 sec)</pre>
      <p>记住下面一点非常重要：<em>当删除了一个分区，也同时删除了该分区中所有的数据。</em>可以通过重新运行前面的SELECT查询来验证这一点： </p>
      <pre>mysql&gt; SELECT * FROM tr WHERE purchased 
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; BETWEEN &#39;1995-01-01&#39; AND &#39;1999-12-31&#39;;
Empty set (0.00 sec)</pre>
      <p>如果希望从所有分区删除所有的数据，但是又保留表的定义和表的分区模式，使用TRUNCATE 
        TABLE命令。（请参见<a href="" title="13.2.9. TRUNCATE Syntax">13.2.9节，“TRUNCATE语法”</a>）。 </p>
      <p>如果希望改变表的分区而又不丢失数据，使用“ALTER 
        TABLE ... REORGANIZE PARTITION”语句。参见下面的内容，或者在<a href="partitioning-management-range-list.html" title="13.1.2. ALTER TABLE Syntax">13.1.2节，“ALTER 
        TABLE语法”</a> 中参考关于REORGANIZE 
        PARTITION的信息。 </p>
      <p>如果现在执行一个SHOW CREATE 
        TABLE命令，可以观察到表的分区结构是如何被改变的：</p>
      <pre>mysql&gt; SHOW CREATE TABLE tr\G
*************************** 1. row ***************************
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table: tr
Create Table: CREATE TABLE `tr` (
&nbsp; `id` int(11) default NULL,
&nbsp; `name` varchar(50) default NULL,
&nbsp; `purchased` date default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1 
PARTITION BY RANGE (YEAR(purchased)) (
&nbsp; PARTITION p0 VALUES LESS THAN (1990) ENGINE = MyISAM, 
&nbsp;&nbsp;PARTITION p1 VALUES LESS THAN (1995) ENGINE = MyISAM, 
&nbsp;&nbsp;PARTITION p3 VALUES LESS THAN (2005) ENGINE = MyISAM
)
1 row in set (0.01 sec)</pre>
      <p>如果插入购买日期列的值在&#39;1995-01-01&#39;和 
        &#39;2004-12-31&#39;之间（含）的新行到已经修改后的表中时，这些行将被保存在分区p3中。可以通过下面的方式来验证这一点：</p>
      <pre>mysql&gt; INSERT INTO tr VALUES (11, &#39;pencil holder&#39;, &#39;1995-07-12&#39;);
Query OK, 1 row affected (0.00 sec)
&nbsp;
mysql&gt; SELECT * FROM tr WHERE purchased 
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; BETWEEN &#39;1995-01-01&#39; AND &#39;2004-12-31&#39;;
+------+----------------+------------+
| id&nbsp;&nbsp; | name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | purchased&nbsp; |
+------+----------------+------------+
|&nbsp;&nbsp; 11 | pencil holder&nbsp; | 1995-07-12 |
|&nbsp;&nbsp;&nbsp; 1 | desk organiser | 2003-10-15 |
|&nbsp;&nbsp;&nbsp; 5 | exercise bike&nbsp; | 2004-05-09 |
|&nbsp;&nbsp;&nbsp; 7 | popcorn maker&nbsp; | 2001-11-22 |
+------+----------------+------------+
4 rows in set (0.00 sec)
&nbsp;
mysql&gt; ALTER TABLE tr DROP PARTITION p3;
Query OK, 0 rows affected (0.03 sec)
&nbsp;
mysql&gt; SELECT * FROM tr WHERE purchased 
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; BETWEEN &#39;1995-01-01&#39; AND &#39;2004-12-31&#39;;
Empty set (0.00 sec)</pre>
      <p>注意：由“ALTER TABLE 
        ... DROP PARTITION”语句引起的、从表中删除的行数并没有被服务器报告出来，就好像通过同等的DELETE查询操作一样。 </p>
      <p>删除LIST分区使用和删除RANGE分区完全相同的“ALTER 
        TABLE ... DROP PARTITION”语法。但是，在对其后使用这个表的影响方面，还是有重大的区别：在这个表中，再也不能插入这么一些行，这些行的列值包含在定义已经删除了的分区的值列表中 
        (有关示例，请参见<a href="partitioning-list.html" title="18.2.2. LIST Partitioning">18.2.2节，“LIST分区”</a> ）。 </p>
      <p>要增加一个新的RANGE或LIST分区到一个前面已经分区了的表，使用“ALTER 
        TABLE ... ADD PARTITION”语句。对于使用RANGE分区的表，可以用这个语句添加新的区间到已有分区的序列的前面或后面。例如，假设有一个包含你所在组织的全体成员数据的分区表，该表的定义如下：</p>
      <pre>CREATE TABLE members (
&nbsp;&nbsp;&nbsp; id INT, 
&nbsp;&nbsp;&nbsp;&nbsp;fname VARCHAR(25),
&nbsp;&nbsp;&nbsp; lname VARCHAR(25), 
&nbsp;&nbsp;&nbsp;&nbsp;dob DATE
)
PARTITION BY RANGE(YEAR(dob)) (
&nbsp;&nbsp;&nbsp; PARTITION p0 VALUES LESS THAN (1970),
&nbsp;&nbsp;&nbsp; PARTITION p1 VALUES LESS THAN (1980),
&nbsp;&nbsp;&nbsp; PARTITION p2 VALUES LESS THAN (1990)
);</pre>
      <p>进一步假设成员的最小年纪是16岁。随着日历接近2005年年底，你会认识到不久将要接纳1990年（以及以后年份）出生的成员。可以按照下面的方式，修改成员表来容纳出生在1990－1999年之间的成员：</p>
      <pre>ALTER TABLE ADD PARTITION (PARTITION p3 VALUES LESS THAN (2000));</pre>
      <p>要点：对于通过RANGE分区的表，只可以使用ADD 
        PARTITION添加新的分区到分区列表的高端。设法通过这种方式在现有分区的前面或之间增加一个新的分区，将会导致下面的一个错误：</p>
      <pre>mysql&gt; ALTER TABLE members ADD PARTITION (PARTITION p3 VALUES LESS THAN (1960));
错误1463 (HY000): 对每个分区，VALUES LESS THAN 值必须严格增长</pre>
      <p>采用一个类似的方式，可以增加新的分区到已经通过LIST分区的表。例如，假定有如下定义的一个表：</p>
      <pre>CREATE TABLE tt (
&nbsp;&nbsp;&nbsp; id INT, 
&nbsp;&nbsp;&nbsp;&nbsp;data INT
)
PARTITION BY LIST(data) (
&nbsp;&nbsp;&nbsp; PARTITION p0 VALUES IN (5, 10, 15),
&nbsp;&nbsp;&nbsp; PARTITION p1 VALUES IN (6, 12, 18)
)；</pre>
      <p>可以通过下面的方法添加一个新的分区，用来保存拥有数据列值7，14和21的行：</p>
      <pre>ALTER TABLE tt ADD PARTITION (PARTITION p2 VALUES IN (7, 14, 21))；</pre>
      <p>注意：不能添加这样一个新的LIST分区，该分区包含有已经包含在现有分区值列表中的任意值。如果试图这样做，将会导致错误：</p>
      <pre>mysql&gt; ALTER TABLE tt ADD PARTITION (PARTITION np VALUES IN (4, 8, 12));
错误1465 (HY000): 在LIST分区中，同一个常数的多次定义</pre>
      <p>因为带有数据列值12的任何行都已经分配给了分区p1，所以不能在表tt上再创建一个其值列表包括12的新分区。为了实现这一点，可以先删除分区p1，添加分区np，然后使用修正后的定义添加一个新的分区p1。但是，正如我们前面讨论过的，这将导致保存在分区p1中的所有数据丢失——而这往往并不是你所真正想要做的。另外一种解决方法可能是，建立一个带有新分区的表的副本，然后使用“CREATE 
        TABLE ... SELECT ...”把数据拷贝到该新表中，然后删除旧表，重新命名新表，但是，当需要处理大量的数据时，这可能是非常耗时的。在需要高可用性的场合，这也可能是不可行的。 </p>
      <p>幸运地是，MySQL 
        的分区实现提供了在不丢失数据的条件下重新定义分区的方式。让我们首先看两个涉及到RANGE分区的简单例子。回想一下现在定义如下的成员表： </p>
      <pre>mysql&gt; SHOW CREATE TABLE members\G
*************************** 1. row ***************************
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Table: members
Create Table: CREATE TABLE `members` (
&nbsp; `id` int(11) default NULL,
&nbsp; `fname` varchar(25) default NULL,
&nbsp; `lname` varchar(25) default NULL,
&nbsp; `dob` date default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1 
PARTITION BY RANGE (YEAR(dob)) (
&nbsp; PARTITION p0 VALUES LESS THAN (1970) ENGINE = MyISAM, 
&nbsp;&nbsp;PARTITION p1 VALUES LESS THAN (1980) ENGINE = MyISAM, 
&nbsp;&nbsp;PARTITION p2 VALUES LESS THAN (1990) ENGINE = MyISAM.
&nbsp; PARTITION p3 VALUES LESS THAN (2000) ENGINE = MyISAM
)</pre>
      <p>假定想要把表示出生在1960年前成员的所有行移入到一个分开的分区中。正如我们前面看到的，不能通过使用“ALTER 
        TABLE ... ADD PARTITION”来实现这一点。但是，要实现这一点，可以使用ALTER 
        TABLE上的另外一个与分区有关的扩展，具体实现如下： </p>
      <pre>ALTER TABLE members REORGANIZE PARTITION p0 INTO (
&nbsp;&nbsp;&nbsp; PARTITION s0 VALUES LESS THAN (1960),
&nbsp;&nbsp;&nbsp; PARTITION s1 VALUES LESS THAN (1970)
)；</pre>
      <p>实际上，这个命令把分区p0分成了两个新的分区s0和s1。同时，它还根据包含在两个“PARTITION 
        ... VALUES ...”子句中的规则，把保存在分区p0中的数据移入到两个新的分区中，所以分区s0中只包含YEAR(dob)小于1960的那些行，s1中包含那些YEAR(dob)大于或等于1960但是小于1970的行。 </p>
      <p>一个REORGANIZE 
        PARTITION语句也可以用来合并相邻的分区。可以使用如下的语句恢复成员表到它以前的分区： </p>
      <pre>ALTER TABLE members REORGANIZE PARTITION s0,s1 INTO (
&nbsp;&nbsp;&nbsp; PARTITION p0 VALUES LESS THAN (1970)
)；</pre>
      <p>使用“REORGANIZE 
        PARTITION”拆分或合并分区，没有数据丢失。在执行上面的语句中，MySQL
        把保存在分区s0和s1中的所有数据都移到分区p0中。</p>
      <p>“REORGANIZE 
        PARTITION”的基本语法是：</p>
      <pre>ALTER TABLE <i>tbl_name</i> REORGANIZE PARTITION <i>partition_list</i> INTO (<i>partition_definitions</i>)；</pre>
      <p>其中，<i>tbl_name</i> 是分区表的名称，<i>partition_list</i> 是通过逗号分开的、一个或多个将要被改变的现有分区的列表。<i>partition_definitions</i> 是一个是通过逗号分开的、新分区定义的列表，它遵循与用在“CREATE 
        TABLE”中的<i>partition_definitions</i> 相同的规则 (请参见<a href="partitioning-list.html" title="13.1.5. CREATE TABLE Syntax">13.1.5节，“CREATE 
        TABLE语法”</a>)。应当注意到，在把多少个分区合并到一个分区或把一个分区拆分成多少个分区方面，没有限制。例如，可以重新组织成员表的四个分区成两个分区，具体实现如下：</p>
      <pre>ALTER TABLE members REORGANIZE PARTITION p0,p1,p2,p3 INTO (
&nbsp;&nbsp;&nbsp; PARTITION m0 VALUES LESS THAN (1980),
&nbsp;&nbsp;&nbsp; PARTITION m1 VALUES LESS THAN (2000)
)；</pre>
      <p>同样，对于按LIST分区的表，也可以使用REORGANIZE 
        PARTITION。让我们回到那个问题，即增加一个新的分区到已经按照LIST分区的表tt中，但是因为该新分区有一个值已经存在于现有分区的值列表中，添加新的分区失败。我们可以通过先添加只包含非冲突值的分区，然后重新组织该新分区和现有的那个分区，以便保存在现有的那个分区中的值现在移到了新的分区中，来处理这个问题：</p>
      <pre>ALTER TABLE tt ADD PARTITION (PARTITION np VALUES IN (4, 8));
ALTER TABLE tt REORGANIZE PARTITION p1,np INTO (
&nbsp;&nbsp;&nbsp; PARTITION p1 VALUES IN (6, 18),
&nbsp;&nbsp;&nbsp; PARTITION np VALUES in (4, 8, 12)
)；</pre>
      <p>当使用“ALTER TABLE ... 
        REORGANIZE PARTITION”来对已经按照RANGE和LIST分区表进行重新分区时，下面是一些要记住的关键点：</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        用来确定新分区模式的PARTITION子句使用与用在CREATE 
        TABLE中确定分区模式的PARTITION子句相同的规则。</p>
      <p>最重要的是，应该记住：新分区模式不能有任何重叠的区间（适用于按照RANGE分区的表）或值集合（适用于重新组织按照LIST分区的表）。</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i> partition_definitions</i> 列表中分区的合集应该与在<i>partition_list</i> 中命名分区的合集占有相同的区间或值集合。 </p>
      <p>例如，在本节中用作例子的成员表中，分区p1和p2总共覆盖了1980到1999的这些年。因此，对这两个分区的重新组织都应该覆盖相同范围的年份。</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        对于按照RANGE分区的表，只能重新组织相邻的分区；不能跳过RANGE分区。 </p>
      <p>例如，不能使用以“ALTER 
        TABLE members REORGANIZE PARTITION p0,p2 INTO ...”开头的语句，来重新组织本节中用作例子的成员表。因为，p0覆盖了1970年以前的年份，而p2覆盖了从1990到1999（包括1990和1999）之间的年份，因而这两个分区不是相邻的分区。</p>
      <p> ·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        不能使用REORGANIZE 
        PARTITION来改变表的分区类型；也就是说，例如，不能把RANGE分区变为HASH分区，反之亦然。也不能使用该命令来改变分区表达式或列。如果想在不删除和重建表的条件下实现这两个任务，可以使用“ALTER 
        TABLE ... PARTITION BY ....”，例如： </p>
      <pre>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ALTER TABLE members 
·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;PARTITION BY HASH(YEAR(dob))
·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;PARTITIONS 8；</pre>
      <p> 注释：在MySQL 
        5.1发布前的版本中，“ALTER 
        TABLE ... PARTITION BY ...”还没有实现。作为替代，要么使用先删除表，然后使用想要的分区重建表，或者——如果需要保留已经存储在表中的数据——可以使用“CREATE 
        TABLE ... SELECT ...”来创建新的表，然后从旧表中把数据拷贝到新表中，再删除旧表，如有必要，最后重新命名新表。 
    
    
      
        
          
            


<!--start of htmlend-->
<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->