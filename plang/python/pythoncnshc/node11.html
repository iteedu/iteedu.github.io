<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->


<DIV CLASS="navigation">
<div id='top-navigation-panel' xml:id='top-navigation-panel'>
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="8. 错误和异常 Errors and"
  href="node10.html"><img src='icons/previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></A></td>
<td class='online-navigation'><a rel="parent" title="Python Tutorial"
  href="tut.html"><img src='icons/up.png'
  border='0' height='32'  alt='Up One Level' width='32' /></A></td>
<td class='online-navigation'><a rel="next" title="10. 标准库概览 Brief Tour"
  href="node12.html"><img src='icons/next.png'
  border='0' height='32'  alt='Next Page' width='32' /></A></td>
<td align="center" width="100%" class='online-navigation'>Python Tutorial</td>
<td class='online-navigation'><a rel="contents" title="Table of Contents"
  href="node2.html"><img src='icons/contents.png'
  border='0' height='32'  alt='Contents' width='32' /></A></td>
<td class='online-navigation'><img src='icons/blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><img src='icons/blank.png'
  border='0' height='32'  alt='' width='32' /></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="node10.html">8. 错误和异常 Errors and</A>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="tut.html">Python Tutorial</A>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="node12.html">10. 标准库概览 Brief Tour</A>
</div>
<hr /></div>
</DIV>
<!--End of Navigation Panel-->
<div class='online-navigation'>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></a>

<UL CLASS="ChildLinks">
<LI><A href="node11.html#SECTION0011100000000000000000">9.1 有关术语的话题 A Word About Terminology</a>
<LI><A href="node11.html#SECTION0011200000000000000000">9.2 Python 作用域和命名空间 Python Scopes and Name Spaces</a>
<LI><A href="node11.html#SECTION0011300000000000000000">9.3 初识类 A First Look at Classes</a>
<UL>
<LI><A href="node11.html#SECTION0011310000000000000000">9.3.1 类定义语法 Class Definition Syntax</a>
<LI><A href="node11.html#SECTION0011320000000000000000">9.3.2 类对象 Class Objects</a>
<LI><A href="node11.html#SECTION0011330000000000000000">9.3.3 实例对象 Instance Objects</a>
<LI><A href="node11.html#SECTION0011340000000000000000">9.3.4 方法对象 Method Objects</a>
</ul>
<LI><A href="node11.html#SECTION0011400000000000000000">9.4 一些说明 Random Remarks</a>
<LI><A href="node11.html#SECTION0011500000000000000000">9.5 继承 Inheritance</a>
<UL>
<LI><A href="node11.html#SECTION0011510000000000000000">9.5.1 多继承 Multiple Inheritance</a>
</ul>
<LI><A href="node11.html#SECTION0011600000000000000000">9.6 私有变量 Private Variables</a>
<LI><A href="node11.html#SECTION0011700000000000000000">9.7 补充 Odds and Ends</a>
<LI><A href="node11.html#SECTION0011800000000000000000">9.8 异常也是类 Exceptions Are Classes Too</a>
<LI><A href="node11.html#SECTION0011900000000000000000">9.9 迭代器 Iterators</a>
<LI><A href="node11.html#SECTION00111000000000000000000">9.10 生成器 Generators</a>
</ul>
<!--End of Table of Child-Links-->
</div>
<HR>

<H1><A NAME="SECTION0011000000000000000000"></A><A NAME="classes"></A>
<BR>
9. 类 Classes 
</H1>

<P>
Python 在尽可能不增加新的语法和语义的情况下加入了类机制。这种机制是 C++ 和 Modula-3 的混合。Python中的类没有在用户和定义之间建立一个绝对的屏障，而是依赖于用户自觉的不去“破坏定义”。然而，类机制最重要的功能都完整的保留下来。类继承机制允许多继承，派生类可以覆盖（override）基类中的任何方法，方法中可以调用基类中的同名方法。对象可以包含任意数量的私有成员。
<P>
用 C++ 术语来讲，所有的类成员（包括数据成员）都是公有（ <em>public</em> ）的，所有的成员函数都是虚拟（ <em>virtual</em> ）的。没有特定的构造和析构函数。用Modula-3的术语来讲，在成员方法中没有什么简便的方式（shorthands）可以引用对象的成员：方法函数在定义时需要以引用的对象做为第一个参数，调用时则会隐式引用对象。这样就形成了语义上的引入和重命名。（ This provides semantics for importing and renaming. ）但是，像 C++ 而非 Modula-3 中那样，大多数带有特殊语法的内置操作符（算法运算符、下标等）都可以针对类的需要重新定义。
<H1><A NAME="SECTION0011100000000000000000"></A><A NAME="terminology"></A>
<BR>
9.1 有关术语的话题 A Word About Terminology 
</H1>

<P>
由于没有什么关于类的通用术语，我从 Smalltalk 和 C++ 中借用一些（我更希望用 Modula-3 的，因为它的面向对象机制比 C++更接近Python，不过我想没多少读者听说过它）。
<P>
我要提醒读者，这里有一个面向对象方面的术语陷阱，在 Python 中“对象”这个词不一定指类实例。Python 中并非所有的类型都是类：例如整型、链表这些内置数据类型就不是，甚至某些像文件这样的外部类型也不是，这一点类似于 C++ 和 Modula-3，而不像 Smalltalk。然而，所有的 Python 类型在语义上都有一点相同之处：描述它们的最贴切词语是“对象”。
<P>
对象是被特化的，多个名字（在多个作用域中）可以绑定同一个对象。这相当于其它语言中的别名。通常对 Python 的第一印象中会忽略这一点，使用那些不可变的基本类型（数值、字符串、元组）时也可以很放心的忽视它。然而，在 Python 代码调用字典、链表之类可变对象，以及大多数涉及程序外部实体（文件、窗体等等）的类型时，这一语义就会有影响。这通用有助于优化程序，因为别名的行为在某些方面类似于指针。例如，很容易传递一个对象，因为在行为上只是传递了一个指针。如果函数修改了一个通过参数传递的对象，调用者可以接收到变化－－在 Pascal 中这需要两个不同的参数传递机制。
<H1><A NAME="SECTION0011200000000000000000"></A><A NAME="scopes"></A>
<BR>
9.2 Python 作用域和命名空间 Python Scopes and Name Spaces 
</H1>

<P>
在介绍类之前，我首先介绍一些有关 Python 作用域的规则：类的定义非常巧妙的运用了命名空间，要完全理解接下来的知识，需要先理解作用域和命名空间的工作原理。另外，这一切的知识对于任何高级 Python 程序员都非常有用。
<P>
我们从一些定义开始。
<P>
<em>命名空间</em>是从命名到对象的映射。当前<em>命名空间</em>主要是通过 Python 字典实现的，不过通常不关心具体的实现方式（除非出于性能考虑），以后也有可能会改变其实现方式。以下有一些命名空间的例子：内置命名（像 <tt class="function"><</tt>#2558#>abs() 这样的函数，以及内置异常名）集，模块中的全局命名，函数调用中的局部命名。某种意义上讲对象的属性集也是一个<em>命名空间</em>。关于<em>命名空间</em>需要了解的一件很重要的事就是不同<em>命名空间</em>中的命名没有任何联系，例如两个不同的模块可能都会定义一个名为“maximize”的函数而不会发生混淆－－用户必须以模块名为前缀来引用它们。
<P>
顺便提一句，我称 Python 中任何一个“.”之后的命名为<em>属性</em>－－例如，表达式 <code>z.real</code> 中的 <code>real</code> 是对象 <code>z</code> 的一个属性。严格来讲，从模块中引用命名是引用属性：表达式 <code>modname.funcname</code> 中， <code>modname</code> 是一个模块对象，<code>funcname</code> 是它的一个属性。因此，模块的属性和模块中的全局命名有直接的映射关系：它们共享同一命名空间！<A NAME="tex2html10"
  HREF="#foot1679"><SUP>9.2</SUP></A>
<P> 属性可以是只读过或写的。后一种情况下，可以对属性赋值。你可以这样作：
"<tt class="samp">modname.the_answer = 42</tt>"。可写的属性也可以用 <tt class="keyword">del</tt> 语句删除。例如："<tt class="samp">del modname.the_answer</tt>" 会从 <code>modname</code> 对象中删除 <tt class="member">the_answer</tt> 属性。
<P>
不同的命名空间在不同的时刻创建，有不同的生存期。包含内置命名的命名空间在 Python 解释器启动时创建，会一直保留，不被删除。模块的全局命名空间在模块定义被读入时创建，通常，模块命名空间也会一直保存到解释器退出。由解释器在最高层调用执行的语句，不管它是从脚本文件中读入还是来自交互式输入，都是 __main__ 模块的一部分，所以它们也拥有自己的命名空间。（内置命名也同样被包含在一个模块中，它被称作 __builtin__ 。）
<P>
当函数被调用时创建一个局部命名空间，函数反正返回过抛出一个未在函数内处理的异常时删除。（实际上，说是遗忘更为贴切）。当然，每一个递归调用拥有自己的命名空间。
<P>
尽管作用域是静态定义，在使用时他们都是动态的。每次执行时，至少有三个命名空间可以直接访问的作用域嵌套在一起：包含局部命名的使用域在最里面，首先被搜索；其次搜索的是中层的作用域，这里包含了同级的函数；最后搜索最外面的作用域，它包含内置命名。
<P>
尽管作用域是静态定义，在使用时他们都是动态的。每次执行时，至少有三个命名空间可以直接访问的作用域嵌套在一起：包含局部命名的使用域在最里面，首先被搜索；其次搜索的是中层的作用域，这里包含了同级的函数；最后搜索最外面的作用域，它包含内置命名。
<P>
如果一个命名声明为全局的，那么所有的赋值和引用都直接针对包含模全局命名的中级作用域。另外，从外部访问到的所有内层作用域的变量都是只读的。
<P>
从文本意义上讲，局部作用域引用当前函数的命名。在函数之外，局部作用域与全局使用域引用同一命名空间：模块命名空间。类定义也是局部作用域中的另一个命名空间。
<P>
作用域决定于源程序的文本：一个定义于某模块中的函数的全局作用域是该模块的命名空间，而不是该函数的别名被定义或调用的位置，了解这一点非常重要。另一方面，命名的实际搜索过程是动态的，在运行时确定的——然而，Python 语言也在不断发展，以后有可能会成为静态的“编译”时确定，所以不要依赖于动态解析！（事实上，局部变量已经是静态确定了。）
<P> Python 的一个特别之处在于其赋值操作总是在最里层的作用域。赋值不会复制数据——只是将命名绑定到对象。删除也是如此："<tt class="samp">del
x</tt>" 只是从局部作用域的命名空间中删除命名 <code>x</code> 。事实上，所有引入新命名的操作都作用于局部作用域。特别是 import 语句和函数定将模块名或函数绑定于局部作用域。（可以使用 global 语句将变量引入到全局作用域。）
<H1><A NAME="SECTION0011300000000000000000"></A><A NAME="firstClasses"></A>
<BR>
9.3 初识类 A First Look at Classes 
</H1>

<P>
类引入了一点新的语法，三种新的对象类型，以及一些新的语义。
<H2><A NAME="SECTION0011310000000000000000"></A><A NAME="classDefinition"></A>
<BR>
9.3.1 类定义语法 Class Definition Syntax 
</H2>

<P>
最简单的类定义形式如下：
<div class="verbatim"><pre>
class ClassName:
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</pre></div>

<P>
类的定义就像函数定义（ <tt class="keyword">def</tt> 语句），要先执行才能生效。（你当然可以把它放进 <tt class="keyword">if</tt> 语句的某一分支，或者一个函数的内部。）
<P>
习惯上，类定义语句的内容通常是函数定义，不过其它语句也可以，有时会很有用——后面我们再回过头来讨论。类中的函数定义通常包括了一个特殊形式的参数列表，用于方法调用约定——同样我们在后面讨论这些。

<P>
定义一个类的时候，会创建一个新的命名空间，将其作为局部作用域使用——因此，所以对局部变量的赋值都引入新的命名空间。特别是函数定义将新函数的命名绑定于此。
<P>
类定义完成时（正常退出），就创建了一个<em>类对象</em>。基本上它是对类定义创建的命名空间进行了一个包装；我们在下一节进一步学习类对象的知识。原始的局部作用域（类定义引入之前生效的那个）得到恢复，类对象在这里绑定到类定义头部的类名（例子中是 <tt class="class">ClassName</tt> ）。
<H2><A NAME="SECTION0011320000000000000000"></A><A NAME="classObjects"></A>
<BR>
9.3.2 类对象 Class Objects 
</H2>

<P>
类对象支持两种操作：属性引用和实例化。
<P>属性引用使用和 Python 中所有的属性引用一样的标准语法：<code>obj.name</code>。类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样：
<div class="verbatim"><pre>
class MyClass:
    "A simple example class"
    i = 12345
    def f(self):
        return 'hello world'
</pre></div>

<P>
那么 <code>MyClass.i</code> 和 <code>MyClass.f</code> 是有效的属性引用，分别返回一个整数和一个方法对象。也可以对类属性赋值，你可以通过给<code>MyClass.i</code> 赋值来修改它。 <tt class="member">__doc__</tt> 也是一个有效的属性，返回类的文档字符串： <code>"A simple example class"</code>。
<P>
类的实例化使用函数符号。只要将类对象看作是一个返回新的类实例的无参数函数即可。例如（假设沿用前面的类）：
<div class="verbatim"><pre>
x = MyClass()
</pre></div>

<P>
以上创建了一个新的类<em>实例</em>并将该对象赋给局部变量 <code>x</code>。
<P>
这个实例化操作（“调用”一个类对象）来创建一个空的对象。很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为
  <tt class="method">__init__()</tt> 的特殊方法，像下面这样：
<P>
<div class="verbatim"><pre>
    def __init__(self):
        self.data = []
</pre></div>

<P>
类定义了 <tt class="method">__init__()</tt> 方法的话，类的实例化操作会自动为新创建的类实例调用 <tt class="method">__init__()</tt> 方法。所以在下例中，可以这样创建一个新的实例：
<div class="verbatim"><pre>
x = MyClass()
</pre></div>

<P>
当然，出于弹性的需要， <tt class="method">__init__()</tt> 方法可以有参数。事实上，参数通过 <tt class="method">__init__()</tt> 传递到类的实例化操作上。例如：
<P>
<div class="verbatim">
<pre>
&gt;&gt;&gt; class Complex:
...     def __init__(self, realpart, imagpart):
...         self.r = realpart
...         self.i = imagpart
...
&gt;&gt;&gt; x = Complex(3.0, -4.5)
&gt;&gt;&gt; x.r, x.i
(3.0, -4.5)

</pre></div>

<H2><A NAME="SECTION0011330000000000000000"></A><A NAME="instanceObjects"></A>
<BR>
9.3.3 实例对象 Instance Objects 
</H2>

<P>
现在我们可以用实例对象作什么？实例对象唯一可用的操作就是属性引用。有两种有效的属性名。
<P>
第一种称作数据属性。这相当于 Smalltalk 中的“实例变量”或 C++中的“数据成员”。和局部变量一样，数据属性不需要声明，第一次使用时它们就会生成。例如，如果 <code>x</code> 是前面创建的 <tt class="class">MyClass</tt> 实例，下面这段代码会打印出 <code>16</code> 而不会有任何多余的残留：
<div class="verbatim"><pre>
x.counter = 1
while x.counter &lt; 10:
    x.counter = x.counter * 2
print x.counter
del x.counter
</pre></div>

<P>
第二种为实例对象所接受的引用属性是方法。方法是属于一个对象的函数。（在 Python 中，方法不止是类实例所独有：其它类型的对象也可有<em>方法</em>。例如，链表对象有 append，insert，remove，sort 等等方法。然而，在这里，除非特别说明，我们提到的方法特指类方法）
<P>
实例对象的有效名称依赖于它的类。按照定义，类中所有（用户定义）的函数对象对应它的实例中的方法。所以在我们的例子中，<code>x.f</code> 是一个有效的方法引用，因为 <code>MyClass.f</code> 是一个函数。但 <code>x.i</code> 不是，因为 <code>MyClass.i</code> 是不是函数。不过 <code>x.f</code> 和 <code>MyClass.f</code> 不同－－它是一个方法对象，不是一个函数对象。
<H2><A NAME="SECTION0011340000000000000000"></A><A NAME="methodObjects"></A>
<BR>
9.3.4 方法对象 Method Objects 
</H2>

<P>
通常方法是直接调用的：
<div class="verbatim"><pre>
x.f()
</pre></div>

<P>
在我们的例子中，这会返回字符串 <code>'hello world'</code> 。然而，也不是一定要直接调用方法。 <code>x.f</code> 是一个方法对象，它可以存储起来以后调用。例如：
<div class="verbatim"><pre>
xf = x.f
while True:
    print xf()
</pre></div>

<P> 会不断的打印 "<tt class="samp">hello world</tt>" 。
<P>
调用方法时发生了什么？你可能注意到调用 <code>x.f()</code> 时没有引用前面标出的变量，尽管在 <tt class="method">f</tt> 的函数定义中指明了一个参数。这个参数怎么了？事实上如果函数调用中缺少参数，Python 会抛出异常－－甚至这个参数实际上没什么用……
<P>
实际上，你可能已经猜到了答案：方法的特别之处在于实例对象作为函数的第一个参数传给了函数。在我们的例子中，调用 <code>x.f()</code> 相当于 <code>MyClass.f(x)</code> 。通常，以 <var>n</var> 个参数的列表去调用一个方法就相当于将方法的对象插入到参数列表的最前面后，以这个列表去调用相应的函数。
<P>
如果你还是不理解方法的工作原理，了解一下它的实现也许有帮助。引用非数据属性的实例属性时，会搜索它的类。如果这个命名确认为一个有效的函数对象类属性，就会将实例对象和函数对象封装进一个抽象对象：这就是方法对象。以一个参数列表调用方法对象时，它被重新拆封，用实例对象和原始的参数列表构造一个新的参数列表，然后函数对象调用这个新的参数列表。
<H1><A NAME="SECTION0011400000000000000000"></A><A NAME="remarks"></A>
<BR>
9.4 一些说明 Random Remarks 
</H1>

<P>
〔有些内容可能需要明确一下……〕

<P>
同名的数据属性会覆盖方法属性，为了避免可能的命名冲突－－这在大型程序中可能会导致难以发现的 bug －－最好以某种命名约定来避免冲突。可选的约定包括方法的首字母大写，数据属性名前缀小写（可能只是一个下划线），或者方法使用动词而数据属性使用名词。
<P>
数据属性可以由方法引用，也可以由普通用户（客户）调用。换句话说，类不能实现纯的数据类型。事实上 Python 中没有什么办法可以强制隐藏数据－－一切都基本约定的惯例。（另一方法讲，Python 的实现是用 C 写成的，如果有必要，可以用 C 来编写 Python 扩展，完全隐藏实现的细节，控制对象的访问。）
<P>
客户应该小心使用数据属性－－客户可能会因为随意修改数据属性而破坏了本来由方法维护的数据一致性。需要注意的是，客户只要注意避免命名冲突，就可以随意向实例中添加数据属性而不会影响方法的有效性－－再次强调，命名约定可以省去很多麻烦。
<P>
从方法内部引用数据属性（以及其它方法！）没有什么快捷的方式。我认为这事实上增加了方法的可读性：即使粗略的浏览一个方法，也不会有混淆局部变量和实例变量的机会。
<P>
习惯上，方法的第一个参数命名为 <code>self</code> 。这仅仅是一个约定：对 Python 而言，<code>self</code> 绝对没有任何特殊含义。（然而要注意的是，如果不遵守这个约定，别的 Python 程序员阅读你的代码时会有不便，而且有些类浏览程序也是遵循此约定开发的。）
<P>
类属性中的任何函数对象在类实例中都定义为方法。不是必须要将函数定义代码写进类定义中，也可以将一个函数对象赋给类中的一个变量。例如：
<div class="verbatim"><pre>
# Function defined outside the class
def f1(self, x, y):
    return min(x, x+y)

class C:
    f = f1
    def g(self):
        return 'hello world'
    h = g
</pre></div>

<P>
现在 <code>f</code>, <code>g</code> 和 <code>h</code> 都是类 <tt class="class">C</tt> 的属性，引用的都是函数对象，因此它们都是 <tt class="class">C</tt> 实例的方法－－ <code>h</code> 严格等于 <code>g</code>。要注意的是这种习惯通常只会迷惑程序的读者。
<P>
通过 <code>self</code> 参数的方法属性，方法可以调用其它的方法：
<div class="verbatim"><pre>
class Bag:
    def __init__(self):
        self.data = []
    def add(self, x):
        self.data.append(x)
    def addtwice(self, x):
        self.add(x)
        self.add(x)
</pre></div>

<P>
方法可以像引用普通的函数那样引用全局命名。与方法关联的全局作用域是包含类定义的模块。（类本身永远不会做为全局作用域使用！）尽管很少有好的理由在方法中使用全局数据，全局作用域确有很多合法的用途：其一是方法可以调用导入全局作用域的函数和方法，也可以调用定义在其中的类和函数。通常，包含此方法的类也会定义在这个全局作用域，在下一节我们会了解为何一个方法要引用自己的类！
<H1><A NAME="SECTION0011500000000000000000"></A><A NAME="inheritance"></A>
<BR>
9.5 继承 Inheritance 
</H1>

<P>
当然，如果一种语言不支持继承就，“类”就没有什么意义。派生类的定义如下所示：
<div class="verbatim"><pre>
class DerivedClassName(BaseClassName):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</pre></div>

<P>
命名 <tt class="class">BaseClassName</tt>（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用：
<div class="verbatim"><pre>
class DerivedClassName(modname.BaseClassName):
</pre></div>

<P>
派生类定义的执行过程和基类是一样的。构造派生类对象时，就记住了基类。这在解析属性引用的时候尤其有用：如果在类中找不到请求调用的属性，就搜索基类。如果基类是由别的类派生而来，这个规则会递归的应用上去。
<P>
派生类的实例化没有什么特殊之处：<code>DerivedClassName()</code> （示列中的派生类）创建一个新的类实例。方法引用按如下规则解析：搜索对应的类属性，必要时沿基类链逐级搜索，如果找到了函数对象这个方法引用就是合法的
<P>
派生类可能会覆盖其基类的方法。因为方法调用同一个对象中的其它方法时没有特权，基类的方法调用同一个基类的方法时，可能实际上最终调用了派生类中的覆盖方法。（对于 C++ 程序员来说，Python中的所有方法本质上都是虚方法。）
<P>
派生类中的覆盖方法可能是想要扩充而不是简单的替代基类中的重名方法。有一个简单的方法可以直接调用基类方法，只要调用："<tt class="samp">BaseClassName.methodname(self, arguments)</tt>"。有时这对于客户也很有用。（要注意的中只有基类在同一全局作用域定义或导入时才能这样用。）
<H2><A NAME="SECTION0011510000000000000000"></A><A NAME="multiple"></A>
<BR>
9.5.1 多继承 Multiple Inheritance 
</H2>

<P>
Python同样有限的支持多继承形式。多继承的类定义形如下例：
<div class="verbatim"><pre>
class DerivedClassName(Base1, Base2, Base3):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;
</pre></div>

<P>
这里唯一需要解释的语义是解析类属性的规则。顺序是深度优先，从左到右。因此，如果在 <tt class="class">DerivedClassName</tt> （示例中的派生类）中没有找到某个属性，就会搜索 <tt class="class">Base1</tt> ，然后（递归的）搜索其基类，如果最终没有找到，就搜索 <tt class="class">Base2</tt>，以此类推。
<P>
（有些人认为广度优先－－在搜索<tt class="class">Base1</tt>的基类之前搜索<tt class="class">Base2</tt>和<code>Base3</code>－－看起来更为自然。然而，如果<tt class="class">Base1</tt>和<tt class="class">Base2</tt>之间发生了命名冲突，你需要了解这个属性是定义于<tt class="class">Base1</tt>还是<tt class="class">Base1</tt>的基类中。而深度优先不区分属性继承自基类还是直接定义。）
<P>
显然不加限制的使用多继承会带来维护上的噩梦，因为 Python 中只依靠约定来避免命名冲突。多继承一个很有名的问题是派生继承的两个基类都是从同一个基类继承而来。目前还不清楚这在语义上有什么意义，然而很容易想到这会造成什么后果（实例会有一个独立的“实例变量”或数据属性复本作用于公共基类。）
<H1><A NAME="SECTION0011600000000000000000"></A><A NAME="private"></A>
<BR>
9.6 私有变量 Private Variables 
</H1>

<P>
Python 对类的私有成员提供了有限的支持。任何形如 <code>__spam</code>（以至少双下划线开头，至多单下划线结尾）随即都被替代为 <code>_classname__spam</code>，去掉前导下划线的 <code>classname</code> 即当前的类名。这种混淆不关心标识符的语法位置，所以可用来定义私有类实例和类变量、方法，以及全局变量，甚至于将其它类的实例保存为私有变量。混淆名长度超过255个字符的时候可能会发生截断。在类的外部，或类名只包含下划线时，不会发生截断。
<P>
命名混淆意在给出一个在类中定义“私有”实例变量和方法的简单途径，避免派生类的实例变量定义产生问题，或者与外界代码中的变量搞混。要注意的是混淆规则主要目的在于避免意外错误，被认作为私有的变量仍然有可能被访问或修改。在特定的场合它也是有用的，比如调试的时候，这也是一直没有堵上这个漏洞的原因之一（小漏洞：派生类和基类取相同的名字就可以使用基类的私有变量。）
<P>
要注意的是传入 <code>exec</code>，<code>eval()</code> 或 <code>evalfile()</code> 的代码不会将调用它们的类视作当前类，这与 <code>global</code> 语句的情况类似，<code>global</code> 的作用局限于“同一批”进行字节编译的代码。同样的限制也适用于 <code>getattr()</code>，<code>setattr()</code> 和<code>delattr()</code>，以及直接引用 <code>__dict__</code> 的时候。
<H1><A NAME="SECTION0011700000000000000000"></A><A NAME="odds"></A>
<BR>
9.7 补充 Odds and Ends 
</H1>

<P>
有时类似于Pascal中“记录（record）”或C中“结构（struct）”的数据类型很有用，它将一组已命名的数据项绑定在一起。一个空的类定义可以很好的实现这它：
<div class="verbatim"><pre>
class Employee:
    pass

john = Employee() # Create an empty employee record

# Fill the fields of the record
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
</pre></div>

<P>
某一段 Python
代码需要一个特殊的抽象数据结构的话，通常可以传入一个类，事实上这模仿了该类的方法。例如，如果你有一个用于从文件对象中格式化数据的函数，你可以定义一个带有
  <tt class="method">read()</tt> 和 <tt class="method">readline()</tt>
方法的类，以此从字符串缓冲读取数据，然后将该类的对象作为参数传入前述的函数。
<P>
实例方法对象也有属性： <code>m.im_self</code> 是一个实例方法所属的对象，而 <code>m.im_func</code> 是这个方法对应的函数对象。
<H1><A NAME="SECTION0011800000000000000000"></A><A NAME="exceptionClasses"></A>
<BR>
9.8 异常也是类 Exceptions Are Classes Too
</H1>

<P>
用户自定义异常也可以是类。利用这个机制可以创建可扩展的异常体系。
<P>
以下是两种新的有效（语义上的）异常抛出形式：
<div class="verbatim"><pre>
raise Class, instance

raise instance
</pre></div>

<P>
第一种形式中，<code>instance</code> 必须是 <tt class="class">Class</tt> 或其派生类的一个实例。第二种形式是以下形式的简写：
<div class="verbatim"><pre>
raise instance.__class__, instance
</pre></div>

<P>
发生的异常其类型如果是异常子句中列出的类，或者是其派生类，那么它们就是相符的（反过来说－－发生的异常其类型如果是异常子句中列出的类的基类，它们就不相符）。例如，以下代码会按顺序打印B，C，D：
<div class="verbatim"><pre>
class B:
    pass
class C(B):
    pass
class D(C):
    pass

for c in [B, C, D]:
    try:
        raise c()
    except D:
        print "D"
    except C:
        print "C"
    except B:
        print "B"
</pre></div>

<P> 要注意的是如果异常子句的顺序颠倒过来（ "<tt class="samp">execpt B</tt>" 在最前），它就会打印B，B，B－－第一个匹配的异常被触发。
<P>
打印一个异常类的错误信息时，先打印类名，然后是一个空格、一个冒号，然后是用内置函数
  <tt class="function">str()</tt> 将类转换得到的完整字符串。
<H1><A NAME="SECTION0011900000000000000000"></A><A NAME="iterators"></A>
<BR>
9.9 迭代器 Iterators
</H1>

<P>
现在你可能注意到大多数容器对象都可以用 <code>for</code> 遍历：
<div class="verbatim"><pre>
for element in [1, 2, 3]:
    print element
for element in (1, 2, 3):
    print element
for key in {'one':1, 'two':2}:
    print key
for char in "123":
    print char
for line in open("myfile.txt"):
    print line
</pre></div>

<P>
这种形式的访问清晰、简洁、方便。这种迭代器的用法在 Python 中普遍而且统一。在后台，<code>for</code> 语句在容器对象中调用 <tt class="function">iter()</tt> 。 该函数返回一个定义了 <tt class="method">next()</tt> 方法的迭代器对象，它在容器中逐一访问元素。没有后续的元素时，<tt class="method">next()</tt>抛出一个 <tt class="exception">StopIteration</tt> 异常通知 <code>for</code> 语句循环结束。以下是其工作原理的示例：
<div class="verbatim"><pre>
&gt;&gt;&gt; s = 'abc'
&gt;&gt;&gt; it = iter(s)
&gt;&gt;&gt; it
&lt;iterator object at 0x00A1DB50&gt;
&gt;&gt;&gt; it.next()
'a'
&gt;&gt;&gt; it.next()
'b'
&gt;&gt;&gt; it.next()
'c'
&gt;&gt;&gt; it.next()

Traceback (most recent call last):
  File "&lt;pyshell#6&gt;", line 1, in -toplevel-
    it.next()
StopIteration
</pre></div>

<P>
了解了迭代器协议的后台机制，就可以很容易的给自己的类添加迭代器行为。定义一个 <tt class="method">__iter__()</tt> 方法，使其返回一个带有 <tt class="method">next()</tt> 方法的对象。如果这个类已经定义了 <tt class="method">next()</tt>，那么 <tt class="method">__iter__()</tt> 只需要返回self：
<div class="verbatim"><pre>
&gt;&gt;&gt; class Reverse:
    "Iterator for looping over a sequence backwards"
    def __init__(self, data):
        self.data = data
        self.index = len(data)
    def __iter__(self):
        return self
    def next(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]

&gt;&gt;&gt; for char in Reverse('spam'):
    print char

m
a
p
s
</pre></div>

<P>

<H1><A NAME="SECTION00111000000000000000000"></A><A NAME="generators"></A>
<BR>
9.10 生成器 Generators
</H1>

<P>
生成器是创建迭代器的简单而强大的工具。它们写起来就像是正则函数，需要返回数据的时候使用 <tt class="keyword">yield</tt> 语句。每次  <tt class="method">next()</tt> 被调用时，生成器回复它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）。以下示例演示了生成器可以很简单的创建出来：
<div class="verbatim"><pre>
&gt;&gt;&gt; def reverse(data):
        for index in range(len(data)-1, -1, -1):
            yield data[index]

&gt;&gt;&gt; for char in reverse('golf'):
        print char

f
l
o
g
</pre></div>

<P>
前一节中描述了基于类的迭代器，它能作的每一件事生成器也能作到。因为自动创建了 <tt class="method">__iter__()</tt> 和 <tt class="method">next()</tt> 方法，生成器显得如此简洁。
<P>
另外一个关键的功能是两次调用之间的局部变量和执行情况都自动保存了下来。这样函数编写起来就比手动调用
  <code>self.index</code> 和 <code>self.data</code> 这样的类变量容易的多。
<P>
除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出 <tt class="exception">StopIteration</tt> 异常。综上所述，这些功能使得编写一个正则函数成为创建迭代器的最简单方法。
<BR>
<HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot1679">... 是它的一个属性。因此，模块的属性和模块中的全局命名有直接的映射关系：它们共享同一命名空间！</A><A
 HREF="node11.html#tex2html10"><SUP>9.2</SUP></A></DT>
<DD> 有一个例外。模块对象有一个隐秘的只读对象，名为 __dict__，它返回用于实现模块命名空间的字典，命名 __dict__ 是一个属性而非全局命名。显然，使用它违反了命名空间实现的抽象原则，应该被严格限制于调试中。</DD>
</DL>
<DIV CLASS="navigation">
<div class='online-navigation'>
  <table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="8. 错误和异常 Errors and"
  href="node10.html"><img src='icons/previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></A></td>
<td class='online-navigation'><a rel="parent" title="Python Tutorial"
  href="tut.html"><img src='icons/up.png'
  border='0' height='32'  alt='Up One Level' width='32' /></A></td>
<td class='online-navigation'><a rel="next" title="10. 标准库概览 Brief Tour"
  href="node12.html"><img src='icons/next.png'
  border='0' height='32'  alt='Next Page' width='32' /></A></td>
<td align="center" width="100%" class='online-navigation'>Python Tutorial</td>
<td class='online-navigation'><a rel="contents" title="Table of Contents"
  href="node2.html"><img src='icons/contents.png'
  border='0' height='32'  alt='Contents' width='32' /></A></td>
<td class='online-navigation'><img src='icons/blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><img src='icons/blank.png'
  border='0' height='32'  alt='' width='32' /></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="node10.html">8. 错误和异常 Errors and</A>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="tut.html">Python Tutorial</A>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="node12.html">10. 标准库概览 Brief Tour</A>
</div>
</div>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
</ADDRESS>
<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
