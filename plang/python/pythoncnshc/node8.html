<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->


<DIV CLASS="navigation">
<div id='top-navigation-panel' xml:id='top-navigation-panel'>
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="5. 数据结构 Data Structures"
  href="node7.html"><img src='icons/previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></A></td>
<td class='online-navigation'><a rel="parent" title="Python Tutorial"
  href="tut.html"><img src='icons/up.png'
  border='0' height='32'  alt='Up One Level' width='32' /></A></td>
<td class='online-navigation'><a rel="next" title="7. 输入和输出 Input and"
  href="node9.html"><img src='icons/next.png'
  border='0' height='32'  alt='Next Page' width='32' /></A></td>
<td align="center" width="100%" class='online-navigation'>Python Tutorial</td>
<td class='online-navigation'><a rel="contents" title="Table of Contents"
  href="node2.html"><img src='icons/contents.png'
  border='0' height='32'  alt='Contents' width='32' /></A></td>
<td class='online-navigation'><img src='icons/blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><img src='icons/blank.png'
  border='0' height='32'  alt='' width='32' /></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="node7.html">5. 数据结构 Data Structures</A>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="tut.html">Python Tutorial</A>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="node9.html">7. 输入和输出 Input and</A>
</div>
<hr /></div>
</DIV>
<!--End of Navigation Panel-->
<div class='online-navigation'>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></a>

<UL CLASS="ChildLinks">
<LI><A href="node8.html#SECTION008100000000000000000">6.1 深入模块 More on Modules</a>
<UL>
<LI><A href="node8.html#SECTION008110000000000000000">6.1.1  模块搜索路径 The Module Search Path</a>
<LI><A href="node8.html#SECTION008120000000000000000">6.1.2 “编译”Python文件 ``Compiled'' Python files</a>
</ul>
<LI><A href="node8.html#SECTION008200000000000000000">6.2 标准模块 Standard Modules</a>
<LI><A href="node8.html#SECTION008300000000000000000">6.3 <tt class="function">dir()</tt> 函数 <tt class="function">dir()</tt> Function</a>
<LI><A href="node8.html#SECTION008400000000000000000">6.4 包 Packages</a>
<UL>
<LI><A href="node8.html#SECTION008410000000000000000">6.4.1 以 * 方式加载包 Importing * From a Package</a>
<LI><A href="node8.html#SECTION008420000000000000000">6.4.2 内置包（Intra-package）参考 Intra-package References</a>
<LI><A href="node8.html#SECTION008430000000000000000">6.4.3 多重路径中的包 Packages in Multiple Directories</a>
</ul></ul>
<!--End of Table of Child-Links-->
</div>
<HR>

<H1><A NAME="SECTION008000000000000000000"></A><A NAME="modules"></A>
<BR>
6. 模块 Modules 
</H1>

<P>
如果你退出 Python 解释器重新进入，以前创建的一切定义（变量和函数）就全部丢失了。因此，如果你想写一些长久保存的程序，最好使用一个文本编辑器来编写程序，把保存好的文件输入解释器。我们称之为创建一个<em>脚本</em>。程序变得更长一些了，你可能为了方便维护而把它分离成几个文件。你也可能想要在几个程序中都使用一个常用的函数，但是不想把它的定义复制到每一个程序里。
<P>
为了满足这些需要，Python提供了一个方法可以从文件中获取定义，在脚本或者解释器的一个交互式实例中使用。这样的文件被称为<em>模块</em>；模块中的定义可以<em>导入</em>到另一个模块或主模块中（在脚本执行时可以调用的变量集位于最高级，并且处于计算器模式）
<P>
模块是包 括Python 定义和声明的文件。文件名就是模块名加上 <span class="file">.py</span> 后缀。模块的模块名（做为一个字符串）可以由全局变量 <code>__name__</code> 得到。例如，你可以用自己惯用的文件编辑器在当前目录下创建一个叫 <span class="file">fibo.py</span> 的文件，录入如下内容：
<P>
<div class="verbatim"><pre>
# Fibonacci numbers module

def fib(n):    # write Fibonacci series up to n
    a, b = 0, 1
    while b &lt; n:
        print b,
        a, b = b, a+b

def fib2(n): # return Fibonacci series up to n
    result = []
    a, b = 0, 1
    while b &lt; n:
        result.append(b)
        a, b = b, a+b
    return result
</pre></div>

<P>
现在进入Python解释器，用如下命令导入这个模块：
<P>
<div class="verbatim"><pre>
&gt;&gt;&gt; import fibo
</pre></div>

<P>
这样做不会直接把 <code>fibo</code>中的函数导入当前的语义表；它只是引入了模块名 <code>fibo</code>。你可以通过模块名按如下方式访问这个函数：
<P>
<div class="verbatim"><pre>
&gt;&gt;&gt; fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
&gt;&gt;&gt; fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
&gt;&gt;&gt; fibo.__name__
'fibo'
</pre></div>

<P>
如果你想要直接调用函数，通常可以给它赋一个本地名称：
<P>
<div class="verbatim"><pre>
&gt;&gt;&gt; fib = fibo.fib
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</pre></div>

<P>

<H1><A NAME="SECTION008100000000000000000"></A><A NAME="moreModules"></A>
<BR>
6.1 深入模块 More on Modules 
</H1>

<P>
模块可以像函数定义一样包含执行语句。这些语句通常用于初始化模块。它们只在模块<em>第一次</em>导入时执行一次。<A NAME="tex2html8"
  HREF="#foot983"><SUP>6.2</SUP></A>
<P>
对应于定义模块中所有函数的全局语义表，每一个模块有自己的私有语义表。因此，模块作者可以在模块中使用一些全局变量，不会因为与用户的全局变量冲突而引发错误。
<P>
另一方面，如果你确定你需要这个，可以像引用模块中的函数一样获取模块中的全局变量，形如：<code>modname.itemname</code>。
<P>
模块可以导入（import）其它模块。习惯上所有的
  <tt class="keyword">import</tt>语句都放在模块（或脚本，等等）的开头，但这并不是必须的。被导入的模块名入在本模块的全局语义表中。
<P>
<tt class="keyword">import</tt> 语句的一个变体直接从被导入的模块中导入命名到本模块的语义表中。例如：
<P>
<div class="verbatim"><pre>
&gt;&gt;&gt; from fibo import fib, fib2
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</pre></div>

<P>
这样不会从局域语义表中导入模块名（如上所示， <code>fibo</code>没有定义）。
<P>
这样可以导入所有除了以下划线(<code>_</code>)开头的命名。
<P>
<div class="verbatim"><pre>
&gt;&gt;&gt; from fibo import *
&gt;&gt;&gt; fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
</pre></div>

<P>
这样可以导入所有除了以下划线(<code>_</code>)开头的命名。
<H2><A NAME="SECTION008110000000000000000"></A><A NAME="searchPath"></A>
<BR>
6.1.1  模块搜索路径 The Module Search Path 
</H2>

<P>
导入一个叫 <tt class="module">spam</tt> 的模块时，解释器先在当前目录中搜索名为 <span class="file">spam.py</span> 的文件，然后在环境变量 <a class="envvar" id='l2h-28' xml:id='l2h-28'>PYTHONPATH</a> 表示的目录列表中搜索，然后是环境变量 <a class="envvar" id='l2h-29' xml:id='l2h-29'>PATH</a> 中的路径列表。如果 <a class="envvar" id='l2h-30' xml:id='l2h-30'>PYTHONPATH</a> 没有设置，或者文件没有找到，接下来搜索安装目录，在 <span class="Unix">Unix</span>中，通常是 <span class="file">.:/usr/local/lib/python</span>。
<P>
实际上，解释器由 <code>sys.path</code> 变量指定的路径目录搜索模块，该变量初始化时默认包含了输入脚本（或者当前目录），<a class="envvar" id='l2h-32' xml:id='l2h-32'>PYTHONPATH</a> 和安装目录。这样就允许Python程序（原文如此，programs；我猜想应该是“programer”，程序员－－译者）了解如何修改或替换模块搜索目录。需要注意的是由于这些目录中包含有搜索路径中运行的脚本，所以这些脚本不应该和标准模块重名，否则在导入模块时Python会尝试把这些脚本当作模块来加载。这通常会引发一个错误。请参见6.2节“标准模块（&nbsp;<A HREF="#standardModules">
<tex2html_cross_ref_visible_mark>
</A>）”以了解更多的信息。
<H2><A NAME="SECTION008120000000000000000">
6.1.2 “编译”Python文件 ``Compiled'' Python files</A>
</H2>

<P>
对于引用了大量标准模块的短程序，有一个提高启动速度的重要方法，如果在 <span class="file">spam.py</span> 所在的目录下存在一个名为 <span class="file">spam.pyc</span> 的文件，它会被视为 <tt class="module">spam</tt> 模块的预“编译”（``byte-compiled'' ，二进制编译）版本。用于创建 <span class="file">spam.pyc</span> 的这一版 <span class="file">spam.py</span> 的修改时间记录在 <span class="file">spam.pyc</span> 文件中，如果两者不匹配，<span class="file">.pyc</span> 文件就被忽略。
<P>
通常你不需要为创建 <span class="file">spam.pyc</span> 文件做任何工作。一旦 <span class="file">spam.py</span> 成功编译，就会试图编译对应版本的 <span class="file">spam.pyc</span>。如果有任何原因导致写入不成功，返回的 <span class="file">spam.pyc</span> 文件就会视为无效，随后即被忽略。 <span class="file">spam.pyc</span> 文件的内容是平台独立的，所以Python模块目录可以在不同架构的机器之间共享。
<P>
部分高级技巧：
<UL>
<LI>以 <b class="programopt">-O</b> 参数调用Python解释器时，会生成优化代码并保存在 <span class="file">.pyo</span> 文件中。现在的优化器没有太多帮助；它只是删除了断言（<tt class="keyword">assert</tt> ）语句。使用 <b class="programopt">-O</b> 参参数，所有的代码都会被优化；<code>.pyc</code> 文件被忽略， <code>.py</code>文件被编译为优化代码。</LI>
<LI>向Python解释器传递两个 <b class="programopt">-O</b> 参数（<b class="programopt">-OO</b>）会执行完全优化的二进制优化编译，这偶尔会生成错误的程序。现在的优化器，只是从二进制代码中删除了 <code>__doc__</code> 符串，生成更为紧凑的 <span class="file">.pyo</span> 文件。因为某些程序依赖于这些变量的可用性，你应该只在确定无误的场合使用这一选项。</LI>
<LI>来自 <span class="file">.pyc</span> 文件或 <span class="file">.pyo</span> 文件中的程序不会比来自 <span class="file">.py</span> 文件的运行更快； <span class="file">.pyc</span> 或 <span class="file">.pyo</span> 文件只是在它们加载的时候更快一些。</LI>
<LI>通过脚本名在命令行运行脚本时，不会将为该脚本创建的二进制代码写入 <span class="file">.pyc</span> 或<span class="file">.pyo</span> 文件。当然，把脚本的主要代码移进一个模块里，然后用一个小的解构脚本导入这个模块，就可以提高脚本的启动速度。也可以直接在命令行中指定一个 <span class="file">.pyc</span> 或 <span class="file">.pyo</span> 文件。</LI>
<LI>对于同一个模块（这里指例程 <span class="file">spam.py</span> －－译者），可以只有 <span class="file">spam.pyc</span> 文件（或者 <span class="file">spam.pyc</span> ，在使用 <b class="programopt">-O</b> 参数时）而没有 <span class="file">spam.py</span> 文件。这样可以打包发布比较难于逆向工程的Python代码库。</LI>
<LI><tt class="module">compileall</tt> <a id='l2h-34' xml:id='l2h-34'></a> 模块 可以为指定目录中的所有模块创建 <span class="file">.pyc</span> 文件（或者使用 <span class="file">.pyo</span> 参数创建.pyo文件）。</LI>
</UL>

<H1><A NAME="SECTION008200000000000000000"></A><A NAME="standardModules"></A>
<BR>
6.2 标准模块 Standard Modules 
</H1>

<P>
Python带有一个标准模块库，并发布有独立的文档，名为 <em class="citetitle">Python 库参考手册</em> （此后称其为“库参考手册”）。有一些模块内置于解释器之中，这些操作的访问接口不是语言内核的一部分，但是已经内置于解释器了。这既是为了提高效率，也是为了给系统调用等操作系统原生访问提供接口。这类模块集合是一个依赖于底层平台的配置选项。例如，<tt class="module">amoeba</tt> 模块只提供对 Amoeba
原生系统的支持。有一个具体的模块值得注意：<tt class="module">sys</tt><a id='l2h-36' xml:id='l2h-36'></a> ，这个模块内置于所有的Python解释器。变量 <code>sys.ps1</code> 和 <code>sys.ps2</code>定义了主提示符和副助提示符字符串：
<P>
<div class="verbatim"><pre>
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.ps1
'&gt;&gt;&gt; '
&gt;&gt;&gt; sys.ps2
'... '
&gt;&gt;&gt; sys.ps1 = 'C&gt; '
C&gt; print 'Yuck!'
Yuck!
C&gt;
</pre></div>

<P>
这两个变量只在解释器的交互模式下有意义。
<P>
变量 <code>sys.path</code> 是解释器模块搜索路径的字符串列表。它由环境变量 <a class="envvar" id='l2h-39' xml:id='l2h-39'>PYTHONPATH</a> 初始化，如果没有设定 <a class="envvar" id='l2h-40' xml:id='l2h-40'>PYTHONPATH</a> ，就由内置的默认值初始化。你可以用标准的字符串操作修改它：
<P>
<div class="verbatim">
<pre>
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append('/ufs/guido/lib/python')

</pre></div>

<H1><A NAME="SECTION008300000000000000000"></A><A NAME="dir"></A>
<BR>
6.3 <tt class="function">dir()</tt> 函数 <tt class="function">dir()</tt> Function 
</H1>

<P>
内置函数 <tt class="function">dir()</tt>
用于按模块名搜索模块定义，它返回一个字符串类型的存储列表：
<div class="verbatim"><pre>
&gt;&gt;&gt; import fibo, sys
&gt;&gt;&gt; dir(fibo)
['__name__', 'fib', 'fib2']
&gt;&gt;&gt; dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__name__', '__stderr__',
 '__stdin__', '__stdout__', '_getframe', 'api_version', 'argv',
 'builtin_module_names', 'byteorder', 'callstats', 'copyright',
 'displayhook', 'exc_clear', 'exc_info', 'exc_type', 'excepthook',
 'exec_prefix', 'executable', 'exit', 'getdefaultencoding', 'getdlopenflags',
 'getrecursionlimit', 'getrefcount', 'hexversion', 'maxint', 'maxunicode',
 'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache',
 'platform', 'prefix', 'ps1', 'ps2', 'setcheckinterval', 'setdlopenflags',
 'setprofile', 'setrecursionlimit', 'settrace', 'stderr', 'stdin', 'stdout',
 'version', 'version_info', 'warnoptions']
</pre></div>

<P>
无参数调用时， <tt class="function">dir()</tt> 函数返回当前定义的命名：
<P>
<div class="verbatim"><pre>
&gt;&gt;&gt; a = [1, 2, 3, 4, 5]
&gt;&gt;&gt; import fibo, sys
&gt;&gt;&gt; fib = fibo.fib
&gt;&gt;&gt; dir()
['__name__', 'a', 'fib', 'fibo', 'sys']
</pre></div>

<P>
该列表列出了所有类型的名称：变量，模块，函数，等等：
<P><tt class="function">dir()</tt> 不会列出内置函数和变量名。如果你想列出这些内容，它们在标准模块 <tt class="module">__builtin__</tt><a id='l2h-42' xml:id='l2h-42'></a>中定义：
<div class="verbatim"><pre>
&gt;&gt;&gt; import __builtin__
&gt;&gt;&gt; dir(__builtin__)
['ArithmeticError', 'AssertionError', 'AttributeError',
 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError',
 'Exception', 'False', 'FloatingPointError', 'IOError', 'ImportError',
 'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt',
 'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented',
 'NotImplementedError', 'OSError', 'OverflowError', 'OverflowWarning',
 'PendingDeprecationWarning', 'ReferenceError',
 'RuntimeError', 'RuntimeWarning', 'StandardError', 'StopIteration',
 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError',
 'True', 'TypeError', 'UnboundLocalError', 'UnicodeError', 'UserWarning',
 'ValueError', 'Warning', 'ZeroDivisionError', '__debug__', '__doc__',
 '__import__', '__name__', 'abs', 'apply', 'bool', 'buffer',
 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex',
 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod',
 'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float',
 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id',
 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter',
 'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'min',
 'object', 'oct', 'open', 'ord', 'pow', 'property', 'quit',
 'range', 'raw_input', 'reduce', 'reload', 'repr', 'round',
 'setattr', 'slice', 'staticmethod', 'str', 'string', 'sum', 'super',
 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']
</pre></div>

<P>

<H1><A NAME="SECTION008400000000000000000"></A><A NAME="packages"></A>
<BR>
6.4 包 Packages 
</H1>

<P>
包通常是使用用“圆点模块名”的结构化模块命名空间。例如，名为 <tt class="module">A.B</tt> 的模块表示了名为 "<tt class="samp">B</tt>" 的包中名为 "<tt class="samp">A</tt>" 的子模块。正如同用模块来保存不同的模块架构可以避免全局变量之间的相互冲突，使用圆点模块名保存像 NumPy 或 Python Imaging Library 之类的不同类库架构可以避免模块之间的命名冲突。
<P>
假设你现在想要设计一个模块集（一个“包”）来统一处理声音文件和声音数据。存在几种不同的声音格式（通常由它们的扩展名来标识，例如：<span class="file">.wav</span> ， <span class="file">.aiff</span> ， <span class="file">.au</span>) ），于是，为了在不同类型的文件格式之间转换，你需要维护一个不断增长的包集合。可能你还想要对声音数据做很多不同的操作（例如混音，添加回声，应用平衡功能，创建一个人造效果），所以你要加入一个无限流模块来执行这些操作。你的包可能会是这个样子（通过分级的文件体系来进行分组）：
<div class="verbatim"><pre>
Sound/                          Top-level package
      __init__.py               Initialize the sound package
      Formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      Effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      Filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
</pre></div>

<P>
导入模块时，Python通过 <code>sys.path</code> 中的目录列表来搜索存放包的子目录。
<P>
必须要有一个 <span class="file">__init__.py</span> 文件的存在，才能使Python视该目录为一个包；这是为了防止某些目录使用了"<tt class="samp">string</tt>" 这样的通用名而无意中在随后的模块搜索路径中覆盖了正确的模块。最简单的情况下，<span class="file">__init__.py</span> 可以只是一个空文件，不过它也可能包含了包的初始化代码，或者设置了 <code>__all__</code> 变量，后面会有相关介绍。
<P>
包用户可以从包中导入合法的模块，例如：
<P>
<div class="verbatim"><pre>
import Sound.Effects.echo
</pre></div>

<P>
这样就导入了 <tt class="module">Sound.Effects.echo</tt> 子模块。它必需通过完整的名称来引用。
<div class="verbatim"><pre>
Sound.Effects.echo.echofilter(input, output, delay=0.7, atten=4)
</pre></div>

<P>
导入包时有一个可以选择的方式：
<div class="verbatim"><pre>
from Sound.Effects import echo
</pre></div>

<P>
这样就加载了 <tt class="module">echo</tt> 子模块，并且使得它在没有包前缀的情况下也可以使用，所以它可以如下方式调用：
<div class="verbatim"><pre>
echo.echofilter(input, output, delay=0.7, atten=4)</pre></div>

<P>
还有另一种变体用于直接导入函数或变量：
<div class="verbatim"><pre>
from Sound.Effects.echo import echofilter
</pre></div>

<P>
这样就又一次加载了 <tt class="module">echo</tt> 子模块，但这样就可以直接调用它的 <tt class="function">echofilter()</tt> 函数：
<div class="verbatim"><pre>
echofilter(input, output, delay=0.7, atten=4)
</pre></div>

<P>
需要注意的是使用 <code>from <var>package</var> import <var>item</var></code> 方式导入包时，这个子项（item）既可以是包中的一个子模块（或一个子包），也可以是包中定义的其它命名，像函数、类或变量。<code>import</code> 语句首先核对是否包中有这个子项，如果没有，它假定这是一个模块，并尝试加载它。如果没有找到它，会引发一个 <tt class="exception">ImportError</tt> 异常。
<P>
相反，使用类似<code>import <var>item.subitem.subsubitem</var></code> 这样的语法时，这些子项必须是包，最后的子项可以是包或模块，但不能是前面子项中定义的类、函数或变量。
<H2><A NAME="SECTION008410000000000000000"></A><A NAME="pkg-import-star"></A>
<BR>
6.4.1 以 * 方式加载包 Importing * From a Package 
</H2>

<P>
那么当用户写下 <code>from Sound.Effects import *</code> 时会发生什么事？理想中，总是希望在文件系统中找出包中所有的子模块，然后导入它们。不幸的是，这个操作在 Mac 和 Windows 平台上工作的并不太好，这些文件系统的文件大小写并不敏感！在这些平台上没有什么方法可以确保一个叫<span class="file">ECHO.PY</span> 的文件应该导入为模块 <tt class="module">echo</tt> 、 <tt class="module">Echo</tt> 或 <tt class="module">ECHO</tt> 。（例如，Windows 95有一个讨厌的习惯，它会把所有的文件名都显示为首字母大写的风格。）DOS 8+3文件名限制又给长文件名模块带来了另一个有趣的问题。
<P>
对于包的作者来说唯一的解决方案就是给提供一个明确的包索引。import 语句按如下条件进行转换：执行 <code>from <var>package</var> import *</code> 时，如果包中的 <span class="file">__init__.py</span> 代码定义了一个名为 <code>__all__</code> 的链表，就会按照链表中给出的模块名进行导入。新版本的包发布时作者可以任意更新这个链表。如果包作者不想 import * 的时候导入他们的包中所有模块，那么也可能会决定不支持它（import *）。例如， <span class="file">Sounds/Effects/__init__.py</span> 这个文件可能包括如下代码：
<div class="verbatim"><pre>
__all__ = ["echo", "surround", "reverse"]
</pre></div>

<P>
这意味着 <code>from Sound.Effects import *</code> 语句会从 <tt class="module">Sound</tt> 包中导入以上三个已命名的子模块。
<P>
如果没有定义 <code>__all__</code> ， <code>from Sound.Effects import *</code> 语句不会从 <tt class="module">Sound.Effects</tt> 包中导入所有的子模块。Effects 导入到当前的命名空间，只能确定的是导入了 Sound.Effects 包（可能会运行 <span class="file">__init__.py</span> 中的初始化代码）以及包中定义的所有命名会随之导入。这样就从 <span class="file">__init__.py</span> 中导入了每一个命名（以及明确导入的子模块）。同样也包括了前述的import语句从包中明确导入的子模块，考虑以下代码：
<div class="verbatim"><pre>
import Sound.Effects.echo
import Sound.Effects.surround
from Sound.Effects import *
</pre></div>

<P>
在这个例子中，echo和surround模块导入了当前的命名空间，这是因为执行 <code>from...import</code> 语句时它们已经定义在 <tt class="module">Sound.Effects</tt> 包中了（定义了 <code>__all__</code> 时也会同样工作）。
<P>
需要注意的是习惯上不主张从一个包或模块中用 import <code>*</code> 导入所有模块，因为这样的通常意味着可读性会很差。然而，在交互会话中这样做可以减少输入，相对来说确定的模块被设计成只导出确定的模式中命名的那一部分。
<P>
记住， <code>from Package import specific_submodule</code> 没有错误！事实上，除非导入的模块需要使用其它包中的同名子模块，否则这是受到推荐的写法。
<H2><A NAME="SECTION008420000000000000000">
6.4.2 内置包（Intra-package）参考 Intra-package References</A>
</H2>

<P>
子模块之间经常需要互相引用。例如，<tt class="module">surround</tt> 模块可能会引用 <tt class="module">echo</tt> 模块。事实上，这样的引用如此普遍，以致于 <tt class="keyword">import</tt> 语句会先搜索包内部，然后才是标准模块搜索路径。因此 surround 模块可以简单的调用 <code>import echo</code> 或者 <code>from echo import echofilter</code> 。如果没有在当前的包中发现要导入的模块，<tt class="keyword">import</tt> 语句会依据指定名寻找一个顶级模块。
<P>
如果包中使用了子包结构（就像示例中的 <tt class="module">Sound</tt> 包），不存在什么从邻近的包中引用子模块的便捷方法－－必须使用子包的全名。例如，如果 <tt class="module">Sound.Filters.vocoder</tt> 包需要使用 <tt class="module">Sound.Effects</tt> 包中的 <tt class="module">echosa</tt> 模块，它可以使用 <code>from Sound.Effects import echo</code> 。
<H2><A NAME="SECTION008430000000000000000">
6.4.3 多重路径中的包 Packages in Multiple Directories</A>
</H2>

<P>
包支持一个更为特殊的变量， <tt class="member">__path__</tt> 。 在包的 <span class="file">__init__.py</span> 文件代码执行之前，该变量初始化一个目录名列表。该变量可以修改，它作用于包中的子包和模块的搜索功能。
<P>
这个功能可以用于扩展包中的模块集，不过它不常用。
  <HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot983">...第一次导入时执行一次。</A><A
 HREF="node8.html#tex2html8"><SUP>6.2</SUP></A></DT>
<DD> 
	事实上函数定义既是“声明”又是“可执行体”；执行体由函数在模块全局语义表中的命名导入。</DD>
</DL>
<DIV CLASS="navigation">
<div class='online-navigation'>
  <table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td class='online-navigation'><a rel="prev" title="5. 数据结构 Data Structures"
  href="node7.html"><img src='icons/previous.png'
  border='0' height='32'  alt='Previous Page' width='32' /></A></td>
<td class='online-navigation'><a rel="parent" title="Python Tutorial"
  href="tut.html"><img src='icons/up.png'
  border='0' height='32'  alt='Up One Level' width='32' /></A></td>
<td class='online-navigation'><a rel="next" title="7. 输入和输出 Input and"
  href="node9.html"><img src='icons/next.png'
  border='0' height='32'  alt='Next Page' width='32' /></A></td>
<td align="center" width="100%" class='online-navigation'>Python Tutorial</td>
<td class='online-navigation'><a rel="contents" title="Table of Contents"
  href="node2.html"><img src='icons/contents.png'
  border='0' height='32'  alt='Contents' width='32' /></A></td>
<td class='online-navigation'><img src='icons/blank.png'
  border='0' height='32'  alt='' width='32' /></td>
<td class='online-navigation'><img src='icons/blank.png'
  border='0' height='32'  alt='' width='32' /></td>
</tr></table>
<div class='online-navigation'>
<b class="navlabel">Previous:</b>
<a class="sectref" rel="prev" href="node7.html">5. 数据结构 Data Structures</A>
<b class="navlabel">Up:</b>
<a class="sectref" rel="parent" href="tut.html">Python Tutorial</A>
<b class="navlabel">Next:</b>
<a class="sectref" rel="next" href="node9.html">7. 输入和输出 Input and</A>
</div>
</div>
</DIV>
<!--End of Navigation Panel-->
<ADDRESS>
</ADDRESS>
<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
