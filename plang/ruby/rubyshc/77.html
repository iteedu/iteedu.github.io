<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->


<div class="lpindex"><a href="index.html">首页</a><a href="76.html"> 上一页</a><a href="78.html"> 下一页</a></div>

<H1>控制结构<!-- RDLabel: "控制结构" --></H1>
<UL>
<LI>条件分支 
<UL>
<LI>if 
<LI>if 修饰句 
<LI>unless 
<LI>unless 修饰句 
<LI>case </LI></UL>
<LI>循环 
<UL>
<LI>while 
<LI>while 修饰句 
<LI>until 
<LI>until修饰句 
<LI>for 
<LI>break 
<LI>next 
<LI>redo 
<LI>retry </LI></UL>
<LI>异常处理 
<UL>
<LI>raise 
<LI>begin 
<LI>rescue修饰句 </LI></UL>
<LI>其他 
<UL>
<LI>return 
<LI>BEGIN 
<LI>END </LI></UL></LI></UL>
<P>(与C等语言不同的是)Ruby的控制结构是表达式，其中的一部分还会返回值(也有不返回值的，若把这些不返回值的表达式放在赋值表达式右边的话，就会引发 parse error)。</P>
<P>Ruby中包括从C和Perl那里继承来的控制结构，还包括一种可以将控制结构抽象化的功能，即 带块的方法调用。带块的方法调用使类的设计者可以自己定义一些包括循环在内的控制结构。</P>
<H2>条件分支<!-- RDLabel: "条件分支" --></H2>
<H3>if<!-- RDLabel: "if" --></H3>
<P>例:</P><pre class="code">if age &gt;= 12 then
  print "adult fee\n"
else
  print "child fee\n"
end
gender = if foo.gender == "male" then "male" else "female" end
</PRE>
<P>语法:</P><pre class="code">if 表达式 [then]
  表达式 ...
[elsif 表达式 [then]
  表达式 ... ]
...
[else
  表达式 ... ]
end
</PRE>
<P>若条件表达式的计算结果为真时，将计算then以下的表达式。若if的条件表达式为伪时，将计算elsif的条件部分。可以存在若干个elsif部分，若所有的if以及elsif的条件表达式都为伪的话，如果有else部分，就计算它的表达式。</P>
<P>if 表达式的结果取决于条件成立部分(或else部分)中最后被计算的表达式的结果。若没有else部分，且所有条件均不成立的话，就返回nil。</P>
<P>Ruby中只有false和nil代表伪，其他都是真，甚至0或空字符串也是如此。</P>
<P>请注意，在Ruby中，和if对应的是elsif，而并非else if(C的语句)或者elif(sh的语句)。</P>
<P>另外，当if 条件表达式中出现正则表达式字面值时，将作如下处理</P><pre class="code">$_ =~ 字面值
</PRE>
<H3>if 修饰句<!-- RDLabel: "if 修饰句" --></H3>
<P>例:</P><pre class="code">print "debug\n" if $DEBUG
</PRE>
<P>语法:</P><pre class="code">表达式 if 表达式
</PRE>
<P>当右边的条件成立时，计算左边的表达式，并返回其结果。若条件不成立则返回nil。</P>
<H3>unless<!-- RDLabel: "unless" --></H3>
<P>例:</P><pre class="code">unless baby?
  feed_meat
else
  feed_milk
end
</PRE>
<P>语法:</P><pre class="code">unless 表达式 [then]
  表达式 ...
[else
  表达式 ... ]
end
</PRE>
<P>unless与if相反，当条件表达式结果为伪时，才计算then后面的表达式。unless表达式中不能安插elsif语句。</P>
<H3>unless 修饰句<!-- RDLabel: "unless 修饰句" --></H3>
<P>例:</P><pre class="code">print "stop\n" unless valid(passwd)
</PRE>
<P>语法:</P><pre class="code">表达式 unless 表达式
</PRE>
<P>当右边的条件不成立时，计算左边的表达式，并返回其结果。若条件不成立时返回nil。</P>
<H3>case<!-- RDLabel: "case" --></H3>
<P>例:</P><pre class="code">case $age
when 0 .. 2
  "baby"
when 3 .. 6
  "little child"
when 7 .. 12
  "child"
when 13 .. 18
  "youth"
else
  "adult"
end
</PRE>
<P>语法:</P><pre class="code">case [表达式]
[when 表达式 [, 表达式] ...[, `*' 表达式] [then]
  表达式..]..
[when `*' 表达式 [then]
  表达式..]..
[else
  表达式..]
end
</PRE>
<P>case先对一个表达式进行匹配判断，然后根据匹配结果进行分支选择。它使用"==="操作符比较when的指定值和最初那个表达式的计算值，若一致的话就计算when部分的内容。</P>
<P>也就是说</P><pre class="code">case 表达式0
when 表达式1, 表达式2
  stmt1
when 表达式3, 表达式4
  stmt2
else
  stmt3
end
</PRE>
<P>基本上等同于下面的if表达式。</P><pre class="code">_tmp = 表达式0
if 表达式1 === _tmp or 表达式2 === _tmp
  stmt1
elsif 表达式3 === _tmp or 表达式4 === _tmp
  stmt2
else
  stmt3
end
</PRE>
<P>when 部分的计算顺序同上面这个if句的计算顺序是相同的。即从上到下(从左到右)地计算"==="。另外，“表达式0”只计算一次。</P>
<P>若when 部分中的最后一个表达式前带"*"的话，该表达式将被当作数组展开。</P><pre class="code">ary = [1,2,3]

case v
when *ary
 ..
end
</PRE>
<P>等同于</P><pre class="code">case v
when 1, 2, 3
 ..
end
</PRE>
<P>请参考描述各个类中"==="方法技术细节的文档，来了解"==="在何种条件下为真。</P>
<P>当case的“表达式”部分被省略时，将计算第一个when条件部分为真的表达式。</P><pre class="code">foo = false
bar = true
quu = false

case
when foo then puts 'foo is true'
when bar then puts 'bar is true'
when quu then puts 'quu is true'
end
# 显示 "bar is true"
</PRE>
<P>case将返回条件成立的when部分(或else部分)中最后被计算的表达式的结果。若所有条件都不成立的话，则返回nil。</P>
<H2><a name="a" id="a"></a>循环<!-- RDLabel: "循环" --></H2>
<H3>while<!-- RDLabel: "while" --></H3>
<P>例:</P><pre class="code">ary = [0,2,4,8,16,32,64,128,256,512,1024]
i = 0
while i &lt; ary.length
  print ary[i]
  i += 1
end
</PRE>
<P>语法:</P><pre class="code">while 表达式 [do]
   ...
end
</PRE>
<P>只要表达式的计算值为真，就循环执行while语句中的内容。while不返回值。</P>
<P>ruby 1.7 特性: while返回nil。另外，可以使用带参数的break，将while表达式的返回值设为那个参数的值。</P>
<H3>while 修饰句<!-- RDLabel: "while 修饰句" --></H3>
<P>例:</P><pre class="code">sleep(60) while io_not_ready?
</PRE>
<P>语法:</P><pre class="code">表达式 while 表达式
</PRE>
<P>只要右边表达式的计算值为真，就循环执行左边部分。</P>
<P>若左边表达式是begin，且即不含rescue，又不含ensure的话，则只在开始时计算一次然后就执行循环。</P>
<P>ruby 1.7 特性: 在version 1.7中，即使出现rescue/ensure部分也会作相同处理。</P>
<P>例:</P><pre class="code">send_request(data)
begin
  res = get_response()
end while res == 'Continue'
</PRE>
<P>while 修饰的表达式没有返回值。</P>
<P>ruby 1.7 特性: while修饰的表达式返回nil。另外，可以使用带参数的break，将while修饰的表达式的返回值设为那个参数的值。</P>
<H3>until<!-- RDLabel: "until" --></H3>
<P>例:</P><pre class="code">until f.eof?
  print f.gets
end
</PRE>
<P>语法:</P><pre class="code">until 表达式 [do]
   ...
end
</PRE>
<P>在表达式的计算值变为真之前，一直循环执行until中的内容。until不返回值。</P>
<P>ruby 1.7 特性: until 返回 nil。另外，可以使用带参数的break，将until表达式的返回值设定为那个参数的值。</P>
<H3>until修饰句<!-- RDLabel: "until修饰句" --></H3>
<P>例:</P><pre class="code">print(f.gets) until f.eof?
</PRE>
<P>语法:</P><pre class="code">表达式 until 表达式
</PRE>
<P>在右边表达式的计算值变为真之前，一直循环执行左边部分。</P>
<P>若左边表达式是begin，且即不含rescue，又不含ensure的话，则只在开始时计算一次然后就执行循环。</P>
<P>ruby 1.7 特性: 在version 1.7中，即使出现rescue/ensure部分也会作相同处理</P>
<P>例:</P><pre class="code">send_request(data)
begin
  res = get_response()
end until res == 'OK'
</PRE>
<P>until修饰的表达式没有返回值。</P>
<P>ruby 1.7 特性: until修饰的表达式返回nil。另外，可以使用带参数的break，将until修饰的表达式的返回值设为那个参数的值。</P>
<H3>for<!-- RDLabel: "for" --></H3>
<P>例:</P><pre class="code">for i in [1, 2, 3]
  print i*2, "\n"
end
</PRE>
<P>语法:</P><pre class="code">for lhs ...  in 表达式 [do]
  表达式..
end
</PRE>
<P>先计算表达式得到一个对象，然后分别针对该对象中的每个要素，循环执行for的内容。这基本等价于</P><pre class="code">(表达式).each `{' `|' lhs..`|' 表达式.. `}'
</PRE>
<P>之所以说“基本”是因为，do...end以及由{}构成的块中导入了新的局部变量的有效范围，而for语句对于局部变量的有效范围没有任何影响。</P>
<P>for将返回in所指对象的each方法的返回值。</P>
<P>若想使用多个循环变量的话，可以这样</P><pre class="code">for i,j in [[1,2], [3,4], [5,6]]
  p [i,j]
end
=&gt; [1, 2]
   [3, 4]
   [5, 6]
</PRE>
<P>使用for或each时，每次只能取一个数组元素进行循环，而不能一次取多个。</P><pre class="code">for i,j in [1, 2, 3]
  p [i,j]
end

=&gt; [1, nil]
   [2, nil]
   [3, nil]

# 可能您希望这样[1,2] [3,nil]，但实际上这是行不通的
</PRE>
<P>您必须自己定义这样的方法(迭代器)。请参考 each。</P><pre class="code">class Array
  def each2
    i = 0
    while i &lt; self.size
      yield self[i], self[i+1]
      i += 2
    end
  end
end
</PRE>
<H3>break<!-- RDLabel: "break" --></H3>
<P>例:</P><pre class="code">i = 0
while i &lt; 3
  print i, "\n"
  break
end
</PRE>
<P>语法:</P><pre class="code">break

break val             ruby 1.7 特性
</PRE>
<P>break将退出最内层的循环。所谓循环是指，下列之一</P>
<UL>
<LI>while 
<LI>until 
<LI>for 
<LI>迭代 </LI></UL>
<P>与C语言不同，break只能从循环中退出，而不能从case中退出。</P>
<P>若使用break退出for或迭代循环后，该循环将返回nil。ruby 1.7 特性:但如果使用了参数的话，循环将返回那个参数的值。</P>
<H3>next<!-- RDLabel: "next" --></H3>
<P>例:</P><pre class="code"># 忽略空行的cat
ARGF.each_line do |line|
  next if line.strip.empty?
  print line
end
</PRE>
<P>语法:</P><pre class="code">next

next val              ruby 1.7 特性
</PRE>
<P>next将跳转到最内侧循环的头部。在迭代器中，它将跳离yield调用。</P>
<P>使用next跳离yield后，yield表达式将返回nil。ruby 1.7 特性:但如果使用了参数的话，yield表达式的返回值就是该参数的值。</P>
<H3>redo<!-- RDLabel: "redo" --></H3>
<P>例:</P><pre class="code">redo
</PRE>
<P>语法:</P><pre class="code">redo
</PRE>
<P>不检查循环条件，重新开始当前循环。</P>
<H3>retry<!-- RDLabel: "retry" --></H3>
<P>例:</P><pre class="code">retry
</PRE>
<P>语法:</P><pre class="code">retry
</PRE>
<P>在迭代、块或for语句中使用retry，意味着重启迭代器。同时迭代器的参数也将被重新计算。</P><pre class="code">for i in 1..5
  retry if some_condition # 从 i == 1 开始重新执行
end

# 用户定义的 "until循环"
def UNTIL(cond)
  return if cond
  yield
  retry
end
</PRE>
<P>除了循环以外，还可以在rescue部分(后述)中使用retry。这时将从begin表达式开始重新执行。使用retry可以在某处理过程成功之前，一直循环该处理过程。</P><pre class="code">begin
  do_something # exception raised
rescue
  # handles error
  retry  # restart from beginning
end
</PRE>
<P>若在rescue部分、迭代器块或for语句之外使用retry的话会引发LocalJumpError异常。</P>
<P>归纳一下，在迭代调用中使用break, next, redo, retry的作用如下。</P><pre class="code">def iter
 (a)
  :
 (b)
 yield
 (c)
  :
 (d)
end
iter { retry }   -&gt; 跳到 (a)
iter { redo  }   -&gt; 跳到 (b)
iter { next  }   -&gt; 跳到 (c)
iter { break }   -&gt; 跳到 (d)
</PRE>
<P>严格地讲(a)是从计算参数开始的。(b)指的是即将开始执行块的时候(yield的参数不会被再次计算)。(d)指的是方法的终结。</P><pre class="code">def iter(var = p("(a)"))
  p " : "
  yield
  p "(c)"
  p " : "
ensure
  p "(d)"
end

iter { p "(b)"; retry }     # =&gt; (a) .. (b)(d)(a) .. (b)(d)(a) ...
iter { p "(b)"; redo  }     # =&gt; (a) .. (b)(b)(b)(b) ...
iter { p "(b)"; next  }     # =&gt; (a) .. (b)(c) .. (d)
iter { p "(b)"; break }     # =&gt; (a)..(b)(d)
</PRE>
<H2><a name="b" id="b"></a>异常处理<!-- RDLabel: "异常处理" --></H2>
<H3>raise<!-- RDLabel: "raise" --></H3>
<P>例:</P><pre class="code">raise "you lose"  # 引发RuntimeError异常
# 下面两个将引发SyntaxError异常
raise SyntaxError, "invalid syntax"
raise SyntaxError.new("invalid syntax")
raise             # 再次引发上一个异常
</PRE>
<P>语法:</P><pre class="code">raise
raise message或exception
raise error_type, message
raise error_type, message, traceback
</PRE>
<P>引发异常。第一句将再次引发上一个异常。第二句中，若参数是字符串的话，就把它当作错误信息(message)再引发RuntimeError异常。若参数为异常对象则引发该异常。第三句中，将引发第一个参数所指的异常，并以第二个参数的内容作为错误信息。第四句中，第三参数装载的是源自于$@或caller的堆栈信息，它指明发生异常的地点。</P>
<P>可以使用begin表达式的rescue部分来捕捉异常。这时使用rescue error_type =&gt; var就可以得到异常对象。您还可以从内部变量$!中获得这个对象。另外，变量$@中装载的是发生异常的源代码位置。</P>
<P>raise并不是Ruby的保留字，它是Kernel模块中定义的函数式的方法。</P>
<H3>begin<!-- RDLabel: "begin" --></H3>
<P>例:</P><pre class="code">begin
  do_something
rescue
  recover
ensure
  must_to_do
end
</PRE>
<P>语法:</P><pre class="code">begin
  表达式..
[rescue [error_type,..] [=&gt; evar] [then]
  表达式..]..
[else
  表达式..]
[ensure
  表达式..]
end
</PRE>
<P>若给出了rescue部分(可以有若干个)的话，就可以在发生异常时捕捉到它。若存在与异常类型一致的rescue部分的话，就执行rescue的内容。可以使用$!来查看异常的情况。另外，若事先设定了变量evar的话，它也可以像$!一样存储那些异常的信息。</P><pre class="code">begin
  raise "error message"
rescue =&gt; evar
  p $!
  p evar
end
# =&gt; #&lt;RuntimeError: error message&gt;
     #&lt;RuntimeError: error message&gt;
</PRE>
<P>rescue部分使用Object#kind of?来判断刚才的异常的类是否就是自己期待的异常类，或者这二者是否处于父类／子类的关系。</P>
<P>若error_type被省略，则将捕捉StandardError的子类中的所有异常。Ruby的内部异常(除了SystemExit和Interrupt这些退出命令以外)是StandardError的子类。</P>
<P>请参考异常类来了解异常类的层次关系。</P>
<P>在rescue部分中，error_type与普通的参数一样接受计算，若符合的话就执行相应部分的内容。若error_type的计算值既非类又非模块的话，则引发TypeError异常。</P>
<P>若运行过程中没发生异常，则开始计算可选的else部分。</P>
<P>若存在ensure部分的话，则在begin表达式结束之前一定会计算它。</P>
<P>begin表达式整体的计算值取决于，begin的内容部分/rescue部分/else部分中最后被计算的句子的值。若各部分中均无语句时，其值为nil。不管怎样，ensure部分的值始终会被忽略。</P>
<H3>rescue修饰句<!-- RDLabel: "rescue修饰句" --></H3>
<P>例:</P><pre class="code">open("nonexistent file") rescue STDERR.puts "Warning: #$!"
</PRE>
<P>语法:</P><pre class="code">表达式1 rescue 表达式2
</PRE>
<P>若表达式1中发生异常时就计算表达式2。这等同于下例。不能指定想捕捉的异常类。(也就是说，只能捕捉StandardError异常类的子类了)</P><pre class="code">begin
  表达式1
rescue
  表达式2
end
</PRE>
<P>在包括rescue修饰句的表达式中，若没发生异常则返回表达式1的值，若发生异常则返回表达式2的值。但在大多数场合中，因为考虑到优先度的问题，所以需要使用括号将整个表达式括起来。</P><pre class="code">var = open("nonexistent file") rescue false
p var
=&gt; nil      # 因为只定义了一个空变量var

var = (open("nonexistent file") rescue false)
p var
=&gt; false
</PRE>
<P>特别是传递给某方法的参数时，有必要使用双重括号。</P><pre class="code">p(open("nonexistent file") rescue false)
=&gt; parse error

p((open("nonexistent file") rescue false))
=&gt; false
</PRE>
<P>ruby 1.7 特性: 在1.7中，rescue的优先度发生了变化，因此免去了这些烦恼。</P><pre class="code">var = open("nonexistent file") rescue false
p var
=&gt; false

p(open("nonexistent file") rescue false)
=&gt; false
</PRE>
<H2><a name="c" id="c"></a>其他<!-- RDLabel: "其他" --></H2>
<H3>return<!-- RDLabel: "return" --></H3>
<P>例:</P><pre class="code">return
return 12
return 1,2,3
</PRE>
<P>语法:</P><pre class="code">return [表达式[`,' 表达式 ... ]]
</PRE>
<P>结束方法的运行，且把表达式的值设定为方法的返回值。若给出了2个以上的表达式，则将把这些表达式化为一个数组，然后把该数组设定为方法的返回值。若省略表达式，将返回值设为nil。</P>
<H3>BEGIN<!-- RDLabel: "BEGIN" --></H3>
<P>例:</P><pre class="code">BEGIN {
   ...
}
</PRE>
<P>语法:</P><pre class="code">BEGIN '{' 语句.. '}'
</PRE>
<P>注册初始化例程(routine)。BEGIN块所指定的语句的执行顺序将先于该文件中任何语句。若有多个BEGIN块的话，将按照出现顺序依次执行。</P>
<P>BEGIN块在编译时被注册。也就是说，同一条语句只会被注册一次。</P><pre class="code">if false
  BEGIN { p "begin" }
end

# =&gt; "begin"
</PRE>
<P>BEGIN块引入了独立的局部变量作用域，因此不能和外部共享局部变量。为了与块外交换信息，必须借助于常数或全局变量。</P><pre class="code">BEGIN { $foo, foo = true, true }
p $foo  # =&gt; true
p foo   # undefined local variable or method `foo' for main:Object (NameError)
</PRE>
<P>BEGIN不能出现在方法定义表达式中，否则会引发 parse error。</P><pre class="code">def foo
  BEGIN { p "begin" }
end
# =&gt; -:2: BEGIN in method
</PRE>
<H3>END<!-- RDLabel: "END" --></H3>
<P>例:</P><pre class="code">END {
   ... 
}
</PRE>
<P>语法:</P><pre class="code">END '{' 语句.. '}'
</PRE>
<P>注册“善后”例程。END块中指定的语句会在解释器结束前得到执行。关于Ruby退出程序时的相关处理问题，请参考结束时的相关处理。</P>
<P>若注册了若干END块的话，则以与注册时相反的顺序依次执行这些块。</P><pre class="code">END { p 1 }
END { p 2 }
END { p 3 }

# =&gt; 3
     2
     1
</PRE>
<P>END块中同一条语句只会执行一次。如下例，即使把END块置入循环中，也只会注册一次。若想实现复用，请使用 at_exit。</P><pre class="code">5.times do |i|
  END { p i }
end
# =&gt; 0
</PRE>
<P>若把END块置入方法定义表达式中会引起警告。若有意如此，请使用at_exit。</P><pre class="code">def foo
  END { p "end" }
end
p foo

# =&gt; -:2: warning: END in method; use at_exit
     nil
     "end"
</PRE>
<P>END与BEGIN不同的是，它在运行时进行注册。因此，下例中的END块将不会运行。</P><pre class="code">if false
  END { p "end" }
end
</PRE>
<P>END和at_exit中注册的善后处理无法取消。</P>
<P>END块与BEGIN块不同的是，它同周围部分共享作用域。也就是说，它的作用域同迭代器一样。</P>
<P>若END块中发生了异常，将中断该块。但解释器并不结束，只是发出信息，并且试图处理完所有的善后例程。</P>
<P>例:</P><pre class="code">END { p "FOO" }
END { raise "bar"; p "BAR" }
END { raise "baz"; p "BAZ" }

=&gt; baz (RuntimeError)
   bar (RuntimeError)
   "FOO"
</PRE>


<div class="rpindex"><a href="78.html"> 下一页</a><a href="76.html"> 上一页</a><a href="index.html">首页</a></div>



<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
