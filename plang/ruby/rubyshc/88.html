<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->


<div class="lpindex"><a href="index.html">首页</a><a href="87.html"> 上一页</a><a href="89.html"> 下一页</a></div>

<H1>Ruby术语集</H1>
<H1><BR>--按英文排序</H1>
<H2>A<!-- RDLabel: "A" --></H2>

AWK<!-- RDLabel: "AWK" --> 

<P>由Alfred Aho(A)、Peter Weinberger(W)和Brian Kernighan(K)共通创建的一种小型脚本语言。</P>
<H2>B<!-- RDLabel: "B" --></H2>

blade<!-- RDLabel: "blade" --> 

<P>ml archive (blade/ruby)</P>
<H2>C<!-- RDLabel: "C" --></H2>

Coerce<!-- RDLabel: "Coerce" --> 

<P>进行数据类型变换的方法。如果某数值计算方法从参数那里获得了一个类型不明的实例时, 它会调用coerce方法来进行数据类型变换。coerce方法会返回参数中的数值和本身。</P>
<P>Ruby库的数值类型变换顺序为</P><pre class="code">Fixnum -&gt; Bignum -&gt; Rational -&gt; Float -&gt; Complex
</PRE>
<H2>D<!-- RDLabel: "D" --></H2>

Data<!-- RDLabel: "Data" --> 

<P>该类可将C中的指针处理成Ruby对象。由C指针、mark函数和free函数构成。如果您想使用C语言来扩充Ruby的功能的话, 就必须掌握该类的使用方法。相反地, 如果您没有这个打算的话, 它也就没什么用了。</P>
defined?<!-- RDLabel: "defined?" --> 

<P>该操作符可以检查某对象(表达式)是否已经被定义。若未被定义就返回nil,若已被定义,就以字符串形式返回它的种类。虽然defined?看似一个方法,实际上它是Ruby语法中的操作符, 它不会对参数进行计算。因此下面的表达式</P><pre class="code">defined? print("abc\n")
</PRE>
<P>不会输出任何内容。</P>
<H2>E<!-- RDLabel: "E" --></H2>

Eiffel<!-- RDLabel: "Eiffel" --> 

<P>面向对象的编程语言。据说,早先matz在读了该语言作者所撰写的《Object-oriented Software Construction》之后顿觉恍然大悟。但奇怪的是Ruby与Eiffel却并不相似。如果硬要找出雷同之处的话, 可能只有两点: 1.Ruby的块以end结尾;2.Ruby也有rescue这个保留字。</P>
end<!-- RDLabel: "end" --> 

<P>该保留字表明了块的结束。据统计,大约有33%的人在看到这个end时会联想起Pascal(纯属杜撰)。但它并不和begin连用,因此它可能更接近于Ada或Eiffel。</P>
<P>Ruby之所以不使用C和Perl中的{},主要是因为以下原因</P>
<UL>
<LI>
<P>避开单句·复句的问题</P>
<P>例如在C语言中, 若想向下例中添加语句时</P><pre class="code">if (a==b)
   c();
</PRE>
<P>如果写成这样的话</P><pre class="code">if (a==b)
   c();
   d();
</PRE>
<P>就会造成难以发现的bug。即使是Pascal也存在这个问题。</P>
<LI>
<P>回避else的问题</P>
<P>与上例类似, 如果写出下面这样的语句的话</P><pre class="code">if (a==b)
   if (c==d) foo();
else bar();
</PRE>
<P>就会引起混乱。其实它的本意应该是</P><pre class="code">if (a==b) {
   if (c==d) foo();
   else bar();
}
</PRE>
<P>这个样子。</P>
<LI>
<P>提高可读性</P>
<P>可能您对此持有异议, 但有的人认为:用end来结束块的做法可以提高程序的可读性。</P>
<LI>
<P>begin和case语法表达上的问题</P>
<P>说句实话，matz曾多次想把end用作变量。甚至探讨过在ruby语法中添加{ }的问题，但因为无法完美地解决begin和case的语法表达的问题，最终不得不放弃这个念头。恐怕这才是最大的理由吧。</P></LI></UL>
ENV<!-- RDLabel: "ENV" --> 

<P>该对象的运作方式与访问环境变量的Hash相同。实际上，它就是添加了特殊方法的Object类的实例。使用该对象来修改环境变量后，其变化将会影响到Ruby的子进程。</P>
<H2>F<!-- RDLabel: "F" --></H2>

FAQ<!-- RDLabel: "FAQ" --> 
Frequently Asked Questions<!-- RDLabel: "Frequently Asked Questions" --> 

<P>常见的问题和解答。Ruby FAQ尚处于不断完善的阶段，问题和解答是随时更新的。</P>
<H2>G<!-- RDLabel: "G" --></H2>

goto<!-- RDLabel: "goto" --> 

<P>Ruby中没有该语句。这并不是因为“我们觉得不应该使用”goto，而是“实现其功能实在是太麻烦了”。实际上，您可以使用catch/throw或异常来实现goto的功能。</P>
<H2>H<!-- RDLabel: "H" --></H2>
<H2>I<!-- RDLabel: "I" --></H2>
<H2>J<!-- RDLabel: "J" --></H2>

JARH<!-- RDLabel: "JARH" --> 
Just another Ruby hacker,<!-- RDLabel: "Just another Ruby hacker," --> 
<H2>K<!-- RDLabel: "K" --></H2>
<H2>L<!-- RDLabel: "L" --></H2>
<H2>M<!-- RDLabel: "M" --></H2>

main<!-- RDLabel: "main" --> 

<P>顶层中的self。因为self是必不可少的，所以它只是表明在顶层中有个Object类的实例--self而已。另外为了操作Object类，还特别定义了若干特殊方法。</P>
<P>已定义的特殊方法</P>
<UL>
<LI>private 
<LI>public 
<LI>include </LI></UL>
matz<!-- RDLabel: "matz" --> 

<P>Ruby的作者，也叫松本 行弘。请参考&lt;URL:http://www.st.rim.or.jp/~fuku/cmail/&gt;，另外，他还是3个孩子的父亲。</P>
Mix-in<!-- RDLabel: "Mix-in" --> 
混合插入、糅合<!-- RDLabel: "混合插入、糅合" --> 

<P>就像在冰淇淋中混合多种配料可以做成美味的混合冰淇淋一样，在类中混合插入各种模块就可以添加相应的功能。请参考继承。</P>
<P>matz坚信滥用多重继承会导致继承关系的混乱，因此Ruby中不允许使用多重继承。同时为充分发挥继承功能的优势，Ruby支持两种继承关系：1.使用is-a语句的继承；2.使用Mix-in来共享并继承模块中的功能。</P>
<H2>N<!-- RDLabel: "N" --></H2>
<H2>O<!-- RDLabel: "O" --></H2>
<H2>P<!-- RDLabel: "P" --></H2>

Perl<!-- RDLabel: "Perl" --> 

<P>不必多说了罢</P>
POLS<!-- RDLabel: "POLS" --> 

<P>Principle of least surprise</P>
Python<!-- RDLabel: "Python" --> 

<P>Ruby的劲敌。其功力深厚，可谓“千年蛇妖”。但matz认为Python的功能仍不完美，不然就不会创造Ruby了。最要命的是Python限定了名称长度(6个字符)。</P>
<H2>Q<!-- RDLabel: "Q" --></H2>
<H2>R<!-- RDLabel: "R" --></H2>

RAA<!-- RDLabel: "RAA" --> 

<P>Ruby Application Archive(RAA)</P>
RCR<!-- RDLabel: "RCR" --> 

<P>Ruby Change Request</P>
RD<!-- RDLabel: "RD" --> 

<P>Ruby Document</P>
Ruby<!-- RDLabel: "Ruby" --> 

<P>面向对象的脚本语言。Ruby的意思是“紧跟在Perl(pearl是6月的诞生石，Ruby则是7月的诞生石)之后”。Ruby并不是其他单词的缩写。</P>
<H2>S<!-- RDLabel: "S" --></H2>

Sather<!-- RDLabel: "Sather" --> 

<P>面向对象的编程语言。其实matz钟爱Sather胜过Eiffel。但Ruby与Sather一点都不像。</P>
self<!-- RDLabel: "self" --> 

<P>表示被调的表达式。那为什么把它叫做self呢？因为如果把方法看作动词的话，那么被调就是该动作的主语，从方法的角度来看，被调当然就是<EM>自己</EM>了。一般人认为，Ruby对此并未深究，只不过是模仿Smalltalk的做法罢了。</P>
Smalltalk<!-- RDLabel: "Smalltalk" --> 

<P>面向对象的编程语言。它奠定了现代面向对象 理论体系的基础。</P>
super<!-- RDLabel: "super" --> 

<P>在重定义的方法中调用上级方法。省略参数时，将使用主调方方法的参数来进行调用。</P>
<UL>
<LI>
<P>问题:</P>
<P>修改参数中给出的数值后再调用super的话，将会使用原来的值还是修改后的值呢？</P><pre class="code">def foo(a)
   print a
end
def self.foo(a)
  a=25
  super
end
foo(5)    # 5 or 25??
</PRE>
<LI>
<P>答案:</P>
<P>使用修改后的值(25)</P></LI></UL>
<H2>T<!-- RDLabel: "T" --></H2>

Thread<!-- RDLabel: "Thread" --> 

<P>原为Thread of control的缩略语，意指一系列的控制流。在Ruby中，一个程序内可以同时存在若干线程。</P>
<H2>U<!-- RDLabel: "U" --></H2>

undef<!-- RDLabel: "undef" --> 

<P>将方法设置为未定义状态。继承 和Mix-in的功能都是在类中添加方法，而undef则可以取消方法。但是，如果取消了类所必需的方法(被其他方法所调用的方法)的话，其后果不堪设想。</P>
<H2>V<!-- RDLabel: "V" --></H2>
<H2>W<!-- RDLabel: "W" --></H2>
<H2>X<!-- RDLabel: "X" --></H2>
<H2>Y<!-- RDLabel: "Y" --></H2>
<H2>Z<!-- RDLabel: "Z" --></H2>
<H1><BR>--按拼音排序</H1>
<H2>A</H2>

<H2>B</H2>

被调<!-- RDLabel: "被调" --> 
Receiver<!-- RDLabel: "Receiver" --> 

<P>方法的执行主体。也就是方法调用表达式的`.'中的左边部分。在方法内，可以使用self来表示它。另外，您可以使用@变量名的形式来访问被调的实例变量。</P>
变量<!-- RDLabel: "变量" --> 
Variable<!-- RDLabel: "Variable" --> 

<P>贴在对象上的标签。Ruby的变量包括全局变量、局部变量和实例变量。因为常数的值不能改变，所以不是<EM>变</EM>量。但它也是一种标签，因此在这一点上它与变量是相同的。</P>
<H2>C</H2>

常数<!-- RDLabel: "常数" --> 
Constant<!-- RDLabel: "Constant" --> 

<P>一旦定义了就不能再改变的变量。这个定义本身似乎就有点矛盾。</P>
重定义<!-- RDLabel: "重定义" --> 
Override<!-- RDLabel: "Override" --> 

<P>即指再定义。重新定义超类或include模块中已经定义的方法。使用super即可调用原来的方法。</P>
抽象数据类型<!-- RDLabel: "抽象数据类型" --> 
Abstract Data Type<!-- RDLabel: "Abstract Data Type" --> 

<P>将数据构造和对其进行操作的过程封装在一起，就形成了抽象数据类型。对抽象数据进行操作时，必须使用封装内的操作才行。其结果是不能从外部直接使用数据构造，同时一旦内部构造发生变化也不会对外界造成不良影响。我们把这个过程叫做封装。</P>
初始化<!-- RDLabel: "初始化" --> 
Initialize<!-- RDLabel: "Initialize" --> 

<P>使对象(或“某事物”)变为“就绪”状态。对实例进行初始化操作时，需要重定义Object#initialize方法。类方法Class#new的默认定义就是对新生成的实例执行initialize方法。传给new的参数会被原封不动地传给initialize。另外，若带块调用时，该块会被传给initialize。</P>
<P>因此，不必对Class#new进行重定义。</P>
辞典<!-- RDLabel: "辞典" --> 
Dictionary<!-- RDLabel: "Dictionary" --> 

<P>根据给出的条目即可查出对应的定义。它是哈希表的别名。面向对象的始作俑者Smalltalk把类似哈希表的数据构造称作“辞典”，所以时至今日仍然有一些人把哈希表称作辞典。</P>
<H2>D</H2>

大Endian<!-- RDLabel: "大Endian" --> 
Big Endian<!-- RDLabel: "Big Endian" --> 

<P>美洲大陆的原住民是Indian而并非Endian，那么这个Endian的词源是什么呢？其实它出自Jonathan Swift写的《格列佛游记》。这本书中的人们因为吃鸡蛋的方法不同而分成两类，从圆头开始吃的叫大Endian，从尖头开始吃的叫小Endian。在计算机业界，该词表示CPU等排列数据的一种方式，据说网络一族的人们喜欢大Endian。请参考字节顺序。</P>
大规模退出<!-- RDLabel: "大规模退出" --> 
Non-Local Exit<!-- RDLabel: "Non-Local Exit" --> 

<P>它并不是那种发生在break, next, redo, retry, return等方法的范围内的普通退出，而是一种跨度极大的退出。只要没被捕捉到，它甚至会跳出方法调用的牢笼来引发中断。Ruby的大规模退出包括由异常引起的退出和catch/throw。</P>
<P>大多数的异常(包括由exit所引发的SystemExit在内)都会被rescue 捕捉到。但是若该异常不值得捕捉(例：内存分配失败／解释器的bug)的话，就会放他一马。</P>
<P>在catch/throw中，通常会从被throw的地方起一直跳转到与throw部分具有相同标签的catch部分为止。</P>
迭代器<!-- RDLabel: "迭代器" --> 
Iterator<!-- RDLabel: "Iterator" --> 

<P>即指调用带块方法。当初为了进行迭代操作而设置了带块方法，现在它仍然常被称作迭带器。虽然可以将那些进行迭代操作的方法叫做迭代器，但如果将所有带块方法的调用过程都看作迭带器的话，势必会引起混乱。</P>
调用带块方法<!-- RDLabel: "调用带块方法" --> 

<P>我们把那些可接受代码段(块)的方法叫做带块方法。调用带块方法就是指调用这些带块方法的过程。</P>
<P>在带块方法中使用yield就可以执行块的内容。</P>
<P>当然了，如何处理给出的块，这完全取决于方法。所以，如果硬是把块传给一个不能带块的方法的话，也不会有什么结果，而且也不会发生错误。</P>
动态绑定<!-- RDLabel: "动态绑定" --> 
Dynamic Binding<!-- RDLabel: "Dynamic Binding" --> 

<P>指在运行时根据操作对象的数据类型的不同来选择合适的过程(方法)。它可以提高程序的灵活性。它是面向对象的必要条件之一。在Ruby中变量是没有类型的，因此必然可以进行动态绑定。</P>
动态局部变量<!-- RDLabel: "动态局部变量" --> 
Dynamic Local Variable<!-- RDLabel: "Dynamic Local Variable" --> 

<P>它是一种特殊的局部变量。Ruby的局部变量的作用域是固定的，因此在编译时就会生成局部变量。动态局部变量则有所不同，每次执行时才会生成变量。在块中首次被赋值的局部变量就是动态局部变量，其作用域仅限于块的内部。这主要是为了让各个Thread都能拥有自己独立的变量而设的。</P>
对象<!-- RDLabel: "对象" --> 
Object<!-- RDLabel: "Object" --> 

<P>即指<EM>物体</EM>。举个例子，“爱”可能不是对象，但“情书”却是对象。甄别某事物是否属于对象，这可能是个哲学问题。或许正因为如此，面向对象也变得扑朔迷离起来。在计算机业界有人认为对象就是指内存中的特定空间。到底何谓对象，还真是个难题。另外，请参考封装和抽象数据类型。</P>
多态<!-- RDLabel: "多态" --> 
多态, Polymorphism<!-- RDLabel: "多态, Polymorphism" --> 

<P>根据对象的不同选择合适的操作。在Ruby中的实现方法是，根据被调的对象的不同来选择不同的方法。</P>
<UL>
<LI>
<P>例</P><pre class="code">obj = "abc"
print obj.length, "\n"          # =&gt; 3
obj = [1,2,3,4]
print obj.length, "\n"          # =&gt; 4
</PRE></LI></UL>
<H2>F</H2>

方法<!-- RDLabel: "方法" --> 
Method<!-- RDLabel: "Method" --> 

<P>对对象进行的操作。操作对象(被调)以self来表示。在Ruby中，除去内部类的对象以外，通常对象的构造都是动态确定的。某对象的性质由其内部定义的方法所决定。</P>
封装<!-- RDLabel: "封装" --> 
Encapsulation<!-- RDLabel: "Encapsulation" --> 

<P>将内部结构和算法隐藏起来，以确保只有特定的过程(也叫方法)才能直接操作数据，这种隔离方法就叫做封装。请参考抽象数据类型。</P>
<P>在Ruby中，只有方法可以操作实例变量，因此可以说Ruby中的封装是强制性的。</P>
<H2>G</H2>

关联数组<!-- RDLabel: "关联数组" --> 
Associative Array<!-- RDLabel: "Associative Array" --> 

<P>哈希表的别名。因为哈希表可以使用任意的键来引出值，这就是“关联”特性。另外，可以将哈希表看作是使用非数字形式索引的数组，这是它的“数组”特性，因此它也叫做“关联数组”。以前是使用硬件来实现关联数组(也叫关联记忆)的功能的，但是随着计算速度的攀升以及关键算法(叫做“哈希表”，它是现在的哈希表的词源)的成功研发，现在只用软件就可以实现其功能了。</P>
<H2>H</H2>

哈希表<!-- RDLabel: "哈希表" --> 
Hash<!-- RDLabel: "Hash" --> 

<P>Ruby中的一种从键到值的映像(mapping)。也叫做关联数组或辞典。哈希表之所以得此名，是因为在实现其功能时使用了一种叫做“哈希表”的算法。哈希的意思是“切碎”，是“hashed beef”中的“hash”。</P>
函数<!-- RDLabel: "函数" --> 
Function<!-- RDLabel: "Function" --> 

<P>严格地讲，Ruby中没有函数。但那些省略被调的方法调用看来确实很像函数，而且有的方法根本不需要self或实例变量等被调信息，事实上后者已成为函数了。所以有时也就网开一面地把这样的方法叫成函数了。</P>
<P>通常将这种函数(式的方法)的方法可视性设成了private，这样就只能以省略被调的形式来调用它们了。这类方法中比较有代表性的是 模块函数。</P>
环境变量<!-- RDLabel: "环境变量" --> 
Environment Variable<!-- RDLabel: "Environment Variable" --> 

<P>父进程传给子进程的值。使用ENV就可以访问环境变量。传给子进程只是环境变量的副本，因此子进程无法通过环境变量来向父进程传递信息。这就好比老子不会听小孩的话一样。</P>
<H2>J</H2>

继承<!-- RDLabel: "继承" --> 
Inheritance<!-- RDLabel: "Inheritance" --> 

<P>主要依赖于从祖先或亲戚那里继承的功能，而自己只做一些补充性的工作。在现实世界中，这种行为是要遭到唾弃的，但在计算机世界里这却是个很经济的做法。继承也可以指在某类中添加新功能后生成一个新的类。继承可以用is-a的关系来加以诠释。例如，如果您要生成一个“理科学生”类的话，需要首先继承描述一般学生特征的“学生”类，然后再添加“整天忙于应付实验”等特征后即可生成该类。若不存在is-a关系，而只想共享某些特性或功能时，我们推荐您使用Mix-in。</P>
脚本<!-- RDLabel: "脚本" --> 
Script<!-- RDLabel: "Script" --> 

<P>脚本，特指由解释器进行处理的较短的程序。当然了，其中也不乏大作。</P>
脚本语言<!-- RDLabel: "脚本语言" --> 
Script Language<!-- RDLabel: "Script Language" --> 

<P>脚本语言。</P>
局部变量<!-- RDLabel: "局部变量" --> 
Local Variable<!-- RDLabel: "Local Variable" --> 

<P>只能在特定范围内使用的变量。该范围就是作用域。Ruby的作用域包括</P>
<UL>
<LI>程序整体 
<LI>类·模块定义 
<LI>方法定义 
<LI>块 </LI></UL>
<P>几种。只有块能访问外侧作用域的局部变量。局部变量的作用域 从该变量首次被赋值的位置起 直到该赋值位置所在的作用域结束为止。这个优先范围是静态决定的，与具体的运行情况无关。</P>
<H2>K</H2>

块<!-- RDLabel: "块" --> 
Block<!-- RDLabel: "Block" --> 

<P>可用来构成循环或打家劫舍。</P>
<H2>L</H2>

类方法<!-- RDLabel: "类方法" --> 
Class Method<!-- RDLabel: "Class Method" --> 

<P>就是类的方法。可分为两种：第一种是在所有的类的超类Class中定义的，且被所有的类所共享的方法；第二种是各个类所特有的特殊方法。这倒没什么问题。重要的是类方法中的self指的是类本身，这点需要牢记。</P>
立即值<!-- RDLabel: "立即值" --> 
Immediate Value<!-- RDLabel: "Immediate Value" --> 

<P>实际的数值就保存在变量之中，这和引用是不同的。目前，Ruby中只有Fixnum、Symbol和nil/true/false是立即值。然而Ruby的某些版本并未将Fixnum算做立即值，这也无关紧要。在理论模型层面上，可以将所有的值都看作是对某对象的引用。</P>
理论体系<!-- RDLabel: "理论体系" --> 
Paradigm<!-- RDLabel: "Paradigm" --> 

<P>类似于“思维方式”，这个词很难说得清楚。</P>
<H2>M</H2>

面向对象<!-- RDLabel: "面向对象" --> 

<P>以对象为中心的理论体系。英语中的"Object-Oriented"是个形容词，可是到了日语中就变成名词了。似乎只要将对象置于思考的中心点就万事大吉了，但也要兼顾一下几点</P>
<UL>
<LI>继承 
<LI>封装 
<LI>
<P>多态</P>
<P>(或者动态绑定)</P></LI></UL>
<P>有人甚至把它看作是包治百病的“魔法”，但事实上世界并非如此简单。面对对象概念诞生至今已逾20个年头，它已经磨砺成为一把实用的利剑。</P>
面向对象设计<!-- RDLabel: "面向对象设计" --> 
Object-Oriented Design<!-- RDLabel: "Object-Oriented Design" --> 

<P>以对象作为出发点的系统设计</P>
面向对象编程<!-- RDLabel: "面向对象编程" --> 
Object-Oriented Programming<!-- RDLabel: "Object-Oriented Programming" --> 

<P>以对象作为编程的中心。</P>
面向对象分析<!-- RDLabel: "面向对象分析" --> 
Object-Oriented Analysis<!-- RDLabel: "Object-Oriented Analysis" --> 

<P>以对象为根本的系统分析。</P>
模块函数<!-- RDLabel: "模块函数" --> 
Module Function<!-- RDLabel: "Module Function" --> 

<P>在那些函数式的方法中，模块函数既可用作模块的方法，又可用作特殊方法。例如Math模块中的大部分方法都是模块函数。您既可以这样</P><pre class="code">Math.sqrt(2)
</PRE>
<P>又可以这样</P><pre class="code">include Math
sqrt(2)
</PRE>
<P>来使用它们。</P>
<H2>N</H2>

内部类<!-- RDLabel: "内部类" --> 
Built-In Class<!-- RDLabel: "Built-In Class" --> 

<P>这些内部类被嵌入Ruby解释器内部，其实例的结构与普通对象有所不同。我们不建议您继承内部类。Ruby的内部类如下所示(实际上远不止这些，更多详情请参考内部类/模块/异常类)</P>
<UL>
<LI>Array 
<LI>Bignum 
<LI>Class 
<LI>Data 
<LI>FalseClass 
<LI>File 
<LI>Fixnum 
<LI>Float 
<LI>Hash 
<LI>IO 
<LI>MatchData 
<LI>Module 
<LI>NilClass 
<LI>Proc 
<LI>Regexp 
<LI>String 
<LI>Struct 
<LI>Thread 
<LI>TrueClass </LI></UL>
<H2>P</H2>

排序<!-- RDLabel: "排序" --> 
Sort<!-- RDLabel: "Sort" --> 

<P>将对象依次排列。只要元素是可数的(include了Enumerable)、且已定义了顺序(定义了&lt;=&gt;)的话，Ruby就可以对这些元素的集合进行排序。这并不仅限于数组，也适用于其他复杂对象的集合。</P>
破坏性的<!-- RDLabel: "破坏性的" --> 
Destructive<!-- RDLabel: "Destructive" --> 

<P>因为String#chop!, Array#concat这种方法会直接改变被调的状态，因而会产生“破环性的作用”。不过您不必担心，因为它们不会损坏您的计算机。</P>
<H2>Q</H2>

全局变量<!-- RDLabel: "全局变量" --> 
Global Variable<!-- RDLabel: "Global Variable" --> 

<P>在程序的各个角落中都可以使用的变量。比较危险，少用为佳。</P>
<H2>R</H2>

<H2>S</H2>

实例<!-- RDLabel: "实例" --> 
Instance<!-- RDLabel: "Instance" --> 

<P>即指对象。在强调对象归属于某类时，常使用实例这个词。据说有好多人因为不了解对象和实例的关系，因而搞不懂面对对象到底是怎么一回事儿。</P>
实例变量<!-- RDLabel: "实例变量" --> 
Instance Variable<!-- RDLabel: "Instance Variable" --> 

<P>对象所特有的变量。Ruby实例变量名前都有一个@符号，您只能在方法内部使用它。</P>
<H2>T</H2>

特殊方法<!-- RDLabel: "特殊方法" --> 
Singleton Method<!-- RDLabel: "Singleton Method" --> 

<P>专属于某特定对象的方法。请参考方法。在下列情况下，其他对象也可以继承该特殊方法。</P>
<UL>
<LI>Kernel#clone时 
<LI>定义了子类时 </LI></UL>
<P>若在特殊方法中重定义了原先类中的方法时，可以使用super来调用原来的方法。</P>
特殊类<!-- RDLabel: "特殊类" --> 
Singleton Class<!-- RDLabel: "Singleton Class" --> 

<P>只对应于某特定对象的假想类。</P>
<H2>W</H2>

文档<!-- RDLabel: "文档" --> 
Document<!-- RDLabel: "Document" --> 

<P>matz最头疼的就是写文档了。他平时总是说“源代码就是文档。连bug也写得清清楚楚”，当然了谁都不以为然。</P>
<H2>X</H2>

小Endian<!-- RDLabel: "小Endian" --> 
Little Endian<!-- RDLabel: "Little Endian" --> 

<P>开始有10个人，后来越来越少。在计算机业界中，它是表示一种排列数据的形式。据说有一家大的CPU制造商很喜欢小Endian。请参考字节顺序。</P>
<H2>Y</H2>

异常<!-- RDLabel: "异常" --> 
Exception<!-- RDLabel: "Exception" --> 

<P>遇到非正常情况就会引发异常。发生异常时，只要没使用begin中的rescue进行捕捉的话，它将跨越方法调用的阻拦，进而中断程序(thread)的运行。有了异常处理功能之后，我们就不必再逐一检查Ruby程序中的每个异常情况了。发生异常的地点信息被保存在$@中，而异常本身的信息被保存在$!中。</P>
<H2>Z</H2>

再定义<!-- RDLabel: "再定义" --> 
Redefinition<!-- RDLabel: "Redefinition" --> 

<P>即指重定义。</P>
字节顺序<!-- RDLabel: "字节顺序" --> 
Byte Order<!-- RDLabel: "Byte Order" --> 

<P>将0x01020304这4个字节数据按照1,2,3,4或是4,3,2,1的顺序排列。前者叫做大Endian，而后者叫做小Endian。人们一直在争论哪种方法更好，但至今尚无定论。</P>


<div class="rpindex"><a href="89.html"> 下一页</a><a href="87.html"> 上一页</a><a href="index.html">首页</a></div>



<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
