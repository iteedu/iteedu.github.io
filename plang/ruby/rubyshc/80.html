<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->


<div class="lpindex"><a href="index.html">首页</a><a href="79.html"> 上一页</a><a href="81.html"> 下一页</a></div>

<H1>内部函数<!-- RDLabel: "内部函数" --></H1>
<P>严格说来,Ruby中没有函数.但Kernel模块中定义的方法(可以在任何地方用做函数,因此)可被其他语言当做函数来调用.若您对这些方法进行再定义时,就必需考虑到对其他方面的影响.</P>

<h5>` str
  <!-- RDLabel: "` str" --> 
  
</h5>
<P>把字符串str当做外部命令来运行,并以字符串方式返回命令的输出.使用`str`形式来调用该方法(还可以使用%x(...)表示法进行调用.请参考命令输出).</P>
<P>可以使用$?来了解命令的结束状态.</P>
<P>若您只想执行命令,而不需要得到命令输出时,可以使用system.如果是那些终端控制命令的话,`command`可能会运行失败.</P>
<h5>Array(arg)
  <!-- RDLabel: "Array" --> 
  
</h5>
<P>调用 arg.to_ary 或 arg.to_a 将参数转为数组并返回结果.若变换后没有得到数组就会引发TypeError异常.</P>
<P>若arg中没有to_ary或to_a方法的话,就返回只包含一个元素的数组[arg].</P>
<h5>Float(arg)
  <!-- RDLabel: "Float" --> 
  
</h5>
<P>将参数变为浮点数(Float)并返回结果.</P>
<P>若将不能转为整数或浮点数的字符串传递给参数的话,会引发ArgumentError异常.</P>
<P>请参考String#to_f.</P>
<pre class="code">p Float("10")    # =&gt; 10.0
p Float("10e2")  # =&gt; 1000.0
p Float("1e-2")  # =&gt; 0.01
p Float(".1")    # =&gt; 0.1

p Float("nan")   # =&gt; NaN         (ruby 1.7 特性: =&gt; invalid value (ArgumentError))
p Float("INF")   # =&gt; Infinity    (ruby 1.7 特性: =&gt; invalid value (ArgumentError))
p Float("-Inf")  # =&gt; -Infinity   (ruby 1.7 特性: =&gt; invalid value (ArgumentError))
p Float(("10" * 1000).to_f) # =&gt; Infinity

p Float("0xa.a") # =&gt; 10.625    # (ruby 1.7 特性: =&gt; invalid value (ArgumentError))
p Float(" \n10") # =&gt; 10.0      # 前面的空白被忽略
p Float("1_0_0") # =&gt; 100.0     # `_' 也被看做是数值要素
p Float("")      # =&gt; invalid value (ArgumentError)
p Float(nil)     # =&gt; 0.0       # ruby1.7特性: cannot convert nil into Float (TypeError)

p Float(Object.new) # =&gt; cannot convert Object into Float (TypeError)
</PRE>
<h5>Integer(arg)
  <!-- RDLabel: "Integer" --> 
  
</h5>
<P>将参数变为整数(Fixnum,Bignum)并返回结果.对数值,字符串以外的对象使用to_i方法(Ruby 1.7 特性:在1.7中是to_int).若变换结果不是整数(Integer的子类)就会引发TypeError异常.</P>
<P>若参数是字符串的话,将按其前缀,如0x,0b,0等分别决定要按照16进制,2进制或是8进制的标准来处理该字符串.</P>
<P>若把不能变为整数的字符串传递给参数时,将引发ArgumentError异常.</P>
<pre class="code">p Integer(10.1)       # =&gt; 10
p Integer(10.8)       # =&gt; 10
p Integer("10")       # =&gt; 10
p Integer("10_0_0")   # =&gt; 1000
p Integer("10__0")    # =&gt; 100
                      # =&gt; invalid value for Integer: "10__0" (ArgumentError) (ruby 1.7 特性)
p Integer("_10")      # =&gt; invalid value for Integer: "_10" (ArgumentError)
p Integer("10_")      # =&gt; invalid value for Integer: "10_" (ArgumentError)
p Integer("0d10")     # =&gt; invalid value for Integer: "0d10" (ArgumentError)
                      # =&gt; 10 (ruby 1.7 特性)
p Integer("010")      # =&gt; 8
p Integer("0o10")     # =&gt; invalid value for Integer: "0o10" (ArgumentError) (ruby 1.7 特性)
                      # =&gt; 8
p Integer("0x10")     # =&gt; 16
p Integer("0b10")     # =&gt; 2
p Integer(" \n10\t ") # =&gt; 10
p Integer("")         # =&gt; `Integer': invalid value for Integer: "" (ArgumentError)
p Integer(nil)        # =&gt; 0

p Integer(Object.new) # =&gt; cannot convert Object into Integer (TypeError)
</PRE>
<P>请参考String#hex,String#oct,String#to_i.</P>
<h5>String(arg)
  <!-- RDLabel: "String" --> 
  
</h5>
<P>调用arg.to_s将参数变为字符串并返回结果。若变换后的结果并非字符串的话，会引发TypeError异常。若arg已经是字符串的话，则不作任何处理直接返回arg。</P>
<h5>abort
  <!-- RDLabel: "abort" -->
  abort(message) ((&lt;ruby 1.7 特性&gt;))
  <!-- RDLabel: "abort" --> 
  
</h5>
<P>以非正常方式结束Ruby程序的运行。它与Exit的区别在于，调用时若$!不为nil的话，就将异常消息输出到标准错误输出当中；另外，程序的结束status始终都是EXIT_FAILURE(在绝大多数环境中都是1)。</P>
<P>ruby 1.7 特性:若指定了message参数的话，就将message赋值给SystemExit#message后输出到标准错误输出中。</P>
<h4>at_exit { .... }
  <!-- RDLabel: "at_exit" --> 
  
</h4>
<P>在解释器结束工作之前执行指定的块。除去at_exit是个方法这点差异之外，它与END块所进行工作基本相同。一旦注册了要进行的处理内容之后就不能取消。请参考结束时的相关处理。</P>
<P>Proc对象返回注册的处理内容。</P>
autoload(const_name, feature)
<!-- RDLabel: "autoload" -->
autoload?(const_name) ((&lt;ruby 1.8 feature&gt;))
<!-- RDLabel: "autoload?" --> 

<P>在首次调用常数const_name时会require feature。const_name可以是字符串或Symbol。而且const_name中不能包含"::"操作符(即只能指定顶层的常数)。</P>
<P>返回nil。</P>
<P>ruby 1.8 特性：可以autoload任何类／模块的常数。const_name中还是不能有"::"操作符，可以像下面这样定义。(实际上是调用了Module#autoload)</P>
<pre class="code">------- /tmp/foo.rb ---------
class Foo
  class Bar
  end
end
----- end of /tmp/foo.rb ----

class Foo
  autoload :Bar, '/tmp/foo.rb'
end
p Foo::Bar
</PRE>
<P>另外，还可以下面这样定义。</P>
<pre class="code">class Foo
end
Foo.autoload :Bar, '/tmp/foo.rb'
p Foo::Bar
</PRE>
<P>autoload?的功能是，若autoload常数尚未定义(没被load)时，返回其路径名。另外，若已经load的话就返回nil。</P>
<pre class="code">------- /tmp/foo.rb ---------
class Foo
  class Bar
  end
end
----- end of /tmp/foo.rb ----

class Foo
end
Foo.autoload :Bar, '/tmp/foo.rb'
p Foo.autoload?(:Bar)         # =&gt; "/tmp/foo.rb"
p Foo::Bar                    # =&gt; Foo::Bar
p Foo.autoload?(:Bar)         # =&gt; nil
</PRE>
<P>请注意下例。在autoload的库中，嵌套内的常数还没有被定义。乍看起来好像会正常运行，实则不然(出现了警告消息)。</P>
<pre class="code">------- /tmp/bar.rb ---------
class Bar
end
----- end of /tmp/bar.rb ----

class Foo
  autoload :Bar, '/tmp/bar.rb'
end
p Foo::Bar
p Foo.autoload?(:Bar)

# =&gt; -:4: warning: toplevel constant Bar referenced by Foo::Bar
     Bar
     nil
</PRE>
<P>若不使用嵌套的话，可以把上例简写为</P>
<pre class="code">class Foo
end
class Bar
end
p Foo::Bar

# =&gt; -:5: warning: toplevel constant Bar referenced by Foo::Bar
     Bar
</PRE>
<h5>binding
  <!-- RDLabel: "binding" --> 
  
</h5>
<P>生成并返回Binding对象。该对象包含变量、方法等的环境信息，它通常用作Eval的第二参数。</P>
<h5>caller([level])
  <!-- RDLabel: "caller" --> 
  
</h5>
<P>以$@的back trace(字符串数组)形式返回level层上(省略参数时为1)的调用者的信息。若是顶层的话就返回空数组。将caller的返回值代入$@就可以设定异常的发生位置。</P>
<pre class="code">def foo
  p caller(0)
  p caller(1)
  p caller(2)
  p caller(3)
end

def bar
  foo
end

bar

=&gt; ["-:2:in `foo'", "-:9:in `bar'", "-:12"]
   ["-:9:in `bar'", "-:12"]
   ["-:12"]
   []
</PRE>
<P>下列函数可以从caller的要素中抽取并返回[文件名、行号、方法名]。</P>
<pre class="code">def parse_caller(at)
  if /^(.+?):(\d+)(?::in `(.*)')?/ =~ at
    file = $1
    line = $2.to_i
    method = $3
    [file, line, method]
  end
end

def foo
  p parse_caller(caller.first)
end

def bar
  foo
  p parse_caller(caller.first)
end

bar
p parse_caller(caller.first)

=&gt; ["-", 15, "bar"]
   ["-", 19, nil]
   nil
</PRE>
<P>当$DEBUG为真时，debug函数非常有用。以下是该函数例程。</P>
<pre class="code">def debug(*args)
  p [caller.first, *args] if $DEBUG
end

debug "debug information"

=&gt; ["-:5", "debug information"]
</PRE>
<h5>callcc {|cont| .... }
  <!-- RDLabel: "callcc" --> 
  
</h5>
<P>请参考Continuation。</P>
<h5>catch(tag) {|tag| .... }
  <!-- RDLabel: "catch" --> 
</h5>
<P>运行块并返回它的值。若在块的运行过程中，遇到与tag同名的throw的话，将把throw的第二参数的值作为返回值。</P>
<P>例如下例代码在运行过程中不会调用some_process，同时catch的值是25，而并非10。</P>
<pre class="code">ret = catch(:exit) {
   throw :exit, 25
   some_process()
   10
}
p ret   #=&gt; 25
</PRE>
<P>嵌套的循环不会因为遇到break就一下子跳出。这时可使用catch或异常。</P>
<pre class="code">catch(:loop1) {
  for i in 1..2
    for j in 1..2
      throw :loop1, j
    end
  end
}
</PRE>
chop
<!-- RDLabel: "chop" --> 
chop!
<!-- RDLabel: "chop!" --> 

<P>将内部变量$_末尾的字符去掉(若末尾是"\r\n"则去掉2个字符)。chop!将改变字符串本身并返回结果。若没有可以去掉的字符则返回nil。</P>
<P>请参考String#chop了解详情。chop函数与$_.chop之间存在以下区别。</P>
<UL>
  <LI>chop先拷贝$_的值，然后对拷贝进行修改，最后把这个拷贝的值重新赋值给$_。 </LI>
</UL>
<h5>chomp([rs])
  <!-- RDLabel: "chomp" --> 
  chomp!([rs])
  <!-- RDLabel: "chomp!" --> 
  
</h5>
<P>去掉位于内部变量$_末尾且由rs指定的字符。chomp!将改变字符串本身并返回结果。若没有可被去掉的字符串则返回nil。rs的默认值为$/</P>
<P>请参考String#chomp了解详情。chomp函数与$_.chomp之间存在以下区别。</P>
<UL>
  <LI>chomp先拷贝$_的值，然后对拷贝进行修改，最后把这个拷贝的值重新赋值给$_。 </LI>
</UL>
eval(expr[, binding[, fname[, lineno=1]]])
<!-- RDLabel: "eval" --> 

<P>把字符串expr当作Ruby程序来运行并返回其结果。若给第二参数传递Proc对象或Binding对象的话，将在生成该对象的环境中对字符串进行计算。请参考binding。</P>
<pre class="code">def foo
  a = 1
  binding
end

eval("p a", foo)  # =&gt; 1
</PRE>
<P>若指定了fname 和 lineno的话，将假定字符串位于fname文件lineno行，并且进行编译。这时可以显示栈跟踪(stack trace)等信息。</P>
<h5>exec(command)
  <!-- RDLabel: "exec" --> 
  exec(program[, arg1[, arg2[, ...]]])
  <!-- RDLabel: "exec" --> 
  
</h5>
<P>执行由command指定的命令.该命令(或shell,详见下文)将变成进程执行的代码,所以一旦启动成功,就不会再从该函数中返回.若启动失败,控制权重新回归ruby解释器,然后会引发Errno::EXXX异常.</P>
<P>在第一种语句中,若command中包含shell的元字符(* ? {} [] &lt;&gt; () ~ &amp; | \ $ ; ' ` " \n)的话,则经由shell执行命令.除此之外,将由解释器直接执行</P>
<P>使用第二种语句时,通常不经过shell就执行命令.此时,将把空字符或shell的元字符等原般不动地传递给program的参数.若首个参数是包含两个元素的数组时,第一个元素的字符串将成为启动程序时的路径,而第二个元素将成为程序名的"别名".</P>
<P>ruby 1.8 特性:即使第一个元素不是完整路径,也会自动从环境变量PATH中开始搜索.</P>
<h5>exit([status])
  <!-- RDLabel: "exit" --> 
</h5>
<P>终止Ruby程序的运行.若向status传递了一个整数的话,该整数就将成为Ruby命令的结束状态值.默认的结束状态值是0.</P>
<P>exit通过引发SystemExit异常来结束程序的运行.若有必要的话,可以使用rescue部分来捕捉到它.</P>
<P>ruby 1.8 特性:若status为true的话,就以EXIT_SUCCESS作为结束状态值.若status为false的话,就以EXIT_FAILURE作为结束状态值.默认的结束状态值已被改为EXIT_SUCCESS.</P>
<h5>exit!([status])
  <!-- RDLabel: "exit!" --> 
  
</h5>
<P>以整数status为结束状态值来终止Ruby程序的运行.默认的结束状态值为-1.</P>
<P>exit!与exit不同,它不会进行异常处理.在fork之后,若想终止子进程时可以使用该语句.</P>
<P>ruby 1.8 特性:若status为true的话,就以EXIT_SUCCESS作为结束状态值.若status为false的话,就以EXIT_FAILURE作为结束状态值.默认的结束状态值已被改为EXIT_FAILURE.</P>
<h5>fork
  <!-- RDLabel: "fork" --> 
  fork { ... }
  <!-- RDLabel: "fork" --> 
  
</h5>
<P>使用fork(2)系统调用来制作进程的拷贝.若在父进程中将返回子进程的进程ID,若在子进程中则返回nil.若指定一个块之后再进行调用,则会在生成的子进程中对该块进行计算.</P>
<h5>gets([rs])
  <!-- RDLabel: "gets" --> 
  readline([rs])
  <!-- RDLabel: "readline" --> 
  
</h5>
<P>Ruby解释器在运行时,会把从参数那里得到的文件(若没有的话,就利用标准输入)假设成一个虚拟文件(可以使用内部变量$&lt;或ARGF访问该虚拟文件),然后从该虚拟文件中读入一行,并返回字符串.若到达文件尾部时返回nil.</P>
<P>使用rs指定的字符串作为行的切分符号.rs的默认值取自内部变量$/.读入的字符串也被存入内部变量$_中.</P>
<P>若将rs设为nil的话,则意味着读入文件的全部内容而忽略行的切分.若设为空字符串""的话,会把连续的换行当做行的切分符(段落模式).</P>
<P>readline的功能与gets相同,但是当它遇到文件结尾时会引发EOFError异常.</P>
global_variables
<!-- RDLabel: "global_variables" --> 

<P>返回程序中已定义的全局变量(以'$'开头的变量)名的数组.</P>
<P>另外请参考local_variables, Object#instance_variables, Module.constants, Module#constants, Module#class_variables.</P>
gsub(pattern[, replace])
<!-- RDLabel: "gsub" --> 
gsub!(pattern[, replace])
<!-- RDLabel: "gsub!" --> 
gsub(pattern) {|matched| ... }
<!-- RDLabel: "gsub" --> 
gsub!(pattern) {|matched| ... }
<!-- RDLabel: "gsub!" --> 

<P>在内部变量$_所包含的字符串中,将符合pattern的部分替换为replace,然后返回结果.若省略参数replace时,该方法将演变为迭代器,以块的计算值进行替换操作.将匹配的字符串以参数的形式传递给块.</P>
<pre class="code">$_ = "foobar"
p gsub(/o+/) {|m|
  m.upcase
}
# =&gt; "fOObar"
</PRE>
<P>gsub!将改写$_所包含的字符串本身.请参考String#gsub来获得更多资讯.String#gsub和gsub之间存在以下差异.</P>
<UL>
  <LI>gsub方法会拷贝$_的值,然后对拷贝进行更新,最后再赋值给$_. </LI>
</UL>
<h5>iterator? ((&lt;obsolete&gt;))
  <!-- RDLabel: "iterator?" --> 
  block_given?
  <!-- RDLabel: "block_given?" --> 
  
</h5>
<P>若某方法带块则返回真,否则返回伪.</P>
<h5>load(file[, priv])
  <!-- RDLabel: "load" --> 
  
</h5>
<P>加载Ruby程序file并予以执行.若file是绝对路径,则从file开始加载.若file是相对路径,则依次搜索内部变量$:所指定的路径,并加载第一个搜索到的文件.此时,若$:中的元素是以"~"(tilde)开头的话,就把它扩展为环境变量HOME的值.</P>
<P>若可选参数priv的值为真,则在内部生成一个无名模块作为顶层来进行加载和运行,这便不会污染全局名字空间了.</P>
<P>若加载成功则返回true,若失败则引发LoadError异常.</P>
<P>[require与load之间的区别]</P>
<P>require对于相同的文件只会加载一次,而load则是无条件的加载.另外,require会自动补全扩展名,如.rb或.so等.而load则没有该功能.一般的典型用法是,使用require加载库,而使用load加载配置文件等.</P>
<pre class="code"># 用例
load "#{ENV['HOME']}/.myapprc"
load "/etc/myapprc"
</PRE>
<P>另外,如果想在特定目录中加载文件的话,写成 load 'filename' 就不恰当了.这时请务必使用绝对路径.</P>
local_variables
<!-- RDLabel: "local_variables" --> 

<P>返回当前作用域中已定义的局部变量名的数组.</P>
<P>另外,请参考global_variables, Object#instance_variables, Module.constants, Module#constants, Module#class_variables.</P>
loop { ... }
<!-- RDLabel: "loop" --> 

<P>(只要不被中断就)反复对块进行计算.</P>
<h5>open(file[, mode[, perm]])
  <!-- RDLabel: "open" --> 
  open(file[, mode[, perm]]) {|io| ... }
  <!-- RDLabel: "open" --> 
  
</h5>
<P>打开file并返回File对象.mode可以是下列字符串或者整数(File::Constants模块的常数的逻辑和).省略时默认为"r".</P>
<UL>
  <LI>"r", RDONLY: 以读取模式打开文件. 
  <LI>"w", WRONLY|CREAT|TRUNC: 以写入模式打开文件.打开文件时,若文件已存在就清空文件内容. 
  <LI>"a", WRONLY|CREAT|APPEND: 以写入模式打开文件.通常把写入内容添加到文件结尾. </LI>
</UL>
<P>若有"+"的话,就以读写两用模式(RDWR)打开文件.</P>
<UL>
  <LI>"r+": 将文件的读写位置设在开头. 
  <LI>"w+": 与"r+"一样.打开文件时,若文件已存在就清空其内容. 
  <LI>"a+": 与"r+"一样.打开文件时,若文件已存在,就把读写位置设在文件结尾. </LI>
</UL>
<P>可在上述任意一项后面添加"b"(如"r+b")标志(如果是整数就是File::BINARY).此时,将以二进制方式打开文件(只限于以文本/二进制方式来区分文件的系统).</P>
<P>第三参数perm与open(2)的第三参数是一样的，它以整数的形式说明了文件在CREAT时的访问权限。若第二参数不是数值形式的话，该参数将被忽略。它的默认值是0666。</P>
<P>若文件名以`|'开头时，其后的字符串会被当作命令来执行。另外，将生成管线(pipeline)来应对命令的标准输入输出。</P>
<P>若文件名为"|-"的话，open将生成Ruby的子进程，并返回与子进程之间的管道(pipe)(IO对象)。(此时的运作与IO.popen相同。File.open没有生成管线的功能)。</P>
<P><EM>注意</EM>: 与Perl不同的是，命令通常是以`|'开头的。</P>
<P>当open与块同时被调用时，open将打开文件并执行块，当块的运行终止后就关闭文件。此时返回块的计算结果。请看下例。</P>
<pre class="code">open(path, mode) do |f|
   ...
end

# 等效代码
f = open(path, mode)
begin
   ...
ensure
  f.close
end
</PRE>
<h5>p(obj, [obj2, ...])
  <!-- RDLabel: "p" --> 
  
</h5>
<P>以通俗易懂的方式输出obj。等同于以下代码。(请参考Object#inspect)</P>
<pre class="code">print obj.inspect, "\n", obj2.inspect, "\n", ...
</PRE>
<P>返回nil。</P>
<h5>print([arg1[, arg2, ...]])
  <!-- RDLabel: "print" --> 
  
</h5>
<P>依次输出参数。若没有得到参数则输出变量$_的值。若把非字符串对象传给参数的话，将对该对象使用to_s方法将其变为字符串后输出。若是nil的话则输出字符串"nil"。</P>
<P>若给变量$;(输出字段分隔符)指定了一个非nil的值的话，将在各个参数之间输出该分隔符。若给变量$\(输出记录分隔符)指定了一个非nil的值的话，将在最后输出它。</P>
<P>返回nil。</P>
<h5>printf([port, ]format[, arg[, ...]])
  <!-- RDLabel: "printf" --> 
  
</h5>
<P>类似于C语言的printf，它将按照format将参数格式化为字符串，然后输出到$&gt;。当第一参数是IO的子类的实例时，将对该对象进行输出。若没有任何参数时，将不作反应。</P>
<P>请参考sprintf格式来了解Ruby中format字符串的扩展问题。</P>
<P>返回nil。</P>
<h5>proc { ... }
  <!-- RDLabel: "proc" --> 
  lambda { ... }
  <!-- RDLabel: "lambda" --> 
  proc
  <!-- RDLabel: "proc" --> 
  lambda
  <!-- RDLabel: "lambda" --> 
  
</h5>
<P>在给出的块中生成过程对象(Proc的实例)并返回它(等同于Proc.new)。</P>
<P>若没有给出块的话，将返回主调(caller)方法所指的块。若主调方法没有块时，将引发ArgumentError异常。</P>
<h5>putc(ch)
  <!-- RDLabel: "putc" --> 
  
</h5>
<P>将字符ch输出到$&gt;。若ch是数字的话，将输出对应于0～255的字符。若ch是字符串的话，将输出字符串中的第一个字符。</P>
<P>返回ch。</P>
<pre class="code">putc("ch")
putc(?c)
putc(99)
# =&gt; ccc
</PRE>
<h5>puts([obj[, obj2[, ....]]] )
  <!-- RDLabel: "puts" --> 
</h5>
<P>依次将obj和换行符输出到$&gt;。若没有参数的话则只会输出换行符。</P>
<P>若参数是数组，则依次输出数组元素和换行符。若将既非数组又非字符串的对象传递给参数时，将尝试使用to_ary方法将其化为数组，再使用to_s方法将其化为字符串。若是nil则输出字符串"nil"。</P>
<P>若参数是以换行符结尾时，puts将不再输出换行符。</P>
<pre class="code">puts "foo", "bar\n", "baz"
puts ""    # 只输出换行
puts       # 只输出换行
puts "foo"
=&gt; foo
   bar
   baz


   foo
</PRE>
<P>返回nil。</P>
<P>另外，请参考print, warn。</P>
<h5>raise
  <!-- RDLabel: "raise" --> 
</h5>
<ul>
  <li>raise(exception)
    <!-- RDLabel: "raise" --> 
  </li>
  <li> raise(message)
    <!-- RDLabel: "raise" --> 
  </li>
  <li>raise(error_type, message [, backtrace])
    <!-- RDLabel: "raise" --> 
  </li>
  <li>fail(error_type, message [, backtrace])
    <!-- RDLabel: "fail" --> 
    
  </li>
</ul>
<P>引发异常。</P>
<P>若没有参数时，将再次引发本线程本块内最后被rescue的异常对象($!)。若没有这样的异常时，将引发RuntimeError异常。</P>
<pre class="code">begin
  open("nonexist")
rescue
  raise   # =&gt; `open': No such file or directory - "nonexist" (Errno::ENOENT)
end
</PRE>
<P>若只有一个参数，且该参数为字符串时，将以该字符串为message来引发RuntimeError异常。若该参数为异常类或异常对象时，将引发该异常。</P>
<pre class="code">raise "error message"    # =&gt; -:1: error message (RuntimeError)

raise ArgumentError      # =&gt; -:1: ArgumentError (ArgumentError)

raise ArgumentError.new  # =&gt; -:1: ArgumentError (ArgumentError)
</PRE>
<P>若有2或3个参数时，将以第二参数为message来引发第一参数所指的异常。此时是以异常类或异常对象来指定异常的。而第三参数则是发生异常时的栈跟踪(track trace)，它的形式必须与caller的返回值一致。</P>
<pre class="code">raise ArgumentError, "error message"
# =&gt; -:1: error message (ArgumentError)

raise ArgumentError, "error message", ["file1:99",
                                       "file2:999:in `method'"]

# =&gt; file1:99: error message (ArgumentError)
              from file2:999:in `method'
</PRE>
<P>若将非异常的类或对象赋予第一参数时，实际上发生的异常正是该对象的exception方法的返回值。</P>
<pre class="code">class MyException
  def exception
    ArgumentError.new
  end
end

raise MyException.new

# =&gt; -:7: ArgumentError (ArgumentError)
</PRE>
<P>若采用第二种形式来指定参数时，该参数将被赋予exception方法。</P>
<pre class="code">class MyException
  def exception(mesg)
    ArgumentError.new(mesg)
  end
end

raise MyException.new, "error message"

# =&gt; -:7: error message (ArgumentError)
</PRE>
<P>exception方法必定返回异常对象。否则将引发TypeError。</P>
<P>发生的异常会被存入变量$!中。而发生异常时的栈跟踪信息将被存入变量$@中。</P>
<h5>rand([max=0])
  <!-- RDLabel: "rand" --> 
  
</h5>
<P>产生一个0至max(不含)之间的随机数。若未调用srand的话，就自动调用它。</P>
<P>若将max设为nil或0的话，将返回一个0至1(不含)的实数型Float随机数。</P>
<h5>readlines([rs])
  <!-- RDLabel: "readlines" --> 
  
</h5>
<P>把从命令行参数那里得到的文件(若没有的话,就利用标准输入)假设成一个虚拟文件(ARGF)，再读入该文件的所有内容，然后以行为单位将这些内容转换为数组，最后返回该数组。</P>
<P>以rs所指的字符串为行的切分符。rs的默认值取自内部变量$/。</P>
<P>若将rs设为nil则意味着没有行切分符。若设定为空字符串""，则把连续换行当作行切分符(段落模式)。</P>
<h5>require(feature)
  <!-- RDLabel: "require" --> 
  
</h5>
<P>从加载路径$:开始搜索Ruby库feature，若该库尚未被加载就立即加载。</P>
<P>Ruby库就是指Ruby脚本(*.rb)或扩展库(*.so)，若feature的扩展名被省略时，则会同时搜索这两种文件(欲知具体的搜索顺序，请参考$:)。若给出扩展名时，则只会搜索这种文件。另外，扩展库的扩展名不仅限于常用的那些，还常常使用.so。</P>
<P>加载库后返回true。若该库已被加载则不会重复加载，此时返回false。若加载失败则引发LoadError异常。feature被加载后，它的名字(包括扩展名)会被追加到变量$"中。</P>
<h5>scan(re)
  <!-- RDLabel: "scan" --> 
  scan(re) {|matched| ... }
  <!-- RDLabel: "scan" --> 
  
</h5>
<P>与$_.scan一样。</P>
<h5>select(reads[, writes[, excepts[, timeout]]])
  <!-- RDLabel: "select" --> 
  
</h5>
<P>与IO.select一样。</P>
<h5>set_trace_func(trace_proc)
  <!-- RDLabel: "set_trace_func" --> 
  
</h5>
<P>在Ruby解释器执行程序的过程中，每当发生方法调用或对表达式进行计算等事件时都将执行trace_proc过程对象。、以及等标准附件就是使用该内部函数来实现的。</P>
<P>例:</P>
<pre class="code">set_trace_func lambda {|event, file, line, id, binding, klass|
    # ....
}
</PRE>
<P>块参数的意义如下。</P>
<h5>event
  <!-- RDLabel: "event" --> 
  
</h5>
<P>表示发生事件的类别。详细内容如下。</P>
  <UL>
    <LI>"line" ... 表达式的计算。 
    <LI>"call" ... 方法调用。 
    <LI>"return" ... 从方法调用中返回。 
    <LI>"c-call" ... C(语言)方法的调用。 
    <LI>"c-return" ... 从C(语言)方法调用中返回。 
    <LI>"class" ... 进入类定义、特殊类定义或模块定义中。 
    <LI>"end" ... 类定义、特殊类定义或模块定义的结束。 
    <LI>"raise" ... 发生异常。 </LI>
  </UL>
  <h5>file
    <!-- RDLabel: "file" --> 
  
  </h5>
  <P>运行中的程序的源文件名(字符串)。</P>
  <h5>line
    <!-- RDLabel: "line" --> 
  </h5>
  <P>运行中的程序的源文件行号(整数)。</P>
  <h5>id
    <!-- RDLabel: "id" --> 
  
  </h5>
  <P>根据event的不同，将使用下列之一。与第六个块参数klass相对应。</P>
  
    <h5>line
      <!-- RDLabel: "line" --> 
    
    </h5>
    <P>Symbol对象，它表示最后被调用的方法。在顶层中则为nil。</P>
    <h5>call/return/c-call/c-return  
      <!-- RDLabel: "call/return/c-call/c-return" --> 
    
    </h5>
    <P>Symbol对象，它表示被调用／return的方法。</P>
class/end  <!-- RDLabel: "class/end" --> 
    
  <P>nil。</P>
raise  <!-- RDLabel: "raise" --> 
    
  <P>Symbol对象，它表示最后被调用的方法。在顶层中则为nil。</P>
  
  <h5>binding
    <!-- RDLabel: "binding" --> 
  
  </h5>
  <P>Binding对象，它表示运行中的程序的状况(context)。</P>
  <h5>klass
    <!-- RDLabel: "klass" --> 
  
  </h5>
  <P>根据event的不同，将使用下列之一。与第四个块参数id相对应。</P>
  <h5>line
    <!-- RDLabel: "line" --> 
    
  </h5>
  <P>Class对象，它表示最后被调用的方法的所属类。在顶层中则为false。</P>
  <h5>call/return/c-call/c-return
    <!-- RDLabel: "call/return/c-call/c-return" --> 
  </h5>
  <P>Class对象，它表示被调用／return的方法的所属类。</P>
  class/end
  <!-- RDLabel: "class/end" --> 
    
  <P>false。</P>
  raise
  <!-- RDLabel: "raise" --> 
    
  <P>Class对象，它表示最后被调用的方法的所属类。在顶层中则为false。</P>
  <h5>sleep([sec])
    <!-- RDLabel: "sleep" --> 

  </h5>
  <P>使程序暂停sec秒。也可以将sec设为浮点数。省略sec时，若没有显式地(SIGALRM或其他线程发出的Thread#run)终止睡眠的话，将一直sleep下去。返回值是实际睡眠的秒数(整数)。</P>
  <h5>spawn(cmd, [arg, ...]) ((&lt;ruby 1.9 特性&gt;))
    <!-- RDLabel: "spawn" --> 

  </h5>
  <P>基本上等同于system，但它不会等待子进程的结束。返回生成的子进程的进程ID。</P>
  <h5>split([sep[, limit]])
    <!-- RDLabel: "split" --> 

  </h5>
  <P>使用sep模型将$_中的字符串分割成limit个部分后转化为数组，然后返回该数组。请参考String#split以获得更多的资讯。</P>
  <h5>sprintf(format ... )
    <!-- RDLabel: "sprintf" --> 
format(format ... )
<!-- RDLabel: "format" --> 

  </h5>
  <P>采用同C语言sprintf一样的方法对format字符串进行解释，格式化参数后返回结果。使用format时，就好像使用C语言sprintf一样。</P>
<P>Ruby对整数的大小没有上限，因此把负数指定给%b, %o, %x时(可看作左边有无数个1)，就会显示成..f。若想以“符号加绝对值”的形式进行输出的话，就得写成%+x、% x这样。</P>
<P>请参考sprintf格式化来获取更多资讯。</P>
<h5>srand([seed])
  <!-- RDLabel: "srand" --> 
  
</h5>
<P>设定rand的随机数的种子，返回旧的初始值(第一次返回0)。若省略初始值时，则以当前时刻、进程ID或srand的调用次数为基础生成一个种子。</P>
<h5>sub</h5>
<ul>
  <li>sub(pattern[, replace])
    <!-- RDLabel: "sub" --> 
  </li>
  <li>sub!(pattern[, replace])
    <!-- RDLabel: "sub!" --> 
  </li>
  <li>sub(pattern) {|matched| ... }
    <!-- RDLabel: "sub" --> 
  </li>
  <li>sub!(pattern) {|matched| ... }
    <!-- RDLabel: "sub!" --> 
    
  </li>
</ul>
<P>在内部变量$_所指的字符串中,将首个匹配pattern的部分替换为replace,然后返回结果.若省略参数replace时,该方法将变为迭代器,以块的计算值进行替换操作.将匹配的字符串以参数的形式传递给块.</P>
<P>sub!将改写$_所包含的字符串本身.请参考String#sub来获得更多资讯.String#sub和sub之间存在以下差异.</P>
<UL>
  <LI>sub方法会拷贝$_的值,然后对拷贝进行更新,最后再赋值给$_. </LI>
</UL>
<h5>syscall(num, arg ... )
  <!-- RDLabel: "syscall" --> 
  
</h5>
<P>执行num号码所对应的系统调用。将第二参数以后的部分传给系统调用作为其参数。参数必须是字符串或整数。</P>
<P>请参考syscall(2)或 /usr/include/sys/syscall.h 以了解数值与系统调用的对应关系。</P>
<P>Ruby遵从系统调用的习惯，若syscall(2)返回-1时，引发Errno::EXXX异常。若返回其他值则不作变动。</P>
<h5>system(command)
  <!-- RDLabel: "system" --> 
  system(program[, arg1[, arg2[, ...]]])
  <!-- RDLabel: "system" --> 
  
</h5>
<P>执行command，成功(子进程以 status 0 的状态结束时)则返回真，失败(包括不能执行命令)则返回伪。可参照变量$?来获取结束状态值(status)。</P>
<P>当不能执行命令时，大多数的shell会返回状态值127。(所以$?的值为0x7f00)若没有使用shell时，Ruby子进程以状态值127结束。通常，查看$?的值即可区分是不能执行命令还是命令失败。</P>
<P>ruby 1.9 特性:不能执行命令时会引发Errno::EXXX异常。若使用了shell，则同上所述。</P>
<P>请参考exec以获取更多资讯。</P>
<P>另外，请参考`command`,open。</P>
<h5>test(cmd, file1 [, file2])
  <!-- RDLabel: "test" --> 
  
</h5>
<P>进行文件测试。cmd可以是下列数值字面值或字符串(只把字符串的首字符当成命令)。</P>
<UL>
  <LI>带一个参数时 
  <UL>
  <LI>?r
    <P>可以使用有效 uid 读取文件</P>
  <LI>
  <P>?w</P>
  <P>可以使用有效 uid 写入文件</P>
  <LI>
  <P>?x</P>
  <P>可以使用有效 uid 执行文件</P>
  <LI>
  <P>?o</P>
  <P>文件的所有者是有效 uid </P>
  <LI>
  <P>?G</P>
  <P>文件的所有者group是有效 gid </P>
  <LI>
  <P>?R</P>
  <P>可以使用实 uid 读取文件</P>
  <LI>
  <P>?W</P>
  <P>可以使用实 uid 写入文件</P>
  <LI>
  <P>?X</P>
  <P>可以使用实 uid 执行文件</P>
  <LI>
  <P>?O</P>
  <P>文件的所有者是实 uid </P>
  <LI>
  <P>?e</P>
  <P>文件存在</P>
  <LI>
  <P>?z</P>
  <P>文件大小为 0 </P>
  <LI>
  <P>?s</P>
  <P>文件大小非 0 (返回文件大小)</P>
  <LI>
  <P>?f</P>
  <P>文件是无格式(plain)文件</P>
  <LI>
  <P>?d</P>
  <P>文件是目录</P>
  <LI>
  <P>?l</P>
  <P>文件是符号连接</P>
  <LI>
  <P>?p</P>
  <P>文件是带名的管道(FIFO)</P>
  <LI>
  <P>?S</P>
  <P>文件是socket</P>
  <LI>
  <P>?b</P>
  <P>文件是特殊块文件</P>
  <LI>
  <P>?c</P>
  <P>文件是特殊字符文件</P>
  <LI>
  <P>?u</P>
  <P>文件中有 setuid bit</P>
  <LI>
  <P>?g</P>
  <P>文件中有 setgid bit</P>
  <LI>
  <P>?k</P>
  <P>文件中有 sticky bit</P>
  <LI>
  <P>?M</P>
  <P>返回最近更新文件时刻</P>
  <LI>
  <P>?A</P>
  <P>返回最近访问文件时刻</P>
  <LI>
  <P>?C</P>
  <P>返回文件的 inode 变更时刻</P></LI></UL>
  <LI>带两个参数时 
  <UL>
  <LI>?=
    <P>文件1和文件2的最近更新时刻相同</P>
  <LI>
  <P>?&gt;</P>
  <P>文件1的最近更新时刻要比文件2的新</P>
  <LI>
  <P>?&lt;</P>
  <P>文件1的最近更新时刻要比文件2的旧</P>
  <LI>
  <P>?-</P>
  <P>文件2对文件1发出了硬连接指令</P></LI></UL></LI>
</UL>
<h5>throw(tag[, value=nil])
  <!-- RDLabel: "throw" --> 
  
</h5>
<P>跳到使用了相同的tag的catch块的终点(跳过方法)。若没有使用相同tag的catch的话，就以NameError结束线程。tag可以是字符串或符号。value将变为catch的返回值。</P>
<P>例:</P>
<pre class="code">ret = catch(:exit) {
   throw :exit, 25
   some_process()    # 决不会被执行
   10
}
p ret   #=&gt; 25
</PRE>
<h5>trace_var(varname, hook)
  <!-- RDLabel: "trace_var" --> 
</h5>
<h5>trace_var(varname) {|newval| .... }
  <!-- RDLabel: "trace_var" --> 
</h5>
<P>注册钩子以监视对全局变量varname所进行的赋值。varname可以是字符串或Symbol。</P>
<P>这里所说的“全局变量”是指以“$”开头的变量，包括特殊变量。</P>
<P>调用之后，只要varname所指的全局变量被赋值，就会计算字符串或Proc对象hook。若钩子是Proc对象的话，将把块参数中的值向外传递。另外，可注册多个钩子。</P>
<P>若想解除跟踪的话，可以把hook设为nil，还可以使用untrace_var。</P>
<P>例:</P>
<pre class="code">trace_var(:$v) {|val| puts "$v=#{val.inspect}" }
$v = "foo"   #=&gt; $v="foo"
$v = 1       #=&gt; $v=1
</PRE>
<P>若hook为nil，将返回hook的数组(若是以块注册的话，将以Proc对象返回)。除此之外，将返回nil。</P>
<h5>trap(signal, command)
  <!-- RDLabel: "trap" --> 
</h5>
<h5>trap(signal) { ... }
  <!-- RDLabel: "trap" --> 
</h5>
<P>※ 在Ruby 1.8 以后的版本中，推荐使用Signal.trap。</P>
<P>将command注册为signal所指的中断的处理程序。signal可以是信号名字符串、Symbol或信号编号。</P>
<P>command可以是字符串或块。若将其设为nil、空字符串""、"SIG_IGN"或者"IGNORE"时，将忽略该信号(若可能的话)。若将其设为"SIG_DFL"或"DEFAULT"时，将进行默认的动作。若设为"EXIT"时，在接到信号之后将进行结束时的相关处理，然后以status 0 的状态结束。</P>
<P>还可以将signal设为0或"EXIT"等特殊值。这表示“程序结束时”。</P>
<P>Ruby解释器会为一些特定的信号引发异常Interrupt或SignalException。还可以使用异常处理来捕捉这些信号。</P>
<pre class="code">begin
  Process.kill :QUIT, $$   # 对自己发出SIGQUIT
rescue SignalException
  puts "rescue #$!"
end
# =&gt; rescue SIGQUIT
</PRE>
<P>用trap()捕捉到的信号不会引发异常。</P>
<P>若注册了与信号相对应的command时，trap将返回它(若是块的话，将被当作Proc对象返回。若是"IGNORE"或"DEFAULT"则返回nil)。若没有注册的话则返回nil。</P>
<P>ruby 1.8 特性：在执行trap之前，若注册了"IGNORE"或"DEFAULT"的话，则返回"IGNORE"、"DEFAULT"。若注册了ruby解释器无法识别的信号处理程序时将返回nil。</P>
<pre class="code">p trap(:INT, "p true")     # =&gt; nil
p trap(:INT) { }           # =&gt; "p true"
p trap(:INT, "SIG_IGN")    # =&gt; #&lt;Proc:0x401b1328&gt;
p trap(:INT, "DEFAULT")    # =&gt; nil
p trap(:INT, "EXIT")       # =&gt; nil
p trap(:INT, nil)          # =&gt; "EXIT"
</PRE>
<P>若指定了并不存在的信号时，将引发ArgumentError异常。</P>
<h5>untrace_var(varname[, hook])
  <!-- RDLabel: "untrace_var" --> 
  
</h5>
<P>取消与全局变量varname有关的钩子。若指定了hook的话，将只会取消该钩子。若省略hook或将其设为nil时，将取消varname所有的钩子。返回取消钩子的数组。</P>
<P>例:</P>
<pre class="code">$v = nil
trace_var(:$v) {|val| puts "$v=#{val.inspect}" }
$v = 'str'        #=&gt; $v="str"
untrace_var :$v
$v = 'str'        # 不输出任何信息
</PRE>
<h5>warn(mesg)
  <!-- RDLabel: "warn" --> 
</h5>
<P>ruby 1.8 特性</P>
<P>依次输出mesg和换行符到$stderr之中。若内部变量$VERBOSE为nil时，则不会输出。这等同于</P>
<pre class="code">$stderr.print mesg, "\n" unless $VERBOSE.nil?
</PRE>
<P>返回nil。</P>
<div class="rpindex"><a href="81.html"> 下一页</a><a href="79.html"> 上一页</a><a href="index.html">首页</a></div>



<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
