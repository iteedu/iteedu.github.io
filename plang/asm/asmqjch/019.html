<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->



<div class="lpindex"><a href="index.html">首页</a><a href="018.html"> 上一页</a><a href="020.html"> 下一页</a></div>
<h1>第十九课 树型视图控件</h1>
本课中，我们将学习如何使用树型视图控件。另外还要学习如何在树型视图中完成拖-拉动作，以及如何使用图象列表。 
<H3>理论：</H3>
<p>树型视图是一种特别的窗口，我们可以使用它一目了然地表示某种层次关系。譬如象在资源管理器中左边窗口中的就是树型视图。您可以调用CreateWindowEx来创建树型视图，传递一个类名“"SysTreeView32"”，或者您也可以把它放到一个对话框中去。不要忘了在您的代码中加入InitCommonControls函数。</p>
<p>树型视图有几种特有的风格。下面是几种经常使用的。 
  TVS_HASBUTTONS == 
  在父项目中显示（+）或（-）。用户可以通过点击该符号来展开或收起该父项目下的子项目。如果想在根目录下也有这个符号必须指定TVS_LINESATROOT风格。</p>
<p> TVS_HASLINES 
  == 在层次中用线条来连接各个项目名称。 </p>
<p> TVS_LINESATROOT == 
  在根目录下的项目也用线连接。如果没有指定TVS_HASLINES风格，该风格也就会被忽略。 
  像其它的通用控件一样，树型视图用消息来完成通信。父窗口发送一系列的消息给树型视图，而树型视图发送"notification"消息给它的父窗口。在这方面，树型视图和其它的通用控制没什么两样</p>
<p>  当有事件发生时，树型视图发送一个WM_NOTIFY消息个父窗口，并在消息中附带传递一些附加信息。  </p>
<p>WM_NOTIFY <BR>
  wParam 
  ==控件的ID。因为该值不是唯一的，故我们不用它。我们使用NMHDR结构体中的hwndFrom或IDFrom成员变量。<br /> 
  lParam 
  == 
  指向NMHDR结构体的指针。有一些控件可能传递一个指向更大一点的结构体的指针。但该结构体必须保证它的第一个成员变量是一个NMHDR型的变量。这样，您在处理lParam变量时，至少可以得到一个NMHDR型的变量。  </p>
<p>下面我们来看NMHDR：  </p>
<pre class="code">       NMHDR  STRUCT    DWORD
              HWNDFROM  DWORD     ?
               IDFROM  DWORD     ?
                 CODE  DWORD     ?
       NMHDR  ENDS</pre>
<p>hwndFrom是发送WM_NOTIFY消息的控件的窗口句柄。<BR>
  idFrom是发送WM_NOTIFY消息的控件的ID。 <BR>
  code是控件发送给父窗口的数据。<BR>
  树型视图发送给父窗口的通知消息以TVN_打头。 
  树型视图接收到的消息以TVM_打头，譬如：TVM_CREATEDRAGIMAGE。 
  树型视图发送TVN_XXX消息时在code变量中放入NMHDR型变量。父窗口发送TVM_消息来控制树型视图。 </p>
<H4>在树型视图中加入项目</H4>
<p>在创建完树型视图后可以通过发送TVM_INSERTITEM消息往其中加入项目了。</p>
<pre class="code">TVM_INSERTITEM 
      WPARAM  =         0           ;
      LPARAM  =         指向结构体TV_INSERTSTRUCT的指针     ;</pre>
<P>您应当知道一些关于树型视图中的项目之间关系的一些术语。 
  一个项目可能是一个父亲、儿子或两者都是。父项目下含有子项目，而该父项目又有可能是其它项目的子项目。一个没有父项目的项目叫根项目。在树型视图中可能有多个根项目。现在我们来看看TV_INSERTSTRUCT结构体：</P>
  <pre class="code">         TV_INSERTSTRUCT  STRUCT    DWORD
                          HPARENT  DWORD     ?
                          HINSERTAFTER  DWORD     ?
                          ITEMTYPE <>
         TV_INSERTSTRUCT  ENDS</pre>
  <p>hParent = 
    父项目的句柄。如果该值为TVI_ROOT value或NULL，该项目插在树型视图的根部。<BR>
    hInsertAfter = 
    应该插入在起后面的项目的句柄或下面的值： </p>
  <LI>TVI_FIRST ==&gt; 插在列表的头部。 
  <LI>TVI_LAST ==&gt; 插在列表的尾部。 
  <LI>TVI_SORT ==&gt; 按字母顺序插入。 </LI>
  <pre class="code">ITEMTYPE UNION 
         itemex TVITEMEX <>
         item TVITEM <>
ITEMTYPE  ENDS</pre>
  <p>我们仅使用TVITEM。</p>
  <pre class="code">     TV_ITEM  STRUCT    DWORD
       IMASK  DWORD     ?
       HITEM  DWORD     ?
       STATE  DWORD     ?
   STATEMASK  DWORD     ?
     PSZTEXT  DWORD     ?
  CCHTEXTMAX  DWORD     ?
      IIMAGE  DWORD     ?
          ISELECTEDIMAGE  DWORD     ?
   CCHILDREN  DWORD     ?
      LPARAM  DWORD     ?
     TV_ITEM  ENDS</pre>
<P>该结构体根据消息类型，用来发送或接收关于一个树型视图的项目的有关信息。譬如：对于消息TVM_INSERTITEM，它用来指定插入树型视图控件的项目的属性。而对于消息TVM_GETITEM，该结构体用来填充关于选定项目的信息。</P>
  <P>imask 
    用来指定TV_ITEM的那些成员变量有效。譬如，如果指定了TVIF_TEXT，这意味着pszText成员变量是有效的。您可以同时指定几个标志位。<BR>
    hItem 
    是树型视图项目的句柄。每一个项目都有它自己的句柄，就像窗口一样。如果您想要操作一个项目，就必须选择它的句柄。<BR>
    pszText 
    是一个字符串指针。它是项目的标签名。<BR>
    cchTextMax仅在查询项目的名称时使用。由于在pszText中指定了指针，WINDOWS还要知道该缓冲去的大小。所以您必须给出该值。<BR>
    iImage 
    和 
    iSelectedImage用来指定图象列表以及一个索引号。这样就知道当项目被选中或没被选中时用哪个图象来表示该项目。像资源管理器中左边窗口中的文件夹等小图表就是有这两个参数来决定的。 </P>
  <P> 为了在树型视图中插入一个项目，您必须至少设定hParent, hInsertAfter，另外您还要设定imask和pszText值。 </P>
  <H4>把图形加到图形视图中</H4>
  <p>如果您想要在项目的名称左边显示图标的话，您必须创建一个图形列表，并且把它和树形视图相关联起来。您可以调用ImageList_Create来创建一个图形列表。</p>
  <pre class="code">ImageList_Create PROTO cx:DWORD, cy:DWORD, flags:DWORD, cInitial:DWORD,  cGrow:DWORD </pre>
  <P>如果创建成功的话，该函数返回一个空的图象列表的句柄。<BR>cx == 以像素为单位的图象的宽度。<BR>cy == 
以像素为单位的图象的高度。图象列表中的每一幅的高度都必须相同。否则WINDOWS会对您的图象进行裁剪，如果过大的话就可能裁剪成几小块。所以您必须指定相同大小的图象。<BR>flags 
== 指定图象列表的图象的颜色深度。详细情况请参考WIN32 API 指南。<BR>cInitial == 
指定包含的图象的数目。WINDWOS将依此来分配合适的内存。<BR>cGrow == 在增加新图象是一次增加的数目。</P>
<P>图象列表不是窗口。仅仅是保存在那给其它的窗口使用的一种资源。 在图象列表产生后，您可以调用ImageList_Add来向其中加入图象。 </P>
<pre class="code">ImageList_Add PROTO himl:DWORD, hbmImage:DWORD, hbmMask:DWORD</pre>
<p>如果该函数调用失败的话，返回-1。<BR>
  himl == 
  图象列表的句柄。它是调用ImageList_Create时返回的值。<BR>
  hbmImage == 
  加入图象列表的位图的句柄。您通常把位图保存在资源中，然后调用LoadBitmap来把它加载进来。 
  注意您没有必要指定该位图中包含的图象的数目。WINDOWS会根据它的大小，自动计算。<BR>
  hbmMask == 
  掩码位图的句柄。如果没有使用掩码位图，可以忽略该值。 
  通常我们加入两种图象到图象列表中。一种时被选中时显示的图象，另一种时没被选中时显示的。<BR>
  当图象列表准备就绪后，您可以发送消息TVM_SETIMAGELIST给树型视图来让图象列表和树型视图联系起来。</p>
<p> TVM_SETIMAGELIST <BR>
  wParam = 图象列表的状态，一共有两种： </p>
<LI>TVSIL_NORMAL 包含被选中和没有被选中两种状态的图象。 
<LI>TVSIL_STATE 包含了用户自定义的状态的图象。 </LI>lParam = 图象列表的句柄。 
<H4>检索树型视图的信息</H4>您可以通过发送消息TVM_GETITEM来检索图形视图的信息。 

  <P>TVM_GETITEM <BR>wParam = 0 <BR>lParam 
  =指向结构体TV_ITEM的指针。该结构体将用来得到相关的信息。</P>
  <P>在发送该消息前必须设置成员变量imask的值，以便WINDOWS能告诉相关的信息。当然，最重要的是，您必须传递您想得到信息的项目的句柄。这就引起了一个问题，您如何得到项目的句柄？要保存所有项目的句柄吗？</P>
  <P>答案是很简单的：没有必要。您可以发送消息TVM_GETNEXTITEM到树型视图以检索您想要得到其属性的项目的句柄。譬如：您可以查询第一个子项目的句柄、根目录的句柄、选中的项目的句柄等等。</P>
  TVM_GETNEXTITEM <BR>wParam = 标志<BR>lParam = 
  树型视图的句柄（仅仅当wParam的值是某些标志位时才是必须的）。 wParam中的值非常重要， 我解释如下： 

  
    <LI>TVGN_CARET 选中的项目 
    <LI>TVGN_CHILD hitem参数指定项目的第一个子项目 
    <LI>TVGN_DROPHILITE 拖-拉操作的目的项目 
    <LI>TVGN_FIRSTVISIBLE 第一个可见项目 
    <LI>TVGN_NEXT 下一个同级项目 
    <LI>TVGN_NEXTVISIBLE 下一个可见项目，指定的项目必须可见。发送消息TVM_GETITEMRECT 来决定项目是否可见 
    <LI>TVGN_PARENT 指定项目的父项目 
    <LI>TVGN_PREVIOUS 前一个同级项目 
    <LI>TVGN_PREVIOUSVISIBLE 前一个可见项目，指定的项目必须可见。发送消息TVM_GETITEMRECT 
    来决定项目是否可见 
    <LI>TVGN_ROOT 根项目 
</LI>由此您可以通过发送该消息来得到项目的句柄，然后在发送消息TVM_GETITEM时在结构体变量TV_ITEM的成员变量hItem中放入该项目的句柄就可以得到关于该项目的有关信息了。 

<H4>在树型视图中进行拖-拉操作</H4>也就是因为这一部分我才决定写这课教程。当我按照InPrise公司的WIN32帮助来运行例子时，发现它的帮助中缺少真正重要的信息。我只有通过自己做实验，最后总算弄明白来个中来由。希望您不要和我一样再去走这些弯路，下面我把我所知的在树型视图中进行拖-拉操作的步骤描述如下： 

<OL>
  <LI>当用户要拖动一个项目时，树型视图控件会给它的父窗口发送TVN_BEGINDRAG通知消息。您可以在此处创建表示项目处在拖动操作中的图象，这可以通过发送TVM_CREATEDRAGIMAGE消息给树型视图，让其为目前使用的图象产生一副缺省的图象来实现。树型视图控件将创建一个图象列表，其中仅包含一副在拖动中显示的图象，图象列表创建后，您可以得到它的句柄。 

  <LI>在拖拉的图象生成后，您可以通过调用ImageList_BeginDrag来指定拖动图象的热点位置。
    <pre class="code"> ImageList_BeginDrag PROTO himlTrack:DWORD,  iTrack:DWORD , dxHotspot:DWORD, dyHotspot:DWORD </pre>
   
    himlTrack 是包含了拖拉时显示的图象的图象列表的句柄 
    <BR>
    iTrack 是选中的图象在图象列表中的索引号。<BR>
    dxHotspot 
    因为在拖动中该图象被用来取代光标，所以我们必须指定图象中的哪一点是光标的左上角的位置。dxHotspot是水平相对位置。 
    <BR>
    dyHotspot 
    是垂直相对位置。<BR>
    iTrack等于0。如果您要想光标的热点在拖拉中显示的图象的左上角，把dxHotspot和dyHotspot都设成0。 
  <LI>当拖拉的图象要显示时，我们调用ImageList_DragEnter 在树型视图中显示该图象。<br /> 
    <pre class="code">ImageList_DragEnter PROTO hwndLock:DWORD, x:DWORD, y:DWORD </pre>
   
    hwndLock 是进行拖拉中的窗口的句柄，拖拉的动作限制在该窗口中。<BR>
    x 和 
    y是在拖拉时显示图象的初始位置的坐标值。这些值是相对于窗口的左上角而不是客户区的左上角。 
  
  <LI>既然可以显示拖动中的图象了，我们就要处理拖动操作了。在这里有一个小问题。我们监视拖动是通过监视鼠标光标的移动来实现的，譬如在移动时我们通过捕获WM_MOUSEMOVE消息来得到移动中的坐标位置，通过捕获WM_LBUTTONUP消息来获知用户的放下操作。但这时如果鼠标光标移过子窗口时父窗口就无法再得到鼠标光标的移动以及鼠标的按键消息了。解决办法是调用SetCapture函数了锁定鼠标事件，这样无论鼠标移到那里和有什么动作，我们的窗口都可以知道了。 

  <LI>在处理WM_MOUSEMOVE消息时，您可以调用ImageList_DragMove来更新图象移动的轨迹。 
  该函数可以移动拖放操作中的图象位置。另外，如果您想让移动中的图象经过某些项目时高量度显示，可以调用TVM_HITTEST 
  来确定是否经过某个项目的上面。如果是的话，您可以发送TVM_SELECTITEM消息并设置 
  TVGN_DROPHILITE标志位使得那个项目高亮度显示。注意：在发送消息TVM_SELECTITEM前，您必须先隐藏图象列表，否则会留下非常难看的轨迹。要隐藏拖动中的图象可以调用ImageList_DragShowNolock，在显示完高亮度的图象后再调用该函数以让拖动中的图象再正常显示。 

  <LI>当用户释放主键后，您必须做几件事。 
  如果您在高亮度显示的时候释放鼠标主键（表示您想把该项目加到此处），您必须使该项目变成正常地显示，这可以通过发送消息TVM_SELECTITEM消息并设置标志位TVGN_DROPHILITE来实现，只是这时lParam必须为0。如果您不让高亮度显示的项目恢复正常，那就会发生一个奇怪的现象：当您再选择另外的项目时，那个项目的图象会包含在一个正方形中，当时高亮度显示的项目依旧是上一个项目。接下来必须调用ImageList_EndDrag和ImageList_DragLeave。还有调用ReleaseCapture来释放捕获的鼠标。如果您创建了一个图象列表，那还要调用calling 
  ImageList来将它销毁，在拖放操作结束后您可以进行另外其它的操作。 </LI></OL>
<H3>例子代码：</H3>
<Pre class="code">.386
.MODEL        FLAT,STDCALL
option casemap:none 
     INCLUDE  \MASM32\INCLUDE\WINDOWS.INC
     INCLUDE  \MASM32\INCLUDE\USER32.INC
     INCLUDE  \MASM32\INCLUDE\KERNEL32.INC
     INCLUDE  \MASM32\INCLUDE\COMCTL32.INC
     INCLUDE  \MASM32\INCLUDE\GDI32.INC
  INCLUDELIB  \MASM32\LIB\GDI32.LIB
  INCLUDELIB  \MASM32\LIB\COMCTL32.LIB
  INCLUDELIB  \MASM32\LIB\USER32.LIB
  INCLUDELIB  \MASM32\LIB\KERNEL32.LIB WINMAIN PROTO :DWORD,:DWORD,:DWORD,:DWORD
.CONST
    IDB_TREE  EQU       4006        ; ID of the bitmap resource
.DATA
   CLASSNAME  DB        "TREEVIEWWINCLASS",0
     APPNAME  DB        "TREE VIEW DEMO",0
           TREEVIEWCLASS  DB        "SYSTREEVIEW32",0
      PARENT  DB        "PARENT ITEM",0
      CHILD1  DB        "CHILD1",0
      CHILD2  DB        "CHILD2",0
    DRAGMODE  DD        FALSE       ; a flag to determine if we are in drag mode

.DATA?
hInstance HINSTANCE ? 
            HWNDTREEVIEW  DD        ?           ; handle of the tree view control
     HPARENT  DD        ?           ; handle of the root tree view item
  HIMAGELIST  DD        ?           ; handle of the image list used in the tree view control
          HDRAGIMAGELIST  DD        ?           ; handle of the image list used to store the drag image

.CODE
      START:
              INVOKE    GETMODULEHANDLE, NULL
              MOV       HINSTANCE,EAX
              INVOKE    WINMAIN, HINSTANCE,NULL,NULL, SW_SHOWDEFAULT
              INVOKE    EXITPROCESS,EAX
              INVOKE    INITCOMMONCONTROLS

     WINMAIN  PROC      HINST:HINSTANCE,HPREVINST:HINSTANCE,CMDLINE:LPSTR,CMDSHOW:DWORD
              LOCAL     WC:WNDCLASSEX
              LOCAL     MSG:MSG
              LOCAL     HWND:HWND
              MOV       WC.CBSIZE,SIZEOF WNDCLASSEX
              MOV       WC.STYLE, CS_HREDRAW OR CS_VREDRAW
              MOV       WC.LPFNWNDPROC, OFFSET WNDPROC
              MOV       WC.CBCLSEXTRA,NULL
              MOV       WC.CBWNDEXTRA,NULL
              PUSH      HINST
              POP       WC.HINSTANCE
              MOV       WC.HBRBACKGROUND,COLOR_APPWORKSPACE
              MOV       WC.LPSZMENUNAME,NULL
              MOV       WC.LPSZCLASSNAME,OFFSET CLASSNAME
              INVOKE    LOADICON,NULL,IDI_APPLICATION
              MOV       WC.HICON,EAX
              MOV       WC.HICONSM,EAX
              INVOKE    LOADCURSOR,NULL,IDC_ARROW
              MOV       WC.HCURSOR,EAX
              INVOKE    REGISTERCLASSEX, ADDR WC
              INVOKE    CREATEWINDOWEX,WS_EX_CLIENTEDGE,ADDR CLASSNAME,ADDR APPNAME,\ WS_OVERLAPPED+WS_CAPTION+WS_SYSMENU+WS_MINIMIZEBOX+WS_MAXIMIZEBOX+WS_VISIBLE,CW_USEDEFAULT,\
CW_USEDEFAULT,200,400,NULL,NULL,\ 
hInst,NULL 
              MOV       HWND,EAX
.WHILE        TRUE
              INVOKE    GETMESSAGE, ADDR MSG,NULL,0,0
.BREAK        .IF (!EAX)
              INVOKE    TRANSLATEMESSAGE, ADDR MSG
              INVOKE    DISPATCHMESSAGE, ADDR MSG
.ENDW
              MOV       EAX,MSG.WPARAM
              RET
     WINMAIN  ENDP

     WNDPROC  PROC      USES EDI HWND:HWND, UMSG:UINT, WPARAM:WPARAM, LPARAM:LPARAM
              LOCAL     TVINSERT:TV_INSERTSTRUCT
              LOCAL     HBITMAP:DWORD
              LOCAL     TVHIT:TV_HITTESTINFO
.IF           UMSG==WM_CREATE
              INVOKE    CREATEWINDOWEX,NULL,ADDR TREEVIEWCLASS,NULL,\
                        WS_CHILD+WS_VISIBLE+TVS_HASLINES+TVS_HASBUTTONS+TVS_LINESATROOT,0,\
                        0,200,400,hWnd,NULL,\
                        hInstance,NULL ; Create the tree view control
              MOV       HWNDTREEVIEW,EAX
              INVOKE    IMAGELIST_CREATE,16,16,ILC_COLOR16,2,10         ; create the associated image list
              MOV       HIMAGELIST,EAX
              INVOKE    LOADBITMAP,HINSTANCE,IDB_TREE       ; load the bitmap from the resource
              MOV       HBITMAP,EAX
              INVOKE    IMAGELIST_ADD,HIMAGELIST,HBITMAP,NULL           ; Add the bitmap into the image list
              INVOKE    DELETEOBJECT,HBITMAP    ; always delete the bitmap resource
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_SETIMAGELIST,0,HIMAGELIST
              MOV       TVINSERT.HPARENT,NULL
              MOV       TVINSERT.HINSERTAFTER,TVI_ROOT
              MOV       TVINSERT.ITEM.IMASK,TVIF_TEXT+TVIF_IMAGE+TVIF_SELECTEDIMAGE
              MOV       TVINSERT.ITEM.PSZTEXT,OFFSET PARENT
              MOV       TVINSERT.ITEM.IIMAGE,0
              MOV       TVINSERT.ITEM.ISELECTEDIMAGE,1
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_INSERTITEM,0,ADDR TVINSERT
              MOV       HPARENT,EAX
              MOV       TVINSERT.HPARENT,EAX
              MOV       TVINSERT.HINSERTAFTER,TVI_LAST
              MOV       TVINSERT.ITEM.PSZTEXT,OFFSET CHILD1
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_INSERTITEM,0,ADDR TVINSERT
              MOV       TVINSERT.ITEM.PSZTEXT,OFFSET CHILD2
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_INSERTITEM,0,ADDR TVINSERT
.ELSEIF       UMSG==WM_MOUSEMOVE
.IF           DRAGMODE==TRUE
              MOV       EAX,LPARAM
              AND       EAX,0FFFFH
              MOV       ECX,LPARAM
              SHR       ECX,16
              MOV       TVHIT.PT.X,EAX
              MOV       TVHIT.PT.Y,ECX
              INVOKE    IMAGELIST_DRAGMOVE,EAX,ECX
              INVOKE    IMAGELIST_DRAGSHOWNOLOCK,FALSE
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_HITTEST,NULL,ADDR TVHIT
.IF           EAX!=NULL
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_SELECTITEM,TVGN_DROPHILITE,EAX
.ENDIF
              INVOKE    IMAGELIST_DRAGSHOWNOLOCK,TRUE
.ENDIF
.ELSEIF       UMSG==WM_LBUTTONUP
.IF           DRAGMODE==TRUE
              INVOKE    IMAGELIST_DRAGLEAVE,HWNDTREEVIEW
              INVOKE    IMAGELIST_ENDDRAG
              INVOKE    IMAGELIST_DESTROY,HDRAGIMAGELIST
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_GETNEXTITEM,TVGN_DROPHILITE,0
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_SELECTITEM,TVGN_CARET,EAX
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_SELECTITEM,TVGN_DROPHILITE,0
              INVOKE    RELEASECAPTURE
              MOV       DRAGMODE,FALSE
.ENDIF
.ELSEIF       UMSG==WM_NOTIFY
              MOV       EDI,LPARAM
              ASSUME    EDI:PTR NM_TREEVIEW
.IF           [EDI].HDR.CODE==TVN_BEGINDRAG
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_CREATEDRAGIMAGE,0,[EDI].ITEMNEW.HITEM
              MOV       HDRAGIMAGELIST,EAX
              INVOKE    IMAGELIST_BEGINDRAG,HDRAGIMAGELIST,0,0,0
              INVOKE    IMAGELIST_DRAGENTER,HWNDTREEVIEW,[EDI].PTDRAG.X,[EDI].PTDRAG.Y
              INVOKE    SETCAPTURE,HWND
              MOV       DRAGMODE,TRUE
.ENDIF
              ASSUME    EDI:NOTHING
.ELSEIF       UMSG==WM_DESTROY
              INVOKE    POSTQUITMESSAGE,NULL
.ELSE
              INVOKE    DEFWINDOWPROC,HWND,UMSG,WPARAM,LPARAM
              RET
.ENDIF
              XOR       EAX,EAX
              RET
     WNDPROC  ENDP
              END       START</Pre>

<H3>分析：</H3>
<p>在处理消息WM_CREATE的代码中，您可以创建树型视图控件。  </p>
<pre class="code">              INVOKE    CREATEWINDOWEX,NULL,ADDR TREEVIEWCLASS,NULL,\
                        WS_CHILD+WS_VISIBLE+TVS_HASLINES+TVS_HASBUTTONS+TVS_LINESATROOT,0,\
                        0,200,400,hWnd,NULL,\
                        hInstance,NULL</pre>
<p>注意： TVS_xxxx 是树型视图所特有的风格。</p>
<pre class="code">              INVOKE    IMAGELIST_CREATE,16,16,ILC_COLOR16,2,10
              MOV       HIMAGELIST,EAX
              INVOKE    LOADBITMAP,HINSTANCE,IDB_TREE
              MOV       HBITMAP,EAX
              INVOKE    IMAGELIST_ADD,HIMAGELIST,HBITMAP,NULL
              INVOKE    DELETEOBJECT,HBITMAP
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_SETIMAGELIST,0,HIMAGELIST</pre>
<p>接下来，您可以创建一个空的图像列表，该图像列表容纳的是以像素为单位16x16大小和16位深度的图像，该图像列表初始包含两幅图像，最大可以容纳10幅。然后我们从资源中加载图像，并把它们放到图像列表中去。随后我们删除掉图像的句柄，因为我们不需要再用到它。设置好图像列表后，我们通过发送消息TVM_SETIMAGELIST把它和树型视图控件联系起来。</p>
<pre class="code">              MOV       TVINSERT.HPARENT,NULL
              MOV       TVINSERT.HINSERTAFTER,TVI_ROOT
              MOV       TVINSERT.U.ITEM.IMASK,TVIF_TEXT+TVIF_IMAGE+TVIF_SELECTEDIMAGE
              MOV       TVINSERT.U.ITEM.PSZTEXT,OFFSET PARENT
              MOV       TVINSERT.U.ITEM.IIMAGE,0
              MOV       TVINSERT.U.ITEM.ISELECTEDIMAGE,1
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_INSERTITEM,0,ADDR TVINSERT</pre>
<p>现在把项目插入到树型视图控件中去，首先我们从根项目开始。因为是根项目，所以成员变量hParent是NULL，hInsertAfter是TVI_ROOT。imask指定TV_ITEM结构体变量中的pszText，iImage和iSelectedImage三个成员变量的值是有效的。我们应该给这三个成员变量赋上正确的值。其中pszText显示项目的名称，iImage是图像列表中图像的索引号，该图像显示在未选中的项目名称的左边，iSelectedImage是选中的项目的图像索引号。设置好了这些值后，我们发送TVM_INSERTITEM消息给树型视图控件来把根项目加入到树型视图控件中去。  </p>
<pre class="code">              MOV       HPARENT,EAX
              MOV       TVINSERT.HPARENT,EAX
              MOV       TVINSERT.HINSERTAFTER,TVI_LAST
              MOV       TVINSERT.U.ITEM.PSZTEXT,OFFSET CHILD1
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_INSERTITEM,0,ADDR TVINSERT
              MOV       TVINSERT.U.ITEM.PSZTEXT,OFFSET CHILD2
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_INSERTITEM,0,ADDR TVINSERT</pre>
<p>加入完根项目后，我们再加入子项目。这时的成员变量hParent是其父项目的句柄，hInsertAfter的值是TVI_LAST。至于选中和非选中时用的图像是一样的，所以我们无需更改其它变量的值。</p>
<pre class="code">.ELSEIF       UMSG==WM_NOTIFY
              MOV       EDI,LPARAM
              ASSUME    EDI:PTR NM_TREEVIEW
.IF           [EDI].HDR.CODE==TVN_BEGINDRAG
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_CREATEDRAGIMAGE,0,[EDI].ITEMNEW.HITEM
              MOV       HDRAGIMAGELIST,EAX
              INVOKE    IMAGELIST_BEGINDRAG,HDRAGIMAGELIST,0,0,0
              INVOKE    IMAGELIST_DRAGENTER,HWNDTREEVIEW,[EDI].PTDRAG.X,[EDI].PTDRAG.Y
              INVOKE    SETCAPTURE,HWND
              MOV       DRAGMODE,TRUE
.ENDIF
              ASSUME    EDI:NOTHING</pre>
<p>当用户拖动项目时，树型视图控件将发送WM_NOTIFY消息给它的父窗口，子消息号是TVN_BEGINDRAG。在lPAram中是指向结构体NM_TREEVIEW 
  的指针，该结构体包含了一些附加信息。我们把lParam的值放到edi寄存器中，这样就可以把edi作为一个指针来使用。“assume edi:ptr 
  NM_TREEVIEW ”语句用来告诉编译器MASM把edi作为指向NM_TREEVIEW 
  的结构体的变量使用。我们通过发送消息TVM_CREATEDRAGIMAGE来创建一个拖动的图像。它将返回一个新创建的图像列表的句柄，该图像列表中包含拖动中的图像。我们调用ImageList_BeginDrag函数设置拖动图像的热点。调用ImageList_DragEnter函数进入操作。该函数会在特定位置显示拖动中的图像。起初显示的位置我们设在结构体NM_TREEVIEW中的成员变量ptDrag所指的位置。我们锁定鼠标的输入，并设置标志变量，表示我们进入了拖拉操作。  </p>
<pre class="code">.ELSEIF       UMSG==WM_MOUSEMOVE
.IF           DRAGMODE==TRUE
              MOV       EAX,LPARAM
              AND       EAX,0FFFFH
              MOV       ECX,LPARAM
              SHR       ECX,16
              MOV       TVHIT.PT.X,EAX
              MOV       TVHIT.PT.Y,ECX
              INVOKE    IMAGELIST_DRAGMOVE,EAX,ECX
              INVOKE    IMAGELIST_DRAGSHOWNOLOCK,FALSE
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_HITTEST,NULL,ADDR TVHIT
.IF           EAX!=NULL
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_SELECTITEM,TVGN_DROPHILITE,EAX
.ENDIF
              INVOKE    IMAGELIST_DRAGSHOWNOLOCK,TRUE
.ENDIF</pre>
<p>现在我们来看看WM_MOUSEMOVE消息的处理过程。当用户拖动图像时，我们的父窗口将接收到WM_MOUSEMOVE。为了响应这些消息，我们调用ImageList_DragMove来更新更新图像的位置。然后我们发送消息TVM_HITTEST给列表视图控件看看拖拉中的图像是否正好经过某些项目的上面，当然还要附带传递坐标位置等信息。如果经过的话，我们发送消息TVM_SELECTITEM并附带TVGN_DROPHILITE标志给树型视图控件，后者将会高亮度显示正被经过的项目。在高亮度显示的过程中，我们隐藏掉拖动中的图像免得显示的图像难看。  </p>
<pre class="code">.ELSEIF       UMSG==WM_LBUTTONUP
.IF           DRAGMODE==TRUE
              INVOKE    IMAGELIST_DRAGLEAVE,HWNDTREEVIEW
              INVOKE    IMAGELIST_ENDDRAG
              INVOKE    IMAGELIST_DESTROY,HDRAGIMAGELIST
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_GETNEXTITEM,TVGN_DROPHILITE,0
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_SELECTITEM,TVGN_CARET,EAX
              INVOKE    SENDMESSAGE,HWNDTREEVIEW,TVM_SELECTITEM,TVGN_DROPHILITE,0
              INVOKE    RELEASECAPTURE
              MOV       DRAGMODE,FALSE
.ENDIF</pre>
<p>当用户释放鼠标左键后，拖拉操作就可以结束了。我们调用ImageList_DragLeave，ImageList_EndDrag和ImageList_Destroy来结束拖拉操作模式。为了使得树形视图控件好看，我们检查最后高亮度显示的项目，并且选中它。我们还必须使得其不高亮度显示，否则其它的项目被选中时就不能高亮度显示了。最后我们释放对鼠标输入事件的捕获。</p>
<div class="rpindex"><a href="020.html"> 下一页</a><a href="018.html"> 上一页</a><a href="index.html">首页</a></div>



<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
