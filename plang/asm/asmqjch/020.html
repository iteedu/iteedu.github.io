<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->



<div class="lpindex"><a href="index.html">首页</a><a href="019.html"> 上一页</a><a href="021.html"> 下一页</a></div>
<h1>第二十课 窗口子类化</h1>
<p>在这一讲，我们将学习什么是窗口子类化和怎样按你所想要的方式方便地使用它。</p>
<h2> 理论：</h2>
<p> 如果你曾经在 Windows 环境下编过程序，有时候就会发现：有一个现成的窗口，几乎有你所需要的全部功能，但还不完全一样（否则就没有必要讲这一节了）。你曾遇到过这样的处境吗，如果你需要一个具有过滤特殊字符功能的 
  Edit 控件。当然最直接的方法就是自己用代码来实现，但这的确是一个费时又很困难的任务，而窗口子类化就可以用来做这种事情。 </p>
<p>窗口子类化允许你接管被子类化的窗口，使你对它有绝对的控制权。举个例子了来阐明一下：例如你需要一个只接受十六进制数字输入的文本编辑框，如果使用一个简单的 
  Edit控件，当用户输入十六进制以外的字符时，你既不知道也无计可施。也就是说，当用户进文本框中输入字符串 "zb+q*" 时，如果除了拒绝接受整个字符串以外几乎什么也不能做，至少这显得特别不专业。重要的是，你需要具有输入检测的能力，即每当用户输入一个字符到编辑框中时要能检测这个字符。</p>
<p> 现在来解释实现细节：当用户往文本框中输入字符时，Windows 会给Edit控件的窗口函数发送 WM_CHAR 消息。这个窗口函数本身寄生于 
  Windows 中，因此不能直接修改它。但是我们可以重定向这个消息使之发送到我们自己编写的窗口处理函数。如果自定义窗口要处理这个消息那就可以处理它，如果不处理就可以把这个消息转发到它原来窗口处理函数。通过这种方式，自定义的窗口处理函数就把它自己插入到 
  Windows 系统和 Edit 控件之间。</p>
<p>看下面的流程： <br>
  窗口子类化之前 <br>
  Windows ==>Edit 控件的窗口处理函数。 </p>
<p>子类化之后 <br>
  Windows ==>自定义的窗口处理函数==> Edit 控件的窗口处理函数。 </p>
<p>注意子类化并不局限于控件，可以子类化任何窗口，现在我们要把精力集中到怎样实现子类化一个窗口上。让我们想想Windows 
  怎样知道 Edit 控件的窗口处理函数放在什么地方。猜的？…肯定不是。原来 WNDCLASSEX 结构的成员 lpfnWndProc 指出了窗口函数地址。如果能用自己编写的窗口函数的地址来替换这个成员变量，那 
  Windows 不就把消息发到自定义的窗口函数了吗! 我们通过调用函数SetWindowLong 来实现这个任务，此函数的原型为： </p>
<pre class="code">SetWindowLong PROTO hWnd:DWORD, nIndex:DWORD, dwNewLong:DWORD</pre>

  <li> hWnd = 将要实施子类化的窗口的句柄</li>
  <li> nIndex = 函数了功能索引 <br>
    GWL_EXSTYLE 设置窗口的扩展风格. <br>
    GWL_STYLE 设置新的窗口风格<br>
    GWL_WNDPROC 设置新的窗口处理函数地址<br>
    GWL_HINSTANCE 设置新的应用程序句柄<br>
    GWL_ID 设置新的窗口标识<br>
    GWL_USERDATA 设置一个与这个窗口相关的给用户使用的32位的数据</li>
  <li> dwNewLong = 用来更新的数据</li>

<p> 我们的工作还是比较简单的： </p>
<ol>
  <li> 写一个窗口函数用于处理发给 Edit 控件的消息。 </li>
  <li> 用参数GWL_WNDPROC调用SetWindowLong 函数，如果调用成功那么返回值就是与调用功能相联系的一个32位的整数</li>
</ol>
<p>在我们的程序中，返回值就是原先窗口函数的地址。我们要保存这个值以便以后使用。 记住：有一些我们不处理的消息，需要把它们派遣给原来的窗口函数来处理，这就用到另外一个函数 
  CallWindowProc， 函数原型为：</p>
<pre class="code"> CallWindowProc PROTO lpPrevWndFunc:DWORD, hWnd:DWORD, Msg:DWORD,wParam:DWORD, lParam:DWORD </pre>
<p>lpPrevWndFunc = 窗口原来函数的地址. 剩下的四个参数就是发给自定义函数的参数，直接把它们传给函数 CallWindowProc 
  就行了。</p>
<p> 代码举例： </p>
<pre class="code">.386
.MODEL        FLAT,STDCALL
option casemap:none 
     INCLUDE  \MASM32\INCLUDE\WINDOWS.INC
     INCLUDE  \MASM32\INCLUDE\USER32.INC
     INCLUDE  \MASM32\INCLUDE\KERNEL32.INC
     INCLUDE  \MASM32\INCLUDE\COMCTL32.INC
  INCLUDELIB  \MASM32\LIB\COMCTL32.LIB
  INCLUDELIB  \MASM32\LIB\USER32.LIB
  INCLUDELIB  \MASM32\LIB\KERNEL32.LIB
WinMain PROTO :DWORD,:DWORD,:DWORD,:DWORD 
EditWndProc PROTO :DWORD,:DWORD,:DWORD,:DWORD 

.DATA
   CLASSNAME  DB        "SUBCLASSWINCLASS",0
     APPNAME  DB        "SUBCLASSING DEMO",0
   EDITCLASS  DB        "EDIT",0
     MESSAGE  DB        "YOU PRESSED ENTER IN THE TEXT BOX!",0

.DATA?
hInstance  HINSTANCE ? 
    HWNDEDIT  DD        ?
  OLDWNDPROC  DD        ?

.CODE
      START:
              INVOKE    GETMODULEHANDLE, NULL
              MOV       HINSTANCE,EAX
              INVOKE    WINMAIN, HINSTANCE,NULL,NULL, SW_SHOWDEFAULT
              INVOKE    EXITPROCESS,EAX

     WINMAIN  PROC      HINST:HINSTANCE,HPREVINST:HINSTANCE,CMDLINE:LPSTR,CMDSHOW:DWORD
              LOCAL     WC:WNDCLASSEX
              LOCAL     MSG:MSG
              LOCAL     HWND:HWND
              MOV       WC.CBSIZE,SIZEOF WNDCLASSEX
              MOV       WC.STYLE, CS_HREDRAW OR CS_VREDRAW
              MOV       WC.LPFNWNDPROC, OFFSET WNDPROC
              MOV       WC.CBCLSEXTRA,NULL
              MOV       WC.CBWNDEXTRA,NULL
              PUSH      HINST
              POP       WC.HINSTANCE
              MOV       WC.HBRBACKGROUND,COLOR_APPWORKSPACE
              MOV       WC.LPSZMENUNAME,NULL
              MOV       WC.LPSZCLASSNAME,OFFSET CLASSNAME
              INVOKE    LOADICON,NULL,IDI_APPLICATION
              MOV       WC.HICON,EAX
              MOV       WC.HICONSM,EAX
              INVOKE    LOADCURSOR,NULL,IDC_ARROW
              MOV       WC.HCURSOR,EAX
              INVOKE    REGISTERCLASSEX, ADDR WC
              INVOKE    CREATEWINDOWEX,WS_EX_CLIENTEDGE,ADDR CLASSNAME,ADDR APPNAME,\
 WS_OVERLAPPED+WS_CAPTION+WS_SYSMENU+WS_MINIMIZEBOX+WS_MAXIMIZEBOX+WS_VISIBLE,CW_USEDEFAULT,\ 
           CW_USEDEFAULT,350,200,NULL,NULL,\ 
           hInst,NULL 
              MOV       HWND,EAX
.WHILE        TRUE
              INVOKE    GETMESSAGE, ADDR MSG,NULL,0,0
.BREAK        .IF (!EAX)
              INVOKE    TRANSLATEMESSAGE, ADDR MSG
              INVOKE    DISPATCHMESSAGE, ADDR MSG
.ENDW
              MOV       EAX,MSG.WPARAM
              RET
     WINMAIN  ENDP

     WNDPROC  PROC      HWND:HWND, UMSG:UINT, WPARAM:WPARAM, LPARAM:LPARAM
.IF           UMSG==WM_CREATE
              INVOKE    CREATEWINDOWEX,WS_EX_CLIENTEDGE,ADDR EDITCLASS,NULL,\
            WS_CHILD+WS_VISIBLE+WS_BORDER,20,\ 
            20,300,25,hWnd,NULL,\ 
            hInstance,NULL 
              MOV       HWNDEDIT,EAX
              INVOKE    SETFOCUS,EAX
        ;----------------------------------------- 
        ; Subclass it! 
        ;----------------------------------------- 
              INVOKE    SETWINDOWLONG,HWNDEDIT,GWL_WNDPROC,ADDR EDITWNDPROC
              MOV       OLDWNDPROC,EAX
.ELSEIF       UMSG==WM_DESTROY
              INVOKE    POSTQUITMESSAGE,NULL
.ELSE
              INVOKE    DEFWINDOWPROC,HWND,UMSG,WPARAM,LPARAM
              RET
.ENDIF
              XOR       EAX,EAX
              RET
     WNDPROC  ENDP

 EDITWNDPROC  PROC      HEDIT:DWORD,UMSG:DWORD,WPARAM:DWORD,LPARAM:DWORD
.IF           UMSG==WM_CHAR
              MOV       EAX,WPARAM
.IF           (AL>="0" && AL<="9") || (AL>="A" && AL<="F") || (AL>="A" && AL<="F") || AL==VK_BACK
.IF           AL>="A" && AL<="F"
              SUB       AL,20H
.ENDIF
              INVOKE    CALLWINDOWPROC,OLDWNDPROC,HEDIT,UMSG,EAX,LPARAM
              RET
.ENDIF
.ELSEIF       UMSG==WM_KEYDOWN
              MOV       EAX,WPARAM
.IF           AL==VK_RETURN
              INVOKE    MESSAGEBOX,HEDIT,ADDR MESSAGE,ADDR APPNAME,MB_OK+MB_ICONINFORMATION
              INVOKE    SETFOCUS,HEDIT
.ELSE
              INVOKE    CALLWINDOWPROC,OLDWNDPROC,HEDIT,UMSG,WPARAM,LPARAM
              RET
.ENDIF
.ELSE
              INVOKE    CALLWINDOWPROC,OLDWNDPROC,HEDIT,UMSG,WPARAM,LPARAM
              RET
.ENDIF
              XOR       EAX,EAX
              RET
 EDITWNDPROC  ENDP
              END       START
</pre>

<p>分析：</p>
<pre class="code">invoke SetWindowLong,hwndEdit,GWL_WNDPROC,addr EditWndProc
mov OldWndProc,eax </pre>
<p>在创建 Edit 控件后，通过调用 SetWindowLong 把原来的窗口函数地址替换为自定义函数的地址，从而对它实施了窗口子类化，要注意 
  为了调用函数 CallWindowProc，我们存储了原窗口函数地址，自已编写的EditWndProc 仅仅是个普普通通的窗口函数。当然也可以再调用一次 
  SetWindowLong 函数来存储这个32位的值，</p>
<pre class="code">invoke SetWindowLong ,hwndEdit,GWL_USERDATA,eax 。</pre>
<p>当然用的时候就要调用GetWindowLong 来取回这个值。  </p>
<pre class="code">
  .if uMsg==WM_CHAR 
        mov eax,wParam 
        .if (al>="0" && al<="9") || (al>="A" && al<="F") || (al>="a" && al<="f") || al==VK_BACK 
            .if al>="a" && al<="f" 
                sub al,20h 
            .endif 
            invoke CallWindowProc,OldWndProc,hEdit,uMsg,eax,lParam 
            ret 
        .endif 
</pre>
 在函数 EditWndProc 中，我们自己处理了WM_CHAR消息： 如果输入的字符是'0'--'9'、'A'-'F'或者是'a'--'f'就接受，并且把此消息转发给原窗口函数，其中若输入的是小写的'a'--'f'就把它变为大写。如果输入的不是十六进制字符，就丢掉它，并且也不转发此消息。因此当输入是非十六进制字符时，这个字符就不会显示在 
Edit 控件中。  
<pre class="code">
    .elseif uMsg==WM_KEYDOWN 
        mov eax,wParam 
        .if al==VK_RETURN 
            invoke MessageBox,hEdit,addr Message,addr AppName,MB_OK+MB_ICONINFORMATION 
            invoke SetFocus,hEdit 
        .else 
            invoke CallWindowProc,OldWndProc,hEdit,uMsg,wParam,lParam 
            ret 
        .end 
</pre>
 在这里我们通过处理 回车(Enter) 键进一步示范了子类化的能力。EditWndProc 通过检查 WM_KEYDONW 
消息来判断是否是 回车键，若是显示提示消息框，否则转发此消息。 你可以用窗口子类化来控制另外的窗口，这是必须掌握的十分有用的技术之一。
<div class="rpindex"><a href="021.html"> 下一页</a><a href="019.html"> 上一页</a><a href="index.html">首页</a></div>



<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
