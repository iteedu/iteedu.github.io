<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->


  <div class="lpindex"><a href="index.html">首页</a><a href="025.html"> 上一页</a><a href="027.html"> 下一页</a></div>
  <h1>第26章: 启动画面</h1>
  上一章我们学习了位图的使用.在这一章我们要用
  上帝赋予我们的创造力来融会贯通上一章我们学到的知识.那就是研究如何用位图来创建启动画面.
  <h3> 理论</h3>
  首先,我们先要搞清楚什么是启动画面.举个简单的例子:我们启动某些作
  的专业一点的程序时(比如Netscape,Adobe Acrobat等)会先跳出一个启动画面.上面通常有一
  些版权信息,版本号等.与此同时,程序后台正做着一些程序的加载或初始化工作.这个启动画面有别于
  一般的窗口.它没有标题栏,没有系统菜单,也没有边框.只有一张位图在屏幕上显示一会儿,然后消失
  .在这一章我们来试试自己做一个. <br>
  第一步你可能会想到把要显示的位图包含到资源文件中去.但是这样做
  有一个缺点.你的程序只在启动的时候显示这张位图,可是它却至始至终存在于你的内存中,直到你
  把程序关掉.这不能不说是对内存的极大浪费.好办法是:创建一个"资源"DLL(动态连接库)来包含位图
  和它独特的显示代码.这样,你就可以在想显示启动画面的时候加载他,用完了就卸载它.所以,我们的
  程序需要2个模块:主程序和启动画面DLL.我们要把位图放到这个DLL的资源中去. <br>
  基本步骤如下:
  <ol>
    <li> 把位图作为一个位图资源放到DLL中去.</li>
    <li> 主程序调用 LoadLibrary 把 dll 加载到内存中去.</li>
    <li> DLL 被调用后,它会建立一个定时器用于管理启动画面显示的时间.然后,注册并创建一个没有
      标题和边框的窗口.同时在窗口的客户区显示位图.</li>
    <li> 等启动画面的显示时间长度到达你预先的设定值,启动画面消失,控制权回到主程序手中.</li>
    <li> 主程序调用 FreeLibrary 从内存中卸载 DLL .然后,做它该做的事去.</li>
  </ol>
  下面我们来研究细节部分
  <h3> 加载/卸载 DLL</h3>
  你可以用 LoadLibrary 灵活的加载一个 DLL ,它的格式如下:
  <pre class="code">LoadLibrary  proto lpDLLName:DWORD</pre>
  它只有一个参数: 你想要加载的 DLL 的名称所在的地址.调用成功返回指向该DLL模块的句柄,反之返回NULL. <br>
  要卸载 DLL, 则调用 FreeLibrary:
  <pre class="code">FreeLibrary  proto  hLib:DWORD</pre>
  它也只有一个参数: 你想要卸载的 DLL 模块的句柄(通常就是上面那个函数返回的啦).
  <h3> 怎样使用定时器</h3>
  首先, 你要用 SetTimer 创建一个定时器:
  <pre class="code">SetTimer  proto  hWnd:DWORD, TimerID:DWORD, uElapse:DWORD, lpTimerFunc:DWORD </pre>
  <p>hWnd接受这个定时器消息的窗口的句柄.如果,你的定时器不需要窗口接受它的消息,你也可以
    用NULL作为参数<br>
    TimerID定时器的 ID 值. 由你自己定义. <br>
    uElapse 定时器定的时间.以ms(千分之一秒)为单位. <br>
    lpTimerFunc 处理该定时器消息的函数所在的地址.如果你用NULL作为该参数,那么定时器的消息会被送给 hWnd 参数所指定的窗口.<br />
    SetTimer 如果成功则返回定时器的 ID 否则返回 NULL. 所以最好不要把定时器的ID设为0(Pheadnius:NULL代表0, 记得吗?).
    
    你可以用2种方法创建定时器:
  <li> 如果你有一个窗口并且定时器把消息传给这个窗口.那么你需要把所有的4个参数都传送给 Settimer 函数
    (lpTimerFunc参数必须为NULL).</li>
  <li> 如果你没有窗口或者你不想让窗口处理定时器的消息,那么你必须在窗口句柄中传送一个NULL.同时你要指定
    用于处理定时器消息的函数的地址.</li>
  <p>这个例子中我们要使用第一种方法. <br>
  当你设定的时间到了, 与定时器相连的窗口会收到 WM_TIMER 消息.例如,你指定 uElapse 的值为 1000, 你的窗口每
  过一秒都会收到 WM_TIMER 消息.<br>
  等到你再也不需要这个定时器了,就用 KillTimer 来去除定时器.  </p>
  <pre class="code">KillTimer  proto  hWnd:DWORD, TimerID:DWORD</pre>
  <h3> 例子:</h3>
  <pre class="code">                                                             

;----------------------------------------------------------------------- 
; 主程序 
;----------------------------------------------------------------------- 
.386
.MODEL        FLAT,STDCALL
option casemap:none 
     INCLUDE  \MASM32\INCLUDE\WINDOWS.INC
     INCLUDE  \MASM32\INCLUDE\USER32.INC
     INCLUDE  \MASM32\INCLUDE\KERNEL32.INC
  INCLUDELIB  \MASM32\LIB\USER32.LIB
  INCLUDELIB  \MASM32\LIB\KERNEL32.LIB WINMAIN PROTO :DWORD,:DWORD,:DWORD,:DWORD

.DATA
   CLASSNAME  DB        "SPLASHDEMOWINCLASS",0
     APPNAME  DB        "SPLASH SCREEN EXAMPLE",0
     LIBNAME  DB        "SPLASH.DLL",0

.DATA?
hInstance HINSTANCE ? 
CommandLine LPSTR ? 
.CODE
      START:
              INVOKE    LOADLIBRARY,ADDR LIBNAME
.IF           EAX!=NULL
              INVOKE    FREELIBRARY,EAX
.ENDIF
              INVOKE    GETMODULEHANDLE, NULL
              MOV       HINSTANCE,EAX
              INVOKE    GETCOMMANDLINE
              MOV       COMMANDLINE,EAX
              INVOKE    WINMAIN, HINSTANCE,NULL,COMMANDLINE, SW_SHOWDEFAULT
              INVOKE    EXITPROCESS,EAX

     WINMAIN  PROC      HINST:HINSTANCE,HPREVINST:HINSTANCE,CMDLINE:LPSTR,CMDSHOW:DWORD
              LOCAL     WC:WNDCLASSEX
              LOCAL     MSG:MSG
              LOCAL     HWND:HWND
              MOV       WC.CBSIZE,SIZEOF WNDCLASSEX
              MOV       WC.STYLE, CS_HREDRAW OR CS_VREDRAW
              MOV       WC.LPFNWNDPROC, OFFSET WNDPROC
              MOV       WC.CBCLSEXTRA,NULL
              MOV       WC.CBWNDEXTRA,NULL
              PUSH      HINSTANCE
              POP       WC.HINSTANCE
              MOV       WC.HBRBACKGROUND,COLOR_WINDOW+1
              MOV       WC.LPSZMENUNAME,NULL
              MOV       WC.LPSZCLASSNAME,OFFSET CLASSNAME
              INVOKE    LOADICON,NULL,IDI_APPLICATION
              MOV       WC.HICON,EAX
              MOV       WC.HICONSM,EAX
              INVOKE    LOADCURSOR,NULL,IDC_ARROW
              MOV       WC.HCURSOR,EAX
              INVOKE    REGISTERCLASSEX, ADDR WC
              INVOKE    CREATEWINDOWEX,NULL,ADDR CLASSNAME,ADDR APPNAME,\
WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\ 
CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\ 
hInst,NULL 
              MOV       HWND,EAX
              INVOKE    SHOWWINDOW, HWND,SW_SHOWNORMAL
              INVOKE    UPDATEWINDOW, HWND
.WHILE        TRUE
              INVOKE    GETMESSAGE, ADDR MSG,NULL,0,0
.BREAK        .IF (!EAX)
              INVOKE    TRANSLATEMESSAGE, ADDR MSG
              INVOKE    DISPATCHMESSAGE, ADDR MSG
.ENDW
              MOV       EAX,MSG.WPARAM
              RET
     WINMAIN  ENDP

     WNDPROC  PROC      HWND:HWND, UMSG:UINT, WPARAM:WPARAM, LPARAM:LPARAM
.IF           UMSG==WM_DESTROY
              INVOKE    POSTQUITMESSAGE,NULL
.ELSE
              INVOKE    DEFWINDOWPROC,HWND,UMSG,WPARAM,LPARAM
              RET
.ENDIF
              XOR       EAX,EAX
              RET
     WNDPROC  ENDP
              END       START

;-------------------------------------------------------------------- 
; 位图 DLL 
;-------------------------------------------------------------------- 
.386
.MODEL        FLAT, STDCALL
     INCLUDE  \MASM32\INCLUDE\WINDOWS.INC
     INCLUDE  \MASM32\INCLUDE\USER32.INC
     INCLUDE  \MASM32\INCLUDE\KERNEL32.INC
     INCLUDE  \MASM32\INCLUDE\GDI32.INC
  INCLUDELIB  \MASM32\LIB\USER32.LIB
  INCLUDELIB  \MASM32\LIB\KERNEL32.LIB
  INCLUDELIB  \MASM32\LIB\GDI32.LIB
.DATA
  BITMAPNAME  DB        "MYSPLASHBMP",0
   CLASSNAME  DB        "SPLASHWNDCLASS",0
     HBITMAP  DD        0
     TIMERID  DD        0

.DATA
   HINSTANCE  DD        ?

.CODE

    DLLENTRY  PROC      HINST:DWORD, REASON:DWORD, RESERVED1:DWORD
.IF           REASON==DLL_PROCESS_ATTACH                                           ; When the dll is loaded
              PUSH      HINST
              POP       HINSTANCE
              CALL      SHOWBITMAP
.ENDIF
              MOV       EAX,TRUE
              RET
    DLLENTRY  ENDP
  SHOWBITMAP  PROC
              LOCAL     WC:WNDCLASSEX
              LOCAL     MSG:MSG
              LOCAL     HWND:HWND
              MOV       WC.CBSIZE,SIZEOF WNDCLASSEX
              MOV       WC.STYLE, CS_HREDRAW OR CS_VREDRAW
              MOV       WC.LPFNWNDPROC, OFFSET WNDPROC
              MOV       WC.CBCLSEXTRA,NULL
              MOV       WC.CBWNDEXTRA,NULL
              PUSH      HINSTANCE
              POP       WC.HINSTANCE
              MOV       WC.HBRBACKGROUND,COLOR_WINDOW+1
              MOV       WC.LPSZMENUNAME,NULL
              MOV       WC.LPSZCLASSNAME,OFFSET CLASSNAME
              INVOKE    LOADICON,NULL,IDI_APPLICATION
              MOV       WC.HICON,EAX
              MOV       WC.HICONSM,0
              INVOKE    LOADCURSOR,NULL,IDC_ARROW
              MOV       WC.HCURSOR,EAX
              INVOKE    REGISTERCLASSEX, ADDR WC
              INVOKE    CREATEWINDOWEX,NULL,ADDR CLASSNAME,NULL,\
WS_POPUP,CW_USEDEFAULT,\ 
CW_USEDEFAULT,250,250,NULL,NULL,\ 
hInstance,NULL 
              MOV       HWND,EAX
              INVOKE    SHOWWINDOW, HWND,SW_SHOWNORMAL
.WHILE        TRUE
              INVOKE    GETMESSAGE, ADDR MSG,NULL,0,0
.BREAK        .IF (!EAX)
              INVOKE    TRANSLATEMESSAGE, ADDR MSG
              INVOKE    DISPATCHMESSAGE, ADDR MSG
.ENDW
              MOV       EAX,MSG.WPARAM
              RET
  SHOWBITMAP  ENDP
     WNDPROC  PROC      HWND:DWORD,UMSG:DWORD,WPARAM:DWORD,LPARAM:DWORD
              LOCAL     PS:PAINTSTRUCT
              LOCAL     HDC:HDC
              LOCAL     HMEMORYDC:HDC
              LOCAL     HOLDBMP:DWORD
              LOCAL     BITMAP:BITMAP
              LOCAL     DLGHEIGHT:DWORD
              LOCAL     DLGWIDTH:DWORD
              LOCAL     DLGRECT:RECT
              LOCAL     DESKTOPRECT:RECT

.IF           UMSG==WM_DESTROY
.IF           HBITMAP!=0
              INVOKE    DELETEOBJECT,HBITMAP
.ENDIF
              INVOKE    POSTQUITMESSAGE,NULL
.ELSEIF       UMSG==WM_CREATE
              INVOKE    GETWINDOWRECT,HWND,ADDR DLGRECT
              INVOKE    GETDESKTOPWINDOW
              MOV       ECX,EAX
              INVOKE    GETWINDOWRECT,ECX,ADDR DESKTOPRECT
              PUSH      0
              MOV       EAX,DLGRECT.BOTTOM
              SUB       EAX,DLGRECT.TOP
              MOV       DLGHEIGHT,EAX
              PUSH      EAX
              MOV       EAX,DLGRECT.RIGHT
              SUB       EAX,DLGRECT.LEFT
              MOV       DLGWIDTH,EAX
              PUSH      EAX
              MOV       EAX,DESKTOPRECT.BOTTOM
              SUB       EAX,DLGHEIGHT
              SHR       EAX,1
              PUSH      EAX
              MOV       EAX,DESKTOPRECT.RIGHT
              SUB       EAX,DLGWIDTH
              SHR       EAX,1
              PUSH      EAX
              PUSH      HWND
              CALL      MOVEWINDOW
              INVOKE    LOADBITMAP,HINSTANCE,ADDR BITMAPNAME
              MOV       HBITMAP,EAX
              INVOKE    SETTIMER,HWND,1,2000,NULL
              MOV       TIMERID,EAX
.ELSEIF       UMSG==WM_TIMER
              INVOKE    SENDMESSAGE,HWND,WM_LBUTTONDOWN,NULL,NULL
              INVOKE    KILLTIMER,HWND,TIMERID
.ELSEIF       UMSG==WM_PAINT
              INVOKE    BEGINPAINT,HWND,ADDR PS
              MOV       HDC,EAX
              INVOKE    CREATECOMPATIBLEDC,HDC
              MOV       HMEMORYDC,EAX
              INVOKE    SELECTOBJECT,EAX,HBITMAP
              MOV       HOLDBMP,EAX
              INVOKE    GETOBJECT,HBITMAP,SIZEOF BITMAP,ADDR BITMAP
              INVOKE    STRETCHBLT,HDC,0,0,250,250,\
hMemoryDC,0,0,bitmap.bmWidth,bitmap.bmHeight,SRCCOPY 
              INVOKE    SELECTOBJECT,HMEMORYDC,HOLDBMP
              INVOKE    DELETEDC,HMEMORYDC
              INVOKE    ENDPAINT,HWND,ADDR PS
.ELSEIF       UMSG==WM_LBUTTONDOWN
              INVOKE    DESTROYWINDOW,HWND
.ELSE
              INVOKE    DEFWINDOWPROC,HWND,UMSG,WPARAM,LPARAM
              RET
.ENDIF
              XOR       EAX,EAX
              RET
     WNDPROC  ENDP

              END       DLLENTRY</pre>
  <h3> 分析:</h3>
  <p>我们首先要再主程序中检验这段代码.  </p>
  <pre class="code">              INVOKE    LOADLIBRARY,ADDR LIBNAME
.IF           EAX!=NULL
              INVOKE    FREELIBRARY,EAX
.ENDIF</pre>
  <p>我们调用 LoadLibrary 读入名称为 "splash.dll" 的 DLL. 然后, 用 FreeLibrary 卸载. 一直到 DLL 完成初始化, LoadLibrary才会返回.<br>
    主程序的任务到此为止. 更有趣的部分再 DLL里. </p>
  <pre class="code">.IF           REASON==DLL_PROCESS_ATTACH                                           ; When the dll is loaded
              PUSH      HINST
              POP       HINSTANCE
              CALL      SHOWBITMAP</pre>
  
  <p>DLL 被加载后, Windows 调用它的有 DLL_PROCESS_ATTACH 标记的入口函数. 我们借这个机会显示启动画面. 首先,我们
    保存 DLL 事例的句柄以供将来使用. 然后, 调用一个叫 ShowBitMap 的函数进行真正的工作. ShowBitMap 注册一个窗口,
    创建这个窗口和显示它.就像我们以前创建窗口一样. 有趣的是这个 CreateWindowEx 调用:
  </p>
  <pre class="code">              INVOKE    CREATEWINDOWEX,NULL,ADDR CLASSNAME,NULL,\
                        WS_POPUP,CW_USEDEFAULT,\
                        CW_USEDEFAULT,250,250,NULL,NULL,\
                        hInstance,NULL</pre>
  <p>注意, 这里的窗口风格仅仅使用了 WS_POPUP . 所以窗口即没有标题栏,也没有边界. 我们同时也限定窗口的宽高为
    250x250个像素.<br>
    现在窗口创建好了. 在 WM_CREATE 的消息处理代码里我们把这个窗口移到屏幕的中央.代码如下:
  <pre class="code">

              INVOKE    GETWINDOWRECT,HWND,ADDR DLGRECT
              INVOKE    GETDESKTOPWINDOW
              MOV       ECX,EAX
              INVOKE    GETWINDOWRECT,ECX,ADDR DESKTOPRECT
              PUSH      0
              MOV       EAX,DLGRECT.BOTTOM
              SUB       EAX,DLGRECT.TOP
              MOV       DLGHEIGHT,EAX
              PUSH      EAX
              MOV       EAX,DLGRECT.RIGHT
              SUB       EAX,DLGRECT.LEFT
              MOV       DLGWIDTH,EAX
              PUSH      EAX
              MOV       EAX,DESKTOPRECT.BOTTOM
              SUB       EAX,DLGHEIGHT
              SHR       EAX,1
              PUSH      EAX
              MOV       EAX,DESKTOPRECT.RIGHT
              SUB       EAX,DLGWIDTH
              SHR       EAX,1
              PUSH      EAX
              PUSH      HWND
              CALL      MOVEWINDOW</pre>
  
  <p>它先找到桌面和窗口的大小. 然后,计算出一个窗口左上角的坐标. 使这个窗口能位于屏幕中央.
  <pre class="code">              INVOKE    LOADBITMAP,HINSTANCE,ADDR BITMAPNAME
              MOV       HBITMAP,EAX
              INVOKE    SETTIMER,HWND,1,2000,NULL
              MOV       TIMERID,EAX</pre>
  
  <p>下一步,它用 LoadBitmap 从资源中读入位图并且创建一个定时器.定时器的 ID 为 1 时间间隔为 2 秒. 定时器
    将每 2 秒 向窗口发送 WM_TIMER 消息.
  </p>
  <pre class="code">.ELSEIF       UMSG==WM_PAINT
              INVOKE    BEGINPAINT,HWND,ADDR PS
              MOV       HDC,EAX
              INVOKE    CREATECOMPATIBLEDC,HDC
              MOV       HMEMORYDC,EAX
              INVOKE    SELECTOBJECT,EAX,HBITMAP
              MOV       HOLDBMP,EAX
              INVOKE    GETOBJECT,HBITMAP,SIZEOF BITMAP,ADDR BITMAP
              INVOKE    STRETCHBLT,HDC,0,0,250,250,hMemoryDC,0,0,bitmap.bmWidth,bitmap.bmHeight,SRCCOPY
              INVOKE    SELECTOBJECT,HMEMORYDC,HOLDBMP
              INVOKE    DELETEDC,HMEMORYDC
              INVOKE    ENDPAINT,HWND,ADDR PS</pre>
  <p>当窗口收到 WM_PAINT 消息, 它创建一个内存DC(Pheadnius:还记得DC吗. 在win32编程中你会经常遇到DC这个词.
    它是 Device Context 的缩写, 官方译为"设备描述表". 如果你研究过vc, 你应该对它不陌生. 不过如果你不明白它是什么
    也不要紧. 你可以把它看作一个句柄. 就是某个设备或某块内存的名称.),然后把位图选进内存DC. 再用 GetObject 函数获得
    位图的尺寸, 然后用 StretchBlt 把位图显示在窗口上. StretchBlt的作用和 BitBlt 一样,但它可以拉伸或压缩位图到我们
    希望的大小. 在这里我们希望位图能适合窗口的大小,所以我们 StretchBlt 代替 BitBlt. 之后我们删除内存DC.
  <pre class="code">.ELSEIF       UMSG==WM_LBUTTONDOWN
              INVOKE    DESTROYWINDOW,HWND</pre>
  
  <p>如果你的程序的使用者每次都要看到启动画面消失才能用, 他们一定会厌烦. 我们可以为用户提供多一种选择.
    当他单击启动画面, 它就会消失. 这就是为什么我们要在DLL里处理 WM_LBUTTONDOWN 消息.
    收到这个消息后立即就用 DestroyWindow 关掉窗口.
  <pre class="code">.ELSEIF       UMSG==WM_TIMER
              INVOKE    SENDMESSAGE,HWND,WM_LBUTTONDOWN,NULL,NULL
              INVOKE    KILLTIMER,HWND,TIMERID</pre>
  
  <p>如果用户选择等待, 那么启动画面会在定时器到了指定的时间后消失. (在本例中, 是 2 秒). 我们可以通过处理
    WM_TIMER 消息达到这一目的. 在收到这一消息后,我们可以对窗口传送 WM_LBUTTONDOWN 消息来关掉窗口. 这是为了避免
    代码重复. 现在, 我们不再需要这个定时器了,所以我们用 KillTimer 删除它. <br>
    窗口关闭后,DLL 把控制权还给主程序.
  <div class="rpindex"><a href="027.html"> 下一页</a><a href="025.html"> 上一页</a><a href="index.html">首页</a></div>


<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
