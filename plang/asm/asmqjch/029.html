<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->



<div class="lpindex"><a href="index.html">首页</a><a href="028.html"> 上一页</a><a href="030.html"> 下一页</a></div>
<h1>第29课: Win32调试API 第二部分</h1>
我们继续Win32调试API的话题。在本章中，我们将要学习如何修改被调试程序。
<h3>理论:</h3>
<p>在前面一章中，我们学会了如何装载被调试的进程以及如何处理进程中发生的事件。
为了有实际用途，我们的程序应具有修改被调试程序的能力。有好几个API函数用于这
一目的。</p>

  <li>ReadProcessMemory该函数允许你去读指定的进程的内存。函数原型如下: 
    <pre class="code">ReadProcessMemory proto hProcess:DWORD, lpBaseAddress:DWORD, lpBuffer:DWORD, nSize:DWORD, lpNumberOfBytesRead:DWORD</pre>
    <p>hProcess 待读进程的句柄.<br>
      lpBaseAddress 目标进程中待读内存起始地址。例如，如果你想要读目标
      进程中从地址401000h开始的4个字节，该参数值应置为401000h。<br>
      lpBuffer 接收缓冲区地址<br>
      nSize 想要读的字节数。<br>
      lpNumberOfBytesRead 记录实际读取的字节数的变量地址。如果对这个值
      不关心，填入NULL即可。</p>
  </li>
  <li>WriteProcessMemory 是对应于ReadProcessMemory的函数，通过它
    可以写目标进程的内存。其参数和ReadProcessMemory 相同。
    <p>理解接下去的两个函数需要一些进程上下文的有关背景知识。在象Windows这样的
      多任务操作系统中，同一时间里可能运行着几个程序。Windows分配给每个线程一个
      时间片，当时间片结束后，Windows将冻结当前线程并切换到下一具有最高优先级的
      线程。在切换之前，Windows将保存当前进程的寄存器的 内容，这样当在该线程再
      次恢复运行时，Windows可以恢复最近一次线程运行的*环境*。保存的寄存器内容总
    称为进程上下文。</p>
    <p> 现在回到我们的主题。当一个调试事件发生时，Windows暂停被调试进程，并保存其
      进程上下文。由于进程被暂停运行，我们可以确信其进程上下文内容将保持不变。
      可以用GetThreadContext来获取进程上下文内容，并且也可以用GetThreadContext
      来修改进程上下文内容。</p>
    <p> 这两个函数威力非凡。有了他们，对被调试进程你就具有象VxD的能力: 如改变其寄
      存器内容，而在被调试程序恢复运行前，这些值将会写回寄存器中。在进程上下文中
      所做的任何改动，将都会反映到被调试程序中。想象一下: 甚至可以改变eip寄存器
      的内容，这样你可以让程序运行到你想要的任何地方! 在正常情况下是不可能做到这
      一点的。</p>
    <pre class="code">GetThreadContext proto hThread:DWORD, lpContext:DWORD </pre>
    <p>hThread 你想要获得上下文的线程句柄<br>
      lpContext 函数成功返回时用来保存上下文内容的结构指针。</p>
    <p>SetThreadContext 参数相同。让我们来看看上下文的结构: </p>
    <pre class="code">
     CONTEXT  STRUCT


            CONTEXTFLAGS  DD        ?
;----------------------------------------------------------------------------------------------------------
;当ContextFlags包含CONTEXT_DEBUG_REGISTERS，返回本部分

;-----------------------------------------------------------------------------------------------------------
        IDR0  DD        ?
        IDR1  DD        ?
        IDR2  DD        ?
        IDR3  DD        ?
        IDR6  DD        ?
        IDR7  DD        ?

;----------------------------------------------------------------------------------------------------------
;当ContextFlags包含CONTEXT_FLOATING_POINT，返回本部分

;-----------------------------------------------------------------------------------------------------------

FloatSave FLOATING_SAVE_AREA <> 
;----------------------------------------------------------------------------------------------------------
;当ContextFlags包含CONTEXT_SEGMENTS，返回本部分

;-----------------------------------------------------------------------------------------------------------
       REGGS  DD        ?
       REGFS  DD        ?
       REGES  DD        ?
       REGDS  DD        ?
;----------------------------------------------------------------------------------------------------------
;当ContextFlags包含CONTEXT_INTEGER，返回本部分
;-----------------------------------------------------------------------------------------------------------
      REGEDI  DD        ?
      REGESI  DD        ?
      REGEBX  DD        ?
      REGEDX  DD        ?
      REGECX  DD        ?
      REGEAX  DD        ?
;----------------------------------------------------------------------------------------------------------
;当ContextFlags包含CONTEXT_CONTROL，返回本部分

;-----------------------------------------------------------------------------------------------------------
      REGEBP  DD        ?
      REGEIP  DD        ?
       REGCS  DD        ?
     REGFLAG  DD        ?
      REGESP  DD        ?
       REGSS  DD        ?
;----------------------------------------------------------------------------------------------------------
;当ContextFlags包含CONTEXT_EXTENDED_REGISTERS，返回本部分
;-----------------------------------------------------------------------------------------------------------
       EXTENDEDREGISTERS  DB        MAXIMUM_SUPPORTED_EXTENSION DUP(?) CONTEXT ENDS</pre>
  </li>
  <li><p>可以看出，该结构中的成员是对实际处理器的寄存器的模仿。在使用该结构之前
    要在ContextFlags 中指定哪些寄存器组用来读写。如要访问所有的寄存器，
    你可以置ContextFlags 为CONTEXT_FULL 。或者只访问regEbp, 
    regEip, regCs, regFlag, regEsp 或 regSs, 应置ContextFlags 为
    CONTEXT_CONTROL 。</p>
    <p>在使用结构CONTEXT 时还应记住: 它必须是双字对齐的，否则在NT下将得
    到奇怪的结果。可以在定义前加上&quot;align dword&quot。例如: </p>
    <pre class="code">              ALIGN     DWORD
MyContext CONTEXT <></pre>
  </li>

<h3>例:</h3>
<p>第一个例子演示DebugActiveProcess的使用。首先，需要在Windows显示在屏
幕上以前运行一个待调试程序win.exe，该程序将处于无限循环运行状态中。然后你运行
例子程序，它将把自己与win.exe连接起来，并且修改win.exe的代码，这样win.exe将退
出无限循环状态而显示自己的窗口。</p>
<pre class="code">
.386
.MODEL        FLAT,STDCALL
option casemap:none 
     INCLUDE  \MASM32\INCLUDE\WINDOWS.INC
     INCLUDE  \MASM32\INCLUDE\KERNEL32.INC
     INCLUDE  \MASM32\INCLUDE\COMDLG32.INC
     INCLUDE  \MASM32\INCLUDE\USER32.INC
  INCLUDELIB  \MASM32\LIB\KERNEL32.LIB
  INCLUDELIB  \MASM32\LIB\COMDLG32.LIB
  INCLUDELIB  \MASM32\LIB\USER32.LIB

.DATA
     APPNAME  DB        "WIN32 DEBUG EXAMPLE NO.2",0
   CLASSNAME  DB        "SIMPLEWINCLASS",0
  SEARCHFAIL  DB        "CANNOT FIND THE TARGET PROCESS",0
           TARGETPATCHED  DB        "TARGET PATCHED!",0
      BUFFER  DW        9090H

.DATA?
DBEvent DEBUG_EVENT <> 
   PROCESSID  DD        ?
    THREADID  DD        ?
              ALIGN     DWORD
context CONTEXT <> 

.CODE
      START:
              INVOKE    FINDWINDOW, ADDR CLASSNAME, NULL
.IF           EAX!=NULL
              INVOKE    GETWINDOWTHREADPROCESSID, EAX, ADDR PROCESSID
              MOV       THREADID, EAX
              INVOKE    DEBUGACTIVEPROCESS, PROCESSID
.WHILE        TRUE
              INVOKE    WAITFORDEBUGEVENT, ADDR DBEVENT, INFINITE
.BREAK        .IF DBEVENT.DWDEBUGEVENTCODE==EXIT_PROCESS_DEBUG_EVENT
.IF           DBEVENT.DWDEBUGEVENTCODE==CREATE_PROCESS_DEBUG_EVENT
              MOV       CONTEXT.CONTEXTFLAGS, CONTEXT_CONTROL
              INVOKE    GETTHREADCONTEXT,DBEVENT.U.CREATEPROCESSINFO.HTHREAD, ADDR CONTEXT
              INVOKE    WRITEPROCESSMEMORY, DBEVENT.U.CREATEPROCESSINFO.HPROCESS, CONTEXT.REGEIP ,ADDR BUFFER, 2, NULL
              INVOKE    MESSAGEBOX, 0, ADDR TARGETPATCHED, ADDR APPNAME, MB_OK+MB_ICONINFORMATION
.ELSEIF       DBEVENT.DWDEBUGEVENTCODE==EXCEPTION_DEBUG_EVENT
.IF           DBEVENT.U.EXCEPTION.PEXCEPTIONRECORD.EXCEPTIONCODE==EXCEPTION_BREAKPOINT
              INVOKE    CONTINUEDEBUGEVENT, DBEVENT.DWPROCESSID,DBEVENT.DWTHREADID, DBG_CONTINUE
.CONTINUE
.ENDIF
.ENDIF
              INVOKE    CONTINUEDEBUGEVENT, DBEVENT.DWPROCESSID, DBEVENT.DWTHREADID, DBG_EXCEPTION_NOT_HANDLED
.ENDW
.ELSE
              INVOKE    MESSAGEBOX, 0, ADDR SEARCHFAIL, ADDR APPNAME,MB_OK+MB_ICONERROR .ENDIF
              INVOKE    EXITPROCESS, 0
              END       START

;--------------------------------------------------------------------
; The partial source code of win.asm, our debuggee. It's actually
; the simple window example in tutorial 2 with an infinite loop inserted
; just before it enters the message loop.
;----------------------------------------------------------------------

......
              MOV       WC.HICONSM,EAX
              INVOKE    LOADCURSOR,NULL,IDC_ARROW
              MOV       WC.HCURSOR,EAX
              INVOKE    REGISTERCLASSEX, ADDR WC
              INVOKE    CREATEWINDOWEX,NULL,ADDR CLASSNAME,ADDR APPNAME,\ WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\ CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\ HINST,NULL
              MOV       HWND,EAX
              JMP       $ < ---- HERE's our infinite loop. It assembles to EB FE
              INVOKE    SHOWWINDOW, HWND,SW_SHOWNORMAL
              INVOKE    UPDATEWINDOW, HWND
.WHILE        TRUE
              INVOKE    GETMESSAGE, ADDR MSG,NULL,0,0
.BREAK        .IF (!EAX)
              INVOKE    TRANSLATEMESSAGE, ADDR MSG
              INVOKE    DISPATCHMESSAGE, ADDR MSG
.ENDW
              MOV       EAX,MSG.WPARAM
              RET
     WINMAIN  ENDP</pre>
<h3>分析:</h3>
<pre class="code">invoke FindWindow, addr ClassName, NULL </pre>
<p>我们的程序需要用DebugActiveProcess将自己绑定到被调试程序，这需要知道
被调试程序的进程Id。用GetWindowThreadProcessId 可以得到该Id，该函数需要
窗口句柄作为参数，因此首先需要知道窗口句柄。<br>
  用FindWindow, 我们先指定窗口类的名称，返回的是该类创建的窗口句柄。如
  果返回NULL，则表明当前没有该类的窗口。</p>
<pre class="code">.IF           EAX!=NULL
              INVOKE    GETWINDOWTHREADPROCESSID, EAX, ADDR PROCESSID
              MOV       THREADID, EAX
              INVOKE    DEBUGACTIVEPROCESS, PROCESSID</pre>
<p>得到进程Id后，我们调用DebugActiveProcess。这样就进入等待调试事件的循
环中。</p>
<pre class="code">.IF           DBEVENT.DWDEBUGEVENTCODE==CREATE_PROCESS_DEBUG_EVENT
              MOV       CONTEXT.CONTEXTFLAGS, CONTEXT_CONTROL
              INVOKE    GETTHREADCONTEXT,DBEVENT.U.CREATEPROCESSINFO.HTHREAD, ADDR CONTEXT</pre>
<p>当得到 CREATE_PROCESS_DEBUG_INFO, 这意味着被调试进程已经被暂停运行了。
  我们就可以对该进程动手术了。本例中，我们将用NOPs ( 90h 90h)覆盖被调试进程中的无
  限循环指令(0EBh 0FEh) 。
  <br>
  首先，需要得到该指令的地址。由于在我们的程序绑定到被调试程序时，被调试程序已经
  处于循环语句中了，eip总是指向该指令。我们所要做的是得到eip的值。我们将使用
  GetThreadContext来达到此目的。将上下文结构成员中ContextFlags设置
  为CONTEXT_CONTROL ，这样告诉GetThreadContext我们需要它去填充上下
  文结构的成员中的&quot;控制&quot;寄存器。
</p>
<pre class="code">              INVOKE    WRITEPROCESSMEMORY, DBEVENT.U.CREATEPROCESSINFO.HPROCESS, CONTEXT.REGEIP ,ADDR BUFFER, 2, NULL</pre>
<p>得到eip的值以后，可以调用WriteProcessMemory来用NOPs覆盖&quot;jmp $&quot;
   指令，这样将使被调试程序退出无限循环。在向用户显示了信息之后，调用ContinueDebugEvent
   来恢复被调试程序的运行。由于指令&quot;jmp $&quot;已被Nops覆盖，被调试程序将继续
   显示窗口，并进入消息循环。证据是我们在屏幕上观察到了次窗口。
</p>
<p>另一个例子与此稍有不同，它是将被调试程序从无限循环中中断。
</p>
<pre class="code">                                    .......
.......
.IF           DBEVENT.DWDEBUGEVENTCODE==CREATE_PROCESS_DEBUG_EVENT
              MOV       CONTEXT.CONTEXTFLAGS, CONTEXT_CONTROL
              INVOKE    GETTHREADCONTEXT,DBEVENT.U.CREATEPROCESSINFO.HTHREAD, ADDR CONTEXT
              ADD       CONTEXT.REGEIP,2
              INVOKE    SETTHREADCONTEXT,DBEVENT.U.CREATEPROCESSINFO.HTHREAD, ADDR CONTEXT
              INVOKE    MESSAGEBOX, 0, ADDR LOOPSKIPPED, ADDR APPNAME, MB_OK+MB_ICONINFORMATION
.......
....... </pre>
<p>这里仍调用GetThreadContext来获取eip值，但没有去覆盖&quot;jmp $&quot;
  指令，而是将 regEip加2，从而&quot;跳过&quot;该指令。结果是当被调试程序
  重新获得控制权时，将恢复执行在&quot;jmp $&quot;后的指令。</p>
<p>现在你可以体会到Get/SetThreadContext的威力了。你也可以修改其他寄存器映象，这
些值将直接反映到被调试程序中。甚至你可以把int 3h指令插入到被调试进程中。产生断点。</p>

  
  <div class="rpindex"><a href="030.html"> 下一页</a><a href="028.html"> 上一页</a><a href="index.html">首页</a></div>



<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
