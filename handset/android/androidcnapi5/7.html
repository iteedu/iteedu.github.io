<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->


<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->





        
<div class=WordSection7 style='layout-grid:15.6pt'><br clear=all
style='page-break-before:always'>

<p class=MsoNormal align=center style='text-align:center'><a
name=ApplicationFundamentals><b>Application
Fundamentals</b></a></p>

<p class=MsoNormal align=center style='text-align:center'>署名：译言biAji </p>

<p class=MsoNormal align=center style='text-align:center'>链接：http://developer.android.com/guide/topics/fundamentals.html&nbsp;
</p>

<p class=MsoNormal align=center style='text-align:center'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>应用程序基础</b><b>(Application Fundamentals)</b></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>Android应用程序使用Java做为开发语言。aapt工具把编译后的Java代码连同其它应用程序需要的数据和资源文件一起打包到一个Android包文件中，这个文件使用.apk做为扩展名，它是分发应用程序并安装到移动设备的媒介，用户只需下载并安装此文件到他们的设备。单一.apk文件中的所有代码被认为是一个应用程序。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:11.9pt'>从很多方面来看，每个Android应用程序都存在于它自己的世界之中：</p>

<p class=MsoNormal align=left style='margin-left:32.9pt;text-align:left;
text-indent:-21.0pt'>l 默认情况下，每个应用程序均运行于它自己的Linux进程中。当应用程序中的任意代码开始执行时，Android启动一个进程，而当不再需要此进程而其它应用程序又需要系统资源时，则关闭这个进程。</p>

<p class=MsoNormal align=left style='margin-left:32.9pt;text-align:left;
text-indent:-21.0pt'>l 每个进程都运行于自己的Java虚拟机（VM）中。所以应用程序代码实际上与其它应用程序的代码是隔绝的。</p>

<p class=MsoNormal align=left style='margin-left:32.9pt;text-align:left;
text-indent:-21.0pt'>l 默认情况下，每个应用程序均被赋予一个唯一的Linux用户ID，并加以权限设置，使得应用程序的文件仅对这个用户、这个应用程序可见。当然，也有其它的方法使得这些文件同样能为别的应用程序所访问。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:11.9pt'>使两个应用程序共有同一个用户ID是可行的，这种情况下他们可以看到彼此的文件。从系统资源维护的角度来看，拥有同一个ID的应用程序也将在运行时使用同一个Linux进程，以及同一个虚拟机。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=center style='text-align:center'><b>应用程序组件</b><b>(Application Components)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Android的核心功能之一就是一个应用程序可以使用其它应用程序的元素（如果那个应用程序允许的话）。比如说，如果你的应用程序需要一个图片卷动列
表，而另一个应用程序已经开发了一个合用的而又允许别人使用的话，你可以直接调用那个卷动列表来完成工作，而不用自己再开发一个。你的应用程序并没有吸纳
或链接其它应用程序的代码，它只是在有需求的时候启动了其它应用程序的那个功能部分。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为达到这个目的，系统必须在一个应用程序的一部分被需要时启动这个应用程序，并将那个部分的Java对象实例化。与在其它系统上的应用程序不同，Android应用程序没有为应用准备一个单独的程序入口（比如说，没有<code>main()</code>方法）， 而是为系统依照需求实例化提供了基本的组件。共有四种组件类型：</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Activities</b></p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; Activity是为用户操作而展示的可视化用户界面。比如说，一个activity可以展示一个菜单项列表供用户选择，或者显示一些包含说明的照片。一个短消息应用程序可以包括一个用于显示做为发送对象的联系人的列表的activity，一个给选定的联系人写短信的activity以及翻阅以前的短信和改变设置的activity。尽管它们一起组成了一个内聚的用户界面，但其中每个activity都与其它的保持独立。每个都是以Activity类为基类的子类实现。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 一个应用程序可以只有一个activity，或者，如刚才提到的短信应用程序那样，包含很多个。每个activity的作用，以及其数目，自然取决于应用 程序及其设计。一般情况下，总有一个应用程序被标记为用户在应用程序启动的时候第一个看到的。从一个activity转向另一个的方式是靠当前的 activity启动下一个。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 每个activity都被给予一个默认的窗口以进行绘制。一般情况下，这个窗口是满屏的，但它也可以是一个小的位于其它窗口之上的浮动窗口。一个 activity也可以使用超过一个的窗口──比如，在activity运行过程中弹出的一个供用户反应的小对话框，或是当用户选择了屏幕上特定项目后显
示的必要信息。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 窗口显示的可视内容是由一系列视图构成的，这些视图均继承自 <code>View</code> 基类。每个视图均控制着窗口中一块特定的矩形空 间。父级视图包含并组织它子视图的布局。叶节点视图（位于视图层次最底端）在它们控制的矩形中进行绘制，并对用户对其直接操作做出响应。所以，视图是 activity与用户进行交互的界面。比如说，视图可以显示一个小图片，并在用户指点它的时候产生动作。Android有很多既定的视图供用户直接使 用，包括按钮、文本域、卷轴、菜单项、复选框等等。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 视图层次是由<code>Activity.setContentView()</code> 方法放入activity的窗口之中的。上下文视图是位于视图层次根位置的视图对象。（参见用户界面章节获取关于视图及层次的更多信息。）</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>服务(Services)</b></p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 服务没有可视化的用户界面，而是在一段时间内在后台运行。比如说，一个服务可以在用户做其它事情的时候在后台播放背景音乐、从网络上获取一些数据或者计算一些东西并提供给需要这个运算结果的activity使用。每个服务都继承自Service基类。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 一个媒体播放器播放播放列表中的曲目是一个不错的例子。播放器应用程序可能有一个或多个activity来给用户选择歌曲并进行播放。然而，音乐播放这个
任务本身不应该为任何activity所处理，因为用户期望在他们离开播放器应用程序而开始做别的事情时，音乐仍在继续播放。为达到这个目的，媒体播放器 activity应该启用一个运行于后台的服务。而系统将在这个activity不再显示于屏幕之后，仍维持音乐播放服务的运行。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 你可以连接至（绑定）一个正在运行的服务（如果服务没有运行，则启动之）。连接之后，你可以通过那个服务暴露出来的接口与服务进行通讯。对于音乐服务来说，这个接口可以允许用户暂停、回退、停止以及重新开始播放。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 如同activity和其它组件一样，服务运行于应用程序进程的主线程内。所以它不会对其它组件或用户界面有任何干扰，它们一般会派生一个新线程来进行一些耗时任务（比如音乐回放）。参见下述
进程和线程(<u>Processes
and Threads</u>) 。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>广播接收器(Broadcast receivers)</b></p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 广播接收器是一个专注于接收广播通知信息，并做出对应处理的组件。很多广播是源自于系统代码的──比如，通知时区改变、电池电量低、拍摄了一张照片或者用户改变了语言选项。应用程序也可以进行广播──比如说，通知其它应用程序一些数据下载完成并处于可用状态。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 应用程序可以拥有任意数量的广播接收器以对所有它感兴趣的通知信息予以响应。所有的接收器均继承自BroadcastReceiver基类。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 广播接收器没有用户界面。然而，它们可以启动一个activity来响应它们收到的信息，或者用NotificationManager来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>内容提供者(Content providers)</b></p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 内容提供者将一些特定的应用程序数据供给其它应用程序使用。数据可以存储于文件系统、SQLite数据库或其它方式。内容提供者继承于ContentProvider
基类，为其它应用程序取用和存储它管理的数据实现了一套标准方法。然而，应用程序并不直接调用这些方法，而是使用一个
ContentResolver
对象，调用它的方法作为替代。ContentResolver可以与任意内容提供者进行会话，与其合作来对所有相关交互通讯进行管理。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 参阅独立的内容提供者Content
Providers 章节获得更多关于使用内容提供者的内容。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 每当出现一个需要被特定组件处理的请求时，Android会确保那个组件的应用程序进程处于运行状态，或在必要的时候启动它。并确保那个相应组件的实例的存在，必要时会创建那个实例。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>激活组件</b><b>Activating components: intents</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当接收到ContentResolver发出的请求后，内容提供者被激活。而其它三种组件──activity、服务和广播接收器被一种叫做intent的异步消息所激活。intent是一个保存着消息内容的Intent对 象。对于activity和服务来说，它指明了请求的操作名称以及作为操作对象的数据的URI和其它一些信息。比如说，它可以承载对一个activity 的请求，让它为用户显示一张图片，或者让用户编辑一些文本。而对于广播接收器而言，Intent对象指明了声明的行为。比如，它可以对所有感兴趣的对象声
明照相按钮被按下。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于每种组件来说，激活的方法是不同的：</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 通过传递一个Intent对象至 <code>Context.startActivity()</code>或<code>Activity.startActivityForResult()</code>以载入（或指定新工作给）一个activity。相应的activity可以通过调用 <code>getIntent()</code> 方法来查看激活它的intent。Android通过调用activity的<code>onNewIntent()</code>方法来传递给它继发的intent。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>一个activity经常启动了下一个。如果它期望它所启动的那个activity返回一个结果，它会以调用startActivityForResult()<code>来取代</code>startActivity()<code>。比如说，如果它启动了另外一个</code>activity<code>以使用户挑选一张照片，它也许想知道哪张照片被选中了。结果将会被封装在一个</code>Intent<code>对象中，并传递给发出调用的</code>activity<code>的onActivityResult()</code> 方法。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 通过传递一个Intent对象至<code>Context.startService()</code>将启动一个服务（或给予正在运行的服务以一个新的指令）。Android调用服务的 <code>onStart()</code>方法并将Intent对象传递给它。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>与此类似，一个Intent可以被调用组件传递给 <code>Context.bindService()</code>以获取一个正在运行的目标服务的连接。这个服务会经由<code>onBind()</code> 方法的调用获取这个Intent对象（如果服务尚未启动，bindService()<code>会先启动它</code>）。比如说，一个activity可以连接至前述的音乐回放服务，并提供给用户一个可操作的（用户界面）以对回放进行控制。这个activity可以调用 bindService() 来建立连接，然后调用服务中定义的对象来影响回放。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>后面一节：远程方法调用(Remote
procedure calls)将更详细的阐明如何绑定至服务。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 应用程序可以凭借将Intent对象传递给 <code>Context.sendBroadcast()</code> ，<code>Context.sendOrderedBroadcast()</code>， 以及<code>Context.sendStickyBroadcast()</code>和其它类似方法来产生一个广播。Android会调用所有对此广播有兴趣的广播接收器的 <code>onReceive()</code>方法，将intent传递给它们。</p>

<p class=MsoNormal align=left style='margin-left:21.0pt;text-align:left'>欲了解更多intent消息的信息，请参阅独立章节 Intent和Intent滤过器(<u>Intents
and Intent Filters</u>)。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>关闭组件</b><b>(Shutting down components)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内容提供者仅在响应ContentResolver提出请求的时候激活。而一个广播接收器仅在响应广播信息的时候激活。所以，没有必要去显式的关闭这些组件。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 而activity则不同，它提供了用户界面，并与用户进行会话。所以只要会话依然持续，哪怕对话过程暂时停顿，它都会一直保持激活状态。与此相似，服务也会在很长一段时间内保持运行。所以Android为关闭activity和服务提供了一系列的方法。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 可以通过调用它的<code>finish()</code>方法来关闭一个activity。一个activity可以通过调用另外一个activity（它用startActivityForResult() <code>启动</code>的）的<code>finishActivity()</code>方法来关闭它。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 服务可以通过调用它的<code>stopSelf()</code>方法来停止，或者调用 <code>Context.stopService()</code>。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>系统也会在组件不再被使用的时候或者Android需要为活动组件声明更多内存的时候关闭它。后面的&lt;activity&gt;</code>元素的name属性指定了实现了这个activity的 Activity的子类。icon和label属性指向了包含展示给用户的此activity的图标和标签的资源文件。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其它组件也以类似的方法声明──<code>&lt;service&gt;</code> 元素用于声明服务， <code>&lt;receiver&gt;</code> 元素用于声明广播接收器，而 <code>&lt;provider&gt;</code> 元素用于声明内容提供者。 manifest文件中未进行声明的activity、服务以及内容提供者将不为系统所见，从而也就不会被运行。然而，广播接收器既可以在manifest文件中声明，也可以在代码中进行动态的创建，并以调用<code>Context.registerReceiver()</code>的方式注册至系统。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 欲更多了解如何为你的应用程序构建manifest文件，请参阅AndroidManifest.xml文件一章。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>Intent</b><b>过滤器</b><b>(Intent
filters)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Intent对象可以被显式的指定目标组件。如果进行了这种指定，Android会找到这个组件（依据manifest文件中的声明）并激活它。但如果 Intent没有进行显式的指定，Android就必须为它找到对于intent来说最合适的组件。这个过程是通过比较Intent对象和所有可能对象的intent过滤器完成的。组件的intent过滤器会告知Android它所能处理的intent类型。如同其它相对于组件很重要的信息一样，这些是在manifest文件中进行声明的。这里是上面实例的一个扩展，其中加入了针对activity的两个intent过滤器声明：</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'><img border=0 width=548 height=325
src="images/image008.png"></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>示例中的第一个过滤器──action “android.intent.action.MAIN”和类别“android.intent.category.LAUNCHER”的组合──是通常具有的。它标明了这个activity将在应用程序加载器中显示，就是用户在设备上看到的可供加载的应用程序列表。换句话说，这个activity是应用程序的入口，是用户选择运行这个应用程序后所见到的第一个activity。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第二个过滤器声明了这个activity能被赋予一种特定类型的数据。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 组件可以拥有任意数量的intent过滤器，每个都会声明一系列不同的能力。如果它没有包含任何过滤器，它将只能被显式声明了目标组件名称的intent激活。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于在代码中创建并注册的广播接收器来说，intent过滤器将被直接以 IntentFilter对象实例化。其它过滤器则在manifest文件中设置。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 欲获得更多intent过滤器的信息，请参阅独立章节： Intent和Intent过滤器。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=center style='text-align:center'><b>Activity</b><b>和任务</b><b>(Activities
and Tasks)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如前所述，一个activity可以启动另外一个，甚至包括与它不处于同一应用程序之中的。举个例子说，假设你想让用户看到某个地方的街道地图。而已经存
在一个具有此功能的activity了，那么你的activity所需要做的工作就是把请求信息放到一个Intent对象里面，并把它传递给startActivity()。于是地图浏览器就会显示那个地图。而当用户按下BACK键的时候，你的activity又会再一次的显示在屏幕上。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于用户来说，这看起来就像是地图浏览器是你activity所在的应用程序中的一个组成部分，其实它是在另外一个应用程序中定义，并运行在那个应用程序的进程之中的。Android将这两个activity放在同一个任务中 来维持一个完整的用户体验。简单的说，任务就是用户所体验到的“应用程序”。它是安排在一个堆栈中的一组相关的activity。堆栈中的根 activity就是启动了这整个任务的那个──一般情况下，它就是用户在应用程序加载器中所选择的。而堆栈最上方的activity则是当前运行的── 用户直接对其进行操作的。当一个activity启动另外一个的时候，新的activity就被压入堆栈，并成为当前运行的activity。而前一个 activity仍保持在堆栈之中。当用户按下BACK键的时候，当前activity出栈，而前一个恢复为当前运行的activity。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆栈中保存的其实是对象，所以如果发生了诸如需要多个地图浏览器的情况，就会使得一个任务中出现多个同一Activity子类的实例同时存在，堆栈会为每个实例单独开辟一个入口。堆栈中的Activity永远不会重排，只会压入或弹出。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 任务其实就是activity的堆栈，而不是manifest文件中的一个类或者元素。所以你无法撇开activity而为一个任务设置一个值。而事实上 整个任务使用的值是在根activity中设置的。比如说，下一节我们会谈及“任务的affinity”，从affinity中读出的值将会设置到任务的 根activity之中。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 任务中的所有activity是作为一个整体进行移动的。整个的任务（即activity堆栈）可以移到前台，或退至后台。举个例子说，比如当前任务在堆 栈中存有四个activity──三个在当前activity之下。当用户按下HOME键的时候，回到了应用程序加载器，然后选择了一个新的应用程序（也
就是一个新<em>任务</em>）。则当前任务遁入后台，而新任务的根activity显示出来。然后，过了一小会儿，用户再次回到了应用程序加载器而又选择了前一个应用程序（上一个任务）。于是那个任务，带着它堆栈中所有的四个activity，再一次的到了前台。<em>当用户</em><em>按下</em><em>BACK</em><em>键的时候，屏幕不会显示出用户刚才离开的</em><em>activity</em><em>（上一个任务的根</em><em>activity</em><em>）。取而代之，当前任务的堆栈中最上面的</em><em>activity</em><em>被弹出，而同一任务中的上一个</em><em>activity</em><em>显示了出来。</em></p>

<p class=MsoNormal align=left style='text-align:left'><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </em>上述的种种即是activity和任务的默认行为模式。但是有一些方法可以改变所有这一切。activity和任务的联系、任务中activity的行为 方式都被启动那个activity的Intent对象中设置的一系列标记和manifest文件中那个activity中的<code>&lt;activity&gt;</code>元素的系列属性之间的交互所控制。无论是请求发出者和回应者在这里都拥有话语权。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们刚才所说的这些关键Intent标记如下：</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLAG_ACTIVITY_NEW_TASK</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>FLAG_ACTIVITY_CLEAR_TOP</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>FLAG_ACTIVITY_SINGLE_TOP</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 而关键的&lt;activity&gt;属性是：</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; taskAffinity</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>launchMode</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>allowTaskReparenting</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>clearTaskOnLaunch</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>alwaysRetainTaskState</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>finishOnTaskLaunch</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来的一节会描述这些标记以及属性的作用，它们是如何互相影响的，以及控制它们的使用时必须考虑到的因素。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>任务共用性和新任务</b><b>Affinities and new tasks</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 默认情况下，一个应用程序中的activity相互之间会有一种Affinity──也就是说，它们首选都归属于一个任务。然而，可以在<code>&lt;</code>activity<code>&gt;</code><code>元素中把每个</code>activity<code>的</code>taskAffinity属
性设置为一个独立的affinity。于是在不同的应用程序中定义的activity可以享有同一个affinity，或者在同一个应用程序中定义的 activity有着不同的affinity。affinity在两种情况下生效：当加载activity的Intent对象包含了FLAG_ACTIVITY_NEW_TASK 标记，或者当activity的allowTaskReparenting属性设置为“true”。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>FLAG_ACTIVITY_NEW_TASK</code>标记</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如前所述，在默认情况下，一个新activity被另外一个调用了startActivity()方法的activity载入了任务之中。并压入了调用者所在的堆栈。然而，如果传递给startActivity()的Intent对象包含了FLAG_ACTIVITY_NEW_TASK标记，系统会为新activity安排另外一个任务。一般情况下，如同标记所暗示的那样，这会是一个新任务。然而，这并不是必然的。如果已经存在了一个与新activity有着同样affinity的任务，则activity会载入那个任务之中。如果没有，则启用新任务。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>allowTaskReparenting</code> 属性</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果一个activity将allowTaskReparenting属 性设置为“true”。它就可以从初始的任务中转移到与其拥有同一个affinity并转向前台的任务之中。比如说，一个旅行应用程序中包含的预报所选城 市的天气情况的activity。它与这个应用程序中其它的activity拥有同样的affinity（默认的affinity）而且允许重定父级。你 的另一个activity启动了天气预报，于是它就会与这个activity共处与同一任务之中。然而，当那个旅行应用程序再次回到前台的时候，这个天气
预报activity就会被再次安排到原先的任务之中并显示出来。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果在用户的角度看来，一个.apk文件中包含了多于一个的“应用程序”，你可能会想要为它们所辖的activity安排不一样的affinity。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>加载模式</b><b>(Launch modes)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;activity&gt;元素的<code>launchMode</code>属性可以设置四种不同的加载模式：</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>&quot;standard&quot; (默认模式)</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>&quot;singleTop&quot;</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>&quot;singleTask&quot;</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>&quot;singleInstance&quot;</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这些模式之间的差异主要体现在四个方面：</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; <strong>哪个任务会把持对</strong><strong>intent</strong><strong>做出响应的</strong><strong>activity</strong><strong>。</strong>对“standard”和“singleTop”模式而言，是产生intent（并调用 <code>startActivity()</code>）的任务──除非Intent对象包含<code>FLAG_ACTIVITY_NEW_TASK</code>标记。而在这种情况下，如同上面Affinitie和新任务一节所述，会是另外一个任务。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>相反，对“<code>singleTask</code>”和“<code>singleInstance</code>”模式而言，activity总是位于任务的根部。正是它们定义了一个任务，所以它们绝不会被载入到其它任务之中。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; <strong>activity</strong><strong>是否可以存在多个实例。</strong>一个“standard”或“singleTop”的activity可以被多次初始化。它们可以归属于多个任务，而一个任务也可以拥有同一activity的多个实例。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>相反，对“singleTask”和“singleInstance”的activity被限定于只能有一个实例。因为这些activity都是任务的起源，这种限制意味着在一个设备中同一时间只允许存在一个任务的实例。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; <strong>在实例所在的任务中是否会有别的</strong><strong>activity</strong><strong>。</strong>一个“singleInstance”模式的activity将会是它所在的任务中唯一的activity。如果它启动了别的activity，那个activity将会依据它自己的加载模式加载到其它的任务中去──如同在intent中设置了FLAG_ACTIVITY_NEW_TASK 标记一样的效果。在其它方面，“singleInstance”模式的效果与“singleTask”是一样的。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>剩下的三种模式允许一个任务中出现多个activity。“singleTask”模式的activity将是任务的根activity，但它可以启动别的activity并将它们置入所在的任务中。“standard”和“singleTop”activity则可以在堆栈的任意位置出现。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; <strong>是否要载入新的类实例以处理新的</strong><strong>intent</strong><strong>。</strong>对默认的&quot;standard&quot;模式来说，对于每个新intent都会创建一个新的实例以进行响应，每个实例仅处理一个intent。“singleTop”模式下，如果activity位于目的任务堆栈的最上面，则重用目前现存的activity来处理新的intent。如果它不是在堆栈顶部，则不会发生重用。而是创建一个新实例来处理新的intent并将其推入堆栈。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>举例来说，假设一个任务的堆栈由根activityA和activity B、C和位于堆栈顶部的D组成，即堆栈A-B-C-D。一个针对D类型的activity的intent抵达的时候，如果D是默认的“standard”加载模式，则创建并加载一个新的类实例，于是堆栈变为A-B-C-D-D。 然而，如果D的载入模式为“singleTop”，则现有的实例会对新intent进行处理（因为它位于堆栈顶部）而堆栈保持A-B-C-D的形态。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>换言之，如果新抵达的intent是针对B类型的activity，则无论B的模式是“standard”还是“singleTop” ，都会加载一个新的B的实例（因为B不位于堆栈的顶部），而堆栈的顺序变为A-B-C-D-B。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>如前所述，“singleTask”或“singleInstance”模式的activity永远不会存在多于一个实例。所以实例将处理所有新的intent。一个“singleInstance”模式的activity永远保持在堆栈的顶部（因为它是那个堆栈中唯一的一个activity），所以它一直坚守在处理intent的岗位上。然而，对一个“singleTask”模式的activity来说，它上面可能有，也可能没有别的activity和它处于同一堆栈。<code>在有的情况下，它就不在能够处理</code>intent<code>的位置上，</code><em>则那个</em><em>intent</em><em>将被舍弃</em><i>。</i>（即便在intent被舍弃的情况下，它的抵达仍将使这个任务切换至前台，并一直保留）</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当一个现存的activity被要求处理一个新的intent的时候，会调用<code>onNewIntent()</code>方法来将intent对象传递至activity。（启动activity的原始intent对象可以通过调用<code>getIntent()</code>方法获得。）</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 请注意，当一个新的activity实例被创建以处理新的intent的时候，用户总可以按下BACK键来回到前面的状态（回到前一个 activity）。但当使用现存的activity来处理新intent的时候，用户是不能靠按下BACK键回到当这个新intent抵达之前的状态 的。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 想获得更多关于加载模式的内容，请参阅 <code>&lt;activity&gt;</code> 元素的描述。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>清理堆栈</b><b>(Clearing the stack)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果用户离开一个任务很长一段时间，系统会清理该任务中除了根activity之外的所有activity。当用户再次回到这个任务的时候，除了只剩下初 始化activity尚存之外，其余都跟用户上次离开它的时候一样。这样做的原因是：在一段时间之后，用户再次回到一个任务的时候，他们更期望放弃他们之
前的所作所为，做些新的事情。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这些属于默认行为，另外，也存在一些activity的属性用以控制并改变这些行为：</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>alwaysRetainTaskState</code> 属性</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果一个任务的根activity中此属性设置为“true”，则上述默认行为不会发生。任务将在很长的一段时间内保留它堆栈内的所有activity。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>clearTaskOnLaunch</code>属性</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果一个任务的根activity中此属性设置为“true”，则每当用户离开这个任务和返回它的时候，堆栈都会被清空至只留下rootactivity。换句话说，这是alwaysRetainTaskState的另一个极端。哪怕仅是过了一小会儿，用户回到任务时，也是见到它的初始状态。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>finishOnTaskLaunch</code>属性</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个属性与clearTaskOnLaunch属性相似，但它仅作用于单个的activity，而不是整个的task。而且它可以使任意activity都被清理，甚至根activity也不例外。当它设置为“true”的时候，此activity仅做为任务的一部分存在于当前回话中，一旦用户离开并再次回到这个任务，此activity将不复存在。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 此外，还有别的方式从堆栈中移除一个activity。如果一个intent对象包含<code>FLAG_ACTIVITY_CLEAR_TOP</code>标记，而且目标任务的堆栈中已经存在了一个能够响应此intent的activity类型的实例。则这个实例之上的所有activity都将被清理以使它位于堆栈的顶部来对intent做出响应。如果此时指定的activity的加载模式为“standard”，则它本身也会从堆栈中移除，并加载一个新的实例来处理到来的intent。这是因为加载模式为“standard”的activity总会创建一个新实例来处理新的intent。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FLAG_ACTIVITY_CLEAR_TOP与FLAG_ACTIVITY_NEW_TASK经常合并使用。这时，这些标记提供了一种定位其它任务中现存的activity并将它们置于可以对intent做出响应的位置的方法。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>启动任务</b><b>(Starting tasks)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当一个activity被指定一个“android.intent.action.MAIN”做为动作，以及“android.intent.category.LAUNCHER”做为类别的intent过滤器之后（在前述intent过滤器一节中已经有了这个示例），它就被设置为一个任务的入口点。这样的过滤器设置会在应用程序加载器中为此activity显示一个图标和标签，以供用户加载任务或加载之后在任意时间回到这个任务。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 第二个能力相当重要：用户必须可以离开一个任务，并在一段时间后返回它。出于这个考虑，加载模式被设定为“singleTask”和“singleInstance”的activity总是会初始化一个新任务，这样的activity仅能用于指定了一个MAIN和LAUNCHER过滤器的情况之下。我们来举例说明如果没指定过滤器的情况下会发生的事情：一个intent加载了一个“singleTask”的activity，初始化了一个新任务，用户在这个任务中花费了一些时间来完成工作。然后用户按下了HOME键。于是任务被要求转至后台并被主屏幕所掩盖。因为它并没有在应用程序加载器中显示图标，这将导致用户无法再返回它。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类似的困境也可由FLAG_ACTIVITY_NEW_TASK标记引起。如果此标记使一个activity启动了一个新任务继而用户按下了HOME键离开了它，则用户必须要有一些方法再次回到这个任务。一些实体（诸如通知管理器）总是在另外的任务中启动新activity，而不是做为它们自己的一部分，所以它们总是将FLAG_ACTIVITY_NEW_TASK标记包含在intent里面并传递给startActivity()。如果你写了一个能被外部实体使用这个标记调用的activity，你必须注意要给用户留一个返回这个被外部实体启动的任务的方法。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当你不想让用户再次返回一个activity的情况下，可以将 <code>&lt;</code>activity<code>&gt;</code> 元素的 finishOnTaskLaunch设置为“true”。参见前述View.onKeyDown()</code>这样报告用户动作以及后面 线程一节所叙述的那样，为这些长时间操作衍生出一个单独的线程进行处理。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在可用内存不足而又有一个正在为用户进行服务的进程需要更多内存的时候，Android有时候可能会关闭一个进程。而在这个进程中运行着的应用程序也因此被销毁。当再次出现需要它们进行处理的工作的时候，会为这些组件重新创建进程。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在决定结束哪个进程的时候，Android会衡量它们对于用户的相对重要性。比如说，相对于一个仍有用户可见的activity的进程，它更有可能去关闭 一个其activity已经不为用户所见的进程。也可以说，决定是否关闭一个进程主要依据在那个进程中运行的组件的状态。这些状态将在后续的一节Thread对象创建的。Android提供了很多便于管理线程的类： Looper用于在一个线程中运行一个消息循环， Handler用于处理消息，HandlerThread
用于使用一个消息循环启用一个线程。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>远程方法调用</b><b>(Remote procedure calls)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Android有一个轻量级的远程方法调用（RPC）机制：即在本地调用一个方法，但在远程（其它的进程中）进行处理，然后将结果返回调用者。这将方法调用及其附属的数据以系统可以理解的方式进行分离，并将其从本地进程和本地地址空间传送至远程过程和远程地址空间，并在那里重新装配并对调用做出反应。返回
的结果将以相反的方向进行传递。Android提供了完成这些工作所需的所有的代码，以使你可以集中精力来实现RPC接口本身。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RPC接口可以只包括方法。即便没有返回值，所有方法仍以同步的方式执行（本地方法阻塞直至远程方法结束）。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简单的说，这套机制是这样工作的：一开始，你用简单的IDL（界面描绘语言）声明一个你想要实现的RPC接口。然后用 <code>aidl</code> 工具为这个声明生成一个Java接口定义，这个定义必须对本地和远程进程都可见。它包含两个内部类，如下图所示：</p>

<p class=MsoNormal align=left style='text-align:left'><img
border=0 width=553 height=428
src="images/image009.jpg"></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内部类中有管理实现了你用IDL声明的接口的远程方法调用所需要的所有代码。两个内部类均实现了 IBinder接口。一个用于系统在本地内部使用，你些的代码可以忽略它；另外一个，我们称为Stub，扩展了Binder类。除了实现了IPC调用的内部代码之外，它还包括了你声明的RPC接口中的方法的声明。你应该如上图所示的那样写一个Stub的子类来实现这些方法。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一般情况下，远程过程是被一个服务所管理的（因为服务可以通知系统关于进程以及它连接到别的进程的信息）。它包含着
aidl工具产生的接口文件和实现了RPC方法的Stub的子类。而客户端只需要包括aidl工具产生的接口文件。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下面将说明服务与其客户端之间的连接是如何建立的：</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 服务的客户端（位于本地）应该实现 <code>onServiceConnected()</code> 和 <code>onServiceDisconnected()</code> 方法。这样，当至远程服务的连接成功建立或者断开的时候，它们会收到通知。这样它们就可以调用
<code>bindService()</code> 来设置连接。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 而服务则应该实现 <code>onBind()</code> 方法以接受或拒绝连接。这取决于它收到的intent（intent将传递给bindService()）。如果接受了连接，它会返回一个Stub的子类的实例。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 如果服务接受了连接，Android将会调用客户端的onServiceConnected() 方法，并传递给它一个IBinder对象，它是由服务所管理的Stub的子类的代理。通过这个代理，客户端可以对远程服务进行调用。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>线程安全方法</b><b>(Thread-safe methods)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在一些情况下，你所实现的方法有可能会被多于一个的线程所调用，所以它们必须被写成线程安全的。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于我们上一节所讨论的RPC机制中的可以被远程调用的方法来说，这是必须首先考虑的。如果针对一个IBinder对象中实现的方法的调用源自这个 IBinder对象所在的进程时，这个方法将会在调用者的线程中执行。然而，如果这个调用源自其它的进程，则这个方法将会在一个线程池中选出的线程中运
行，这个线程池由Android加以管理，并与IBinder存在于同一进程内；这个方法不会在进程的主线程内执行。反过来说，一个服务的 onBind()
方法应为服务进程的主线程所调用，而实现了由 onBind()
返回的对象（比如说，一个实现了RPC方法的Stub的子类）的方法将为池中的线程所调用。因为服务可以拥有多于一个的客户端，而同一时间，也会有多个池中的线程调用同一个IBinder方法。因此IBinder方法必须实现为线程安全的。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 类似的，一个内容提供者能接受源自其它进程的请求数据。尽管ContentResolver和ContentProvider类隐藏了交互沟通过程的管理细节，ContentProvider会由<code>query()</code>， <code>insert()</code>， <code>delete()</code>， <code>update()</code>和<code>getType()</code>方法来相应这些请求，而这些方法也都是由那个内容提供者的进程中所包涵的线程池提供的，而不是进程的主线程本身。所以这些有可能在同一时间被很多线程调用的方法也必须被实现为线程安全的。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=center style='text-align:center'><a
name=ComponentLifecycles><b>组件生命周期</b></a><b>(Component Lifecycles)</b></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>应用程序组件有其生命周期──由Android初始化它们以相应intent直到这个实例被摧毁。在此之间，它们有时是激活的有时则相反。或者，如果它是 一个activity，则是可为用户所见或者不能。这一节讨论了activity、服务以及广播接收器的生命周期，包括它们在生命周期中的状态、在状态之 间<em>转变</em>时通知你的方法、以及当这些进程被关闭或实例被摧毁时，这些状态产生的效果。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>Activity</b><b>生命周期</b><b>(Activity
lifecycle)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个activity主要有三个状态：</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 当在屏幕前台时（位于当前任务堆栈的顶部），它是<em>活跃</em>或<em>运行</em>的状态。它就是相应用户操作的activity。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 当它失去焦点但仍然对用户可见时，它处于<em>暂停</em>状态。即是：在它之上有另外一个activity。这个activity也许是透明的，或者未能完全遮蔽全屏，所以被暂停的activity仍对用户可见。<em>暂停的</em><em>activity</em><em>仍然是存活状态</em>（它保留着所有的状态和成员信息并连接至窗口管理器），但当系统处于极低内存的情况下，仍然可以杀死这个activity。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 如果它完全被另一个activity覆盖是，它处于<em>停止</em>状态。它仍然保留所有的状态和成员信息。然而它不在为用户可见，所以它的窗口将被隐藏，如果其它地方需要内存，则系统经常会杀死这个activity。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>如果一个activity处于暂停或停止状态，系统可以通过要求它结束（调用它的 finish()
方法）或直接杀死它的进程来将它驱出内存。当它再次为用户可见的时候，它只能完全重新启动并恢复至以前的状态。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>当一个activity从这个状态转变到另一个状态时，它被以下列protected方法所通知：</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void onCreate(Bundle savedInstanceState)</p>

<p class=MsoNormal align=left style='margin-left:21.0pt;text-align:left;
text-indent:21.0pt'>void onStart()</p>

<p class=MsoNormal align=left style='margin-left:21.0pt;text-align:left;
text-indent:21.0pt'>void onRestart()</p>

<p class=MsoNormal align=left style='margin-left:21.0pt;text-align:left;
text-indent:21.0pt'>void onResume()</p>

<p class=MsoNormal align=left style='margin-left:21.0pt;text-align:left;
text-indent:21.0pt'>void onPause()</p>

<p class=MsoNormal align=left style='margin-left:21.0pt;text-align:left;
text-indent:21.0pt'>void onStop()</p>

<p class=MsoNormal align=left style='margin-left:21.0pt;text-align:left;
text-indent:21.0pt'>void onDestroy()</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 你可以重载所有这些方法以在状态改变时进行合适的工作。所有的activity都必须实现 <code>onCreate()</code> 用以当对象第一次实例化时进行初始化设置。很多activity会实现 <code>onPause()</code>以提交数据变化或准备停止与用户的交互。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>调用父类</b><b>(Calling into the superclass)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所有activity生命周期方法的实现都必须先调用其父类的版本。比如说：</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img
border=0 width=273 height=79
src="images/image010.png"></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 总得来说，这七个方法定义了一个activity完整的生命周期。实现这些方法可以帮助你监察三个嵌套的生命周期循环：</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 一个activity <strong>完整的生命周期</strong> 自第一次调用
onCreate()开始，直至调用onDestroy()为止。activity在onCreate()中设置所有“全局”状态以完成初始化，而在onDestroy()中释放所有系统资源。比如说，如果activity有一个线程在后台运行以从网络上下载数据，它会以 onCreate()<code>创建那个线程，而以</code> onDestroy()销毁那个线程。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 一个activity的 <strong>可视生命周期</strong>自 onStart() 调用开始直到相应的 onStop()调用。在此期间，用户可以在屏幕上看到此activity，尽管它也许并不是位于前台或者正在与用户做交互。在这两个方法中，你可以管控用来向用户显示这个activity的资源。比如说，你可以在onStart()
中注册一个BroadcastReceiver
来监控会影响到你UI的改变，而在onStop() 中来取消注册，这时用户是无法看到你的程序显示的内容的。onStart() 和 onStop() 方法可以随着应用程序是否为用户可见而被多次调用。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 一个activity的 <strong>前台生命周期</strong>
自 onResume() 调用起，至相应的 onPause()调用为止。在此期间，activity位于前台最上面并与用户进行交互。activity会经常在暂停和恢复之间进行状态转换──比如说当设备转入休眠状态或有新的activity启动时，将调用onPause() 方法。当activity获得结果或者接收到新的intent的时候会调用onResume() 方法。因此，在这两个方法中的代码应当是轻量级的。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>下图展示了上述循环过程以及activity在这个过程之中历经的状态改变。着色的椭圆是activity可以经历的主要状态。矩形框代表了当activity在状态间发生改变的时候，你进行操作所要实现的回调方法。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'><img border=0 width=554 height=722
src="images/image011.png"></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下表详细描述了这些方法，并在activity的整个生命周期中定位了它们。</p>

<table class=MsoNormalTable border=1 cellspacing=0 cellpadding=0 width=539
 style='margin-left:26.7pt;border-collapse:collapse;border:none'>
 <tr>
  <td width=94 valign=top style='width:70.85pt;border:solid black 1.0pt;
  border-right:solid windowtext 1.0pt;background:#DEE8F1;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>方法</p>
  </td>
  <td width=255 valign=top style='width:191.35pt;border:solid black 1.0pt;
  border-left:none;background:#DEE8F1;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>描述</p>
  </td>
  <td width=95 valign=top style='width:70.9pt;border-top:solid black 1.0pt;
  border-left:none;border-bottom:solid black 1.0pt;border-right:solid windowtext 1.0pt;
  background:#DEE8F1;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>是否可被杀死(Killable?)</p>
  </td>
  <td width=94 valign=top style='width:70.85pt;border:solid black 1.0pt;
  border-left:none;background:#DEE8F1;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>下一个</p>
  </td>
 </tr>
 <tr>
  <td width=94 style='width:70.85pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><code>onCreate()</code></p>
  </td>
  <td width=255 style='width:191.35pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='text-align:left'>在activity第一次被创建的时候调用。这里是你做所有初始化设置的地方──创建视图、绑定数据至列表等。如果曾经有状态记录（参阅后述Saving
  Activity State。），则调用此方法时会传入一个包含着此activity以前状态的包对象做为参数。</p>
  <p class=MsoNormal align=left style='text-align:left'>接下来始终遵循调用onStart()。</p>
  </td>
  <td width=95 style='width:70.9pt;border-top:none;border-left:none;border-bottom:
  solid black 1.0pt;border-right:solid windowtext 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>否</p>
  </td>
  <td width=94 style='width:70.85pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>onStart()</p>
  </td>
 </tr>
 <tr>
  <td width=94 style='width:70.85pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><code>onRestart()</code></p>
  </td>
  <td width=255 style='width:191.35pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='text-align:left'>在activity停止后，在再次启动之前被调用。</p>
  <p class=MsoNormal align=left style='text-align:left'>接下来始终遵循调用onStart()。</p>
  </td>
  <td width=95 style='width:70.9pt;border-top:none;border-left:none;border-bottom:
  solid black 1.0pt;border-right:solid windowtext 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>否</p>
  </td>
  <td width=94 style='width:70.85pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>onStart()</p>
  </td>
 </tr>
 <tr>
  <td width=94 style='width:70.85pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><code>onStart()</code></p>
  </td>
  <td width=255 style='width:191.35pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='text-align:left'>当activity正要变得为用户所见时被调用。</p>
  <p class=MsoNormal align=left style='text-align:left'>当activity转向前台时接下来调用onResume()，在activity变为隐藏时接下来调用onStop()。</p>
  </td>
  <td width=95 style='width:70.9pt;border-top:none;border-left:none;border-bottom:
  solid black 1.0pt;border-right:solid windowtext 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>否</p>
  </td>
  <td width=94 style='width:70.85pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>onResume() </p>
  <p class=MsoNormal align=center style='text-align:center'>或</p>
  <p class=MsoNormal align=center style='text-align:center'>onStop()</p>
  </td>
 </tr>
 <tr>
  <td width=94 style='width:70.85pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><code>onResume()</code></p>
  </td>
  <td width=255 style='width:191.35pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='text-align:left'>在activity开始与用户进行交互之前被调用。此时activity位于堆栈顶部，并接受用户输入。</p>
  <p class=MsoNormal align=left style='text-align:left'>接下来始终遵循调用onPause()。</p>
  </td>
  <td width=95 style='width:70.9pt;border-top:none;border-left:none;border-bottom:
  solid black 1.0pt;border-right:solid windowtext 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>否</p>
  </td>
  <td width=94 style='width:70.85pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=y2><code>onPause()</code></p>
  </td>
 </tr>
 <tr>
  <td width=94 style='width:70.85pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><code>onPause()</code></p>
  </td>
  <td width=255 style='width:191.35pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='text-align:left'>当系统将要启动另一个activity时调用。此方法主要用来将未保存的变化进行持久化，停止类似动画这样耗费CPU的动作等。这一切动作应该在短时间内完成，因为下一个activity必须等到此方法返回后才会继续。</p>
  <p class=MsoNormal align=left style='text-align:left'>当activity重新回到前台时接下来调用onResume()。当activity变为用户不可见时接下来调用onStop()。</p>
  </td>
  <td width=95 style='width:70.9pt;border-top:none;border-left:none;border-bottom:
  solid black 1.0pt;border-right:solid windowtext 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>是</p>
  </td>
  <td width=94 style='width:70.85pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>onResume() </p>
  <p class=MsoNormal align=center style='text-align:center'>或</p>
  <p class=MsoNormal align=center style='text-align:center'>onStop()</p>
  </td>
 </tr>
 <tr>
  <td width=94 style='width:70.85pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><code>onStop()</code></p>
  </td>
  <td width=255 style='width:191.35pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='text-align:left'>当activity不再为用户可见时调用此方法。这可能发生在它被销毁或者另一个activity（可能是现存的或者是新的）回到运行状态并覆盖了它。</p>
  <p class=MsoNormal align=left style='text-align:left'>如果activity再次回到前台跟用户交互则接下来调用onRestart()，如果关闭activity则接下来调用onDestroy()。</p>
  </td>
  <td width=95 style='width:70.9pt;border-top:none;border-left:none;border-bottom:
  solid black 1.0pt;border-right:solid windowtext 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>是</p>
  </td>
  <td width=94 style='width:70.85pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>onRestart() </p>
  <p class=MsoNormal align=center style='text-align:center'>or</p>
  <p class=MsoNormal align=center style='text-align:center'>onDestroy()</p>
  </td>
 </tr>
 <tr>
  <td width=94 style='width:70.85pt;border-top:none;border-left:solid black 1.0pt;
  border-bottom:solid black 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'><code>onDestroy()</code></p>
  </td>
  <td width=255 style='width:191.35pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='text-align:left'>在activity销毁前调用。这是activity接收的最后一个调用。这可能发生在activity结束（调用了它的 <code>finish()</code> 方法）或者因为系统需要空间所以临时的销毁了此acitivity的实例时。你可以用<code>isFinishing()</code> 方法来区分这两种情况。</p>
  </td>
  <td width=95 style='width:70.9pt;border-top:none;border-left:none;border-bottom:
  solid black 1.0pt;border-right:solid windowtext 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>是</p>
  </td>
  <td width=94 style='width:70.85pt;border-top:none;border-left:none;
  border-bottom:solid black 1.0pt;border-right:solid black 1.0pt;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=center style='text-align:center'>无</p>
  </td>
 </tr>
</table>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 请注意上表中<strong>可被杀死</strong>一列。它标示了<em>在方法返回后，还没执行</em><em>activity</em><em>的其余代码的任意时间</em>里，系统是否可以杀死包含此activity的进程。三个方法（onPause()、 onStop()<code>和</code>onDestroy()）被标记为“是”。onPause()是三个中的第一个，它也是唯一一个在进程被杀死之前必然会调用的方法──onStop() 和 onDestroy() 有可能不被执行。因此你应该用 onPause() 来将所有持久性数据（比如用户的编辑结果）写入存储之中。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在<strong>可被杀死</strong>一列中标记为“否”的方法在它们被调用时将保护activity所在的进程不会被杀死。所以只有在onPause()<code>方法返回后到</code>onResume() 方法被调用时，一个activity才处于可被杀死的状态。在onPause()<code>再次被调用并返回之前，它不会被系统杀死。</code></p>

<p class=MsoNormal align=left style='text-align:left'><code>&nbsp;&nbsp;&nbsp; </code>如后面一节进程和生命周期所述，即使是在这里技术上没有被定义为“可杀死”的activity仍然有可能被系统杀死──但这仅会发生在实在没有其它方法的极端情况之下。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>保存</b><b>activity</b><b>状态</b><b>(Saving
activity state)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当系统而不是用户自己出于回收内存的考虑，关闭了一个activity之后。用户会期望当他再次回到那个activity的时候，它仍保持着上次离开时的样子。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为了获取activity被杀死前的状态，你应该为activity实现<code>onSaveInstanceState()</code> 方法。Android在activity有可能被销毁之前（即onPause() 调用之前）会调用此方法。它会将一个以名称-值对方式记录了activity动态状态的Bundle
对象传递给该方法。当activity再次启动时，这个Bundle会传递给onCreate()方法和随着onStart()方法调用的<code>onRestoreInstanceState()</code>，所以它们两个都可以恢复捕获的状态。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与onPause()或先前讨论的其它方法不同，onSaveInstanceState() 和 onRestoreInstanceState() 并不是生命周期方法。它们并不是总会被调用。比如说，Android会在activity易于被系统销毁之前调用 onSaveInstanceState()，但用户动作（比如按下了BACK键）造成的销毁则不调用。在这种情况下，用户没打算再次回到这个activity，所以没有保存状态的必要。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为onSaveInstanceState()不是总被调用，所以你应该只用它来为activity保存一些临时的状态，而不能用来保存持久性数据。而是应该用onPause()来达到这个目的。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>服务生命周期</b><b>(Coordinating activities)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 服务以两种方式使用：</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 它可以启动并运行，直至有人停止了它或它自己停止。在这种方式下，它以调用<code>Context.startService()</code>启动，而以调用<code>Context.stopService()</code>结束。它可以调用<code>Service.stopSelf()</code> 或 <code>Service.stopSelfResult()</code>来自己停止。不论调用了多少次startService()方法，你只需要调用一次stopService()来停止服务。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 它可以通过自己定义并暴露出来的接口进行程序操作。客户端建立一个到服务对象的连接，并通过那个连接来调用服务。连接以调用<code>Context.bindService()</code>方法建立，以调用 <code>Context.unbindService()</code>关闭。多个客户端可以绑定至同一个服务。如果服务此时还没有加载，bindService()会先加载它。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>这两种模式并不是完全分离的。你可以绑定至一个用 startService()启动的服务。比如说，一个后台音乐播放服务可以调用startService()并传递给它一个包含欲播放的音乐列表的Intent对象来启动。不久，当用户想要对播放器进行控制或者查看当前播放曲目的详情时，会启用一个activity，调用bindService()连接到服务来完成操作。在这种情况下，直到绑定连接关闭stopService() 才会真正停止一个服务。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>与activity一样，服务也有一系列你可以实现以用于监控其状态变化的生命周期方法。但相对于activity要少一些，只有三个，而且，它们是public属性，并非protected：</p>

<p class=MsoNormal align=left style='margin-left:10.5pt;text-align:left;
text-indent:21.0pt'>void onCreate()</p>

<p class=MsoNormal align=left style='margin-left:10.5pt;text-align:left;
text-indent:21.0pt'>void onStart(Intent
intent)</p>

<p class=MsoNormal align=left style='margin-left:10.5pt;text-align:left;
text-indent:21.0pt'>void onDestroy()</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 倚仗实现这些方法，你监控服务的两个嵌套的生命周期循环：</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 服务的<strong>完整生命周期</strong>始于调用<code>onCreate()</code>而终于<code>onDestroy()</code>方法返回。如同activity一样，服务在onCreate()里面进行它自己的初始化，而在onDestroy()里面释放所有资源。比如说，一个音乐回放服务可以在onCreate()中创建播放音乐的线程， 而在onDestroy()中停止这个线程。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 服务的<strong>活跃生命周期</strong>始于调用<code>onStart()</code>。这个方法用于处理传递给startService()的Intent对象。音乐服务会打开Intent来探明将要播放哪首音乐，并开始播放。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>服务停止时没有相应的回调方法──不存在onStop()方法。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; onCreate()和onDestroy()方法在所有服务中都会被调用，无论它们是由<code>Context.startService()</code>还是由<code>Context.bindService()</code>所启动的。而onStart()仅会被startService()所启用的服务调用。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果一个服务允许别的进程绑定，则它还会有以下额外的回调方法以供实现：</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:31.5pt'>IBinder onBind(Intent intent)</p>

<p class=MsoNormal align=left style='margin-left:31.5pt;text-align:left'>boolean onUnbind(Intent intent)</p>

<p class=MsoNormal align=left style='margin-left:31.5pt;text-align:left'>void onRebind(Intent intent)</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 传递给bindService的Intent的对象也会传递给<code>onBind()</code>回调方法，而传递给unbindService()的Intent对象同样传递给<code>onUnbind()</code>。如果服务允许绑定，onBind()将返回一个供客户端与服务进行交互的通讯渠道。如果有新的客户端连接至服务，则onUnbind()方法可以要求调用<code>onRebind()</code> 。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下图描绘了服务的回调方法。尽管图中对由startService 和startService方法启动的服务做了区分，但要记住，不论一个服务是怎么启动的，它都可能允许客户端的连接，所以任何服务都可以接受onBind()和onUnbind()调用。</p>

<p class=MsoNormal align=left style='margin-left:21.0pt;text-align:left'><img border=0 width=553 height=540
src="images/image012.png"></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>

<p class=MsoNormal align=left style='text-align:left'><a
name=BroadcastReceiverLifecycle><b>广播接收器生命周期</b></a><b>(Broadcast
receiver lifecycle)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 广播接收器只有一个回调方法：</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void onReceive(Context curContext, Intent broadcastMsg)</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当广播消息抵达接收器时，Android调用它的<code>onReceive()</code> 方法并将包含消息的Intent对象传递给它。广播接收器仅在它执行这个方法时处于活跃状态。当onReceive()返回后，它即为失活状态。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 拥有一个活跃状态的广播接收器的进程被保护起来而不会被杀死。但仅拥有失活状态组件的进程则会在其它进程需要它所占有的内存的时候随时被杀掉。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这种方式引出了一个问题：如果响应一个广播信息需要很长的一段时间，我们一般会将其纳入一个衍生的线程中去完成，而不是在主线程内完成它，从而保证用户交互过程的流畅。如果onReceive()衍生了一个线程并且返回，则包涵新线程在内的整个进程都被会判为失活状态（除非进程内的其它应用程序组件仍处于活跃状态），于是它就有可能被杀掉。这个问题的解决方法是令onReceive()启动一个新服务，并用其完成任务，于是系统就会知道进程中仍然在处理着工作。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 下一节中，我们会讨论更多进程易误杀的问题。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'><b>进程与生命周期</b><b>(Processes and lifecycles)</b></p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Android系统会尽可能长的延续一个应用程序进程，但在内存过低的时候，仍然会不可避免需要移除旧的进程。为决定保留或移除一个进程，Android 将每个进程都放入一个“重要性层次”中，依据则是它其中运行着的组件及其状态。重要性最低的进程首先被消灭，然后是较低的，依此类推。重要性共分五层，依
据重要性列表如下：</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<strong>前台进程</strong>是用户操作所必须的。当满足如下任一条件时，进程被认为是处于前台的：</p>

<p class=MsoNormal align=left style='margin-left:63.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 它运行着正在与用户交互的activity（Activity对象的 <code>onResume()</code> 方法已被调用）。</p>

<p class=MsoNormal align=left style='margin-left:63.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 一个正在与用户交互的activity使用着它提供的一个服务。</p>

<p class=MsoNormal align=left style='margin-left:63.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 它包含着一个正在执行生命周期回调方法（<code>onCreate()</code>、<code>onStart()</code>或<code>onDestroy()</code>）的Service对象。</p>

<p class=MsoNormal align=left style='margin-left:63.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 它包含着一个正在执行 <code>onReceive()</code> 方法的BroadcastReceiver对象。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>任一时间下，仅有少数进程会处于前台，仅当内存实在无法供给它们维持同时运行时才会被杀死。一般来说，在这种情况下，设备已然处于使用虚拟内存的状态，必须要杀死一些前台进程以用户界面保持响应。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<strong>可视进程</strong>没有前台组件，但仍可被用户在屏幕上所见。当满足如下任一条件时，进程被认为是可视的：</p>

<p class=MsoNormal align=left style='margin-left:63.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 它包含着一个不在前台，但仍然为用户可见的activity（它的<code>onPause()</code>方法被调用）。这种情况可能出现在以下情况：比如说，前台activity是一个对话框，而之前的activity位于其下并可以看到。</p>

<p class=MsoNormal align=left style='margin-left:63.0pt;text-align:left;
text-indent:-21.0pt'>l&nbsp; 它包含了一个绑定至一个可视的activity的服务。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left'>可视进程依然被视为是很重要的，非到不杀死它们便无法维持前台进程运行时，才会被杀死。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<strong>服务进程</strong>是由 <code>startService()</code> 方法启动的服务，它不会变成上述两类。尽管服务进程不会直接为用户所见，但它们一般都在做着用户所关心的事情（比如在后台播放mp3或者从网上下载东西）。所以系统会尽量维持它们的运行，除非系统内存不足以维持前台进程和可视进程的运行需要。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<strong>背景进程</strong>包含目前不为用户所见的activity（Activity对象的 <code>onStop()</code> 方法已被调用）。这些进程与用户体验没有直接的联系，可以在任意时间被杀死以回收内存供前台进程、可视进程以及服务进程使用。一般来说，会有很多背景进程
运行，所以它们一般存放于一个LRU（最后使用）列表中以确保最后被用户使用的activity最后被杀死。如果一个activity正确的实现了生命周 期方法，并捕获了正确的状态，则杀死它的进程对用户体验不会有任何不良影响。</p>

<p class=MsoNormal align=left style='margin-left:42.0pt;text-align:left;
text-indent:-21.0pt'>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<strong>空进程</strong>不包含任何活动应用程序组件。这种进程存在的唯一原因是做为缓存以改善组件再次于其中运行时的启动时间。系统经常会杀死这种进程以保持进程缓存和系统内核缓存之间的平衡。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>Android会依据进程中当前活跃组件的重要程度来尽可能高的估量一个进程的级别。比如说，如果一个进程中同时有一个服务和一个可视的activity，则进程会被判定为可视进程，而不是服务进程。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>此外，一个进程的级别可能会由于其它进程依赖于它而升高。一个为其它进程提供服务的进程级别永远高于使用它服务的进程。比如说，如果A进程中的内容提供者 为进程B中的客户端提供服务，或进程A中的服务为进程B中的组件所绑定，则A进程最低也会被视为与进程B拥有同样的重要性。</p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'>为运行着一个服务的进程重要级别总高于一个背景activity。所以一个activity以启动一个服务的方式启动一个长时间运行过程比简单的衍生一个 线程来进行处理要好。尤其是当处理过程比activity本身存在时间要长的情况之下。我们以背景音乐播放和上传一个相机拍摄的图片至网站上为例。使用服 务则不论activity发生何事，都至少可以保证操作拥有“服务进程”的权限。如上一节<a
href="7.html#BroadcastReceiverLifecycle">广播接收器生命周期</a> 所提到的，这也正是广播接收器使用服务，而不是使用线程来处理耗时任务的原因。</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

<p class=MsoNormal align=left style='text-align:left'>&nbsp;</p>

</div>

<br
clear=all style='page-break-before:auto'>



        



<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->