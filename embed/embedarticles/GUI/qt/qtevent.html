<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->

    <h1>qt事件机制</h1>
  <p><strong>站长原创，版权所有<a href="http://www.iteedu.com/index.html">ITEEDU</a>，2011-01-12</strong></p>
  <p>学习了一段时间的Qt之后，发现Qt的事件机制和其他语言的机制有些不同。Qt除了能够通过信号和槽机制来实现一些Action动作之外，还可以用对象所带的事件，或者用户自定义的事件来实现对象的一些行为处理。</p>
  <p>现在，我们从头开始讲解。</p>
  <p>到底什么是事件呢？<br>
事件起源： 
基于事件如何被产生与分发，可以把事件分为以下三类。</p>
  <h2> Spontaneous 事件——自发事件 </h2>
  <p>由窗口系统产生，它们被放到系统队列中，通过事件循环逐个处理。 </p>
  <h2>Posted 事件</h2>
  <p>由Qt或是应用程序产生，它们被Qt组成队列，再通过事件循环处理。 </p>
  <h2> Sent&nbsp; 事件</h2>
  <p>由Qt或是应用程序产生，但它们被直接发送到目标对象。 </p>
  <h2>Qt事件循环的过程</h2>
  <p> 当我们在main()函数的末尾调用QApplication::exec()时,程序进入了Qt的事件循环，大概来讲，事件循环如下面所示：<br>
    while  (!exit_was_called)<br>
    {<br>
  &nbsp;  while(!posted_event_queue_is_empty)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  process_next_posted_event();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
  &nbsp;  while(!spontaneous_event_queue_is_empty)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  process_next_spontaneous_event();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
  &nbsp;  while(!posted_event_queue_is_empty)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  process_next_posted_event();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
    }</p>
  <p>首 先，事件循环处理所有的posted事件，直到队列空。 <br>
    然后再处理所有的spontaneous事件，最后它处理所有的因为处理spontaneous事 件而产生的posted事件。 <br>
    send 事件并不在事件循环内处理，它们都直接被发送到了目标对象。 <br>
    现在看一下实践中的paint  事件是如何工作的。 <br>
    当一个widget第一次可见，或是被遮挡后再次变为可见， <br>
    窗口系统产生一个(spontaneous) paint事件，要求程序重画widget,事件循环最终从事件队列中捡选这个事件并把它分发到那个需要重画的widget。 <br>
    并不是所有的paint事件都是由窗口系统产生的。当你调用QWidget::update()去强行重画widget,这个widget会post 一个paint  事件给自己。这个paint事件被放入队列，最终被事件循环分发之。 </p>
  <p>假 如你很不耐烦，等不及事件循环去重画一个widget,  理论上，你应该直接调用paintEvent()强制进行立即的重画。但实际上这不总是可行的，因为paintEvent()函数是protected的 （很可能访问不了）。它也绕开了任何存在的事件过滤器。因为这些原因，Qt提供了一个机制，直接sending事件而不是posting 。 <br>
    QWidget::repaint()就使用了这个机制来强制进行立即重画。 </p>
  <p>posting 相对于sending的一个优势是，它给了Qt一个压缩(compress)事件的机会。假如你在一个widget上连续地调用update() 十次，因update()而产生的这十个事件，将会自动地被合并为一个单独的事件，但是QPaintEvents事件附带的区域信息也合并了。 <br>
    可压缩的事件类型包括：paint,move,resize,layout hint,language  change。 <br>
    最后要注意，你可以在任何时候调用QApplication::sendPostedEvent()，强制Qt产生一个对象的posted事件。</p>
  <h2> 人工合成的事件</h2>
  <p>QT应用程序可以产生他们自己的事件，或是预定义类型，或是自定义类型。  这可以通过创建QEvent类或它的子类的实例，并且调用QApplication:postEvent()或QApplication::sendEvent()来实现。<br>
  这两个函数需要一个  QObject* 与一个QEvent * 作为参数，假如你调用postEvent(),你必须用 new 操作符来创建事件对象，Qt会它被处理后帮你删除它。假如你用sendEvent(), 你应该在栈上来创建事件。下面举两个例子：</p>
  <h3> 一是posting 事件</h3>
  <p> QApplication::postEvent(mainWin, new  QKeyEvent(QEvent::KeyPress,Key_X,'X',0));</p>
  <h3> 二是sending 事件</h3>
  <p> &nbsp;&nbsp;&nbsp; QKeyEvent  event(QEvent::KeyPress, Key_X, 'X', 0);<br>
    &nbsp;&nbsp;&nbsp;  QApplication::sendEvent(mainWin, &amp;event);<br>
    Qt应用程序很少直接调用postEvent()或是sendEvnet()，因为大多数事件会在必要时被Qt或是窗口系统自动产生<br>
    。在大多数的情况下，当你想发送一个事件时，Qt已经为了准备好了一个更高级的函数来为你服务。（例如<br>
  update()与repaint())。</p>
  <h2> 定制事件类型</h2>
  <p>qt允许你创建自己的事件类型，这在多线程的程序中尤其有用。在单线程的程序也相当有用，它可以作为<br>
    对象间的一种通讯机制。为什么你应该用事件而不是其他的标准函数调用，或信号、槽的主要原因是：事件既可用于同步也可用于异步（依赖于你是调用sendEvent()或是postEvents()),函数调用或是槽调用总是同步的。事件的另外一个好处是它可以被过滤。<br>
    演示如何post一个定制事件的代码片段：<br>
    const QEvent::Type MyEvent =  (QEvent::Type)1234;<br>
  &nbsp; ...<br>
    QApplication::postEvent(obj, new  QCustomEvent(MyEvent));<br>
    事件必须是QCustomEvent类型(或子类）的。构造函数的参数是事件的类型，1024以下被Qt保留。其他可被程序使用。为处理定制事件类型，要重新实现customEvent()函数：<br>
    void MyLineEdit::customEvent(QCustomEvent  *event)<br>
  &nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (event-&gt;type() == MyEvent) {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  myEvent();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } else {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  QLineEdit::customEvent(event);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
  &nbsp;&nbsp;&nbsp; }<br>
    QcustomEvent类有一个void *的成员，可用于特定的目的。你也可以子类化QCustomEvent，加上别的成员，但是你也需要在customEvent()中转换QCustomeEvent到你特有的类型。</p>
  <h2> 事件处理与过滤</h2>
  <p>Qt中的事件可以在五个不同的层次上被处理</p>
  <h3> 1.重新实现一个特定的事件handler</h3>
  <p> &nbsp;QObject与QWidget提供了许多特定的事件handlers，分别对应于不同的事件类型。（如paintEvent()对应paint事件）</p>
  <h3> 2.重新实现QObject::event()</h3>
  <p> &nbsp;event()函数是所有对象事件的入口，QObject和QWidget中缺省的实现是简单地把事件推入特定的事件handlers。</p>
  <h3> 3.在QObject安装上事件过滤器</h3>
  <p> &nbsp; 事件过滤器是一个对象，它接收别的对象的事件，在这些事件到达指定目标之间。</p>
  <h3> 4.在aApp上安装一个事件过滤器</h3>
  <p>它会监视程序中发送到所有对象的所有事件。</p>
  <h3> 5.重新实现QApplication:notify()</h3>
  <p>Qt的事件循环与sendEvent()调用这个函数来分发事件，通过重写它，你可以在别人之前看到事件。 </p>
  <h2>特定对象的事件处理</h2>
  <p> 一些事件类型可以被传递。这意味着假如目标对象不处理一个事件，Qt会试着寻找另外的事件接收者。用新的目标来调用QApplication::notify()。举例来讲，key事件是传递的，假如拥有焦点的Widget不处理特定键，Qt会分发相同的事件给父widget,然后是父亲的父亲，直到最顶层widget。<br>
    那么何时接收该事件，何时忽略呢？</p>
  <h3>通过accept( )函数和ignore( )函数。</h3>
  <p>可被传递的事件有一个accept()函数和一个ignore()函数，你可以用它们来告诉Qt，你&ldquo;接收&rdquo;或是  &ldquo;忽略&rdquo;这个事件。假如事件handler调用accept(),这个事件将不会再被传递。假如事件handler调用
    ignore(),Qt会试着查找另外的事件接收者。
    像大多数的开发者一样，你可能不会被调用accept()或是ignore()所烦恼。缺省情况下是&ldquo;接收&rdquo;，在
    QWidget中的缺省实现是调用ignore(),假如你希望接收事件，你需要做的是重新实现事件handler，避免
    调用QWidget的实现。假如你想&ldquo;忽略&rdquo;事件，只需简单地传递它到QWidget的实现。下面的代码演示了这一点：<br>
    void MyFancyWidget::keyPressEvent(QKeyEvent  *event)<br>
  &nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (event-&gt;key() == Key_Escape) {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  doEscape();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } else {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  QWidget::keyPressEvent(event);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
  &nbsp;&nbsp;&nbsp; }<br>
    在上面的例子里，假如用户按了&quot;ESC&quot;键，我们会调用doEscape()并且事件被&ldquo;接收&rdquo;了（这是缺省的情况），
    事件不会被传递到父widget,假如用户按了别的键，则调用QWidget的缺省实现。<br>
    void QWidget::keyPressEvent(QKeyEvent  *event)<br>
  &nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  event-&gt;ignore();<br>
  &nbsp;&nbsp;&nbsp; }<br>
    应该感谢ignore()，事件会被传递到父widget中去。<br>
    讨论到目前为至，我们都假设基类是QWidget,然而，同样的规则也可以应用到别的层次中，只要用QWidget
    代替基类即可。举例来说：<br>
  &nbsp;void  MyFancyLineEdit::keyPressEvent(QKeyEvent *event)<br>
  &nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (event-&gt;key() == Key_SysReq) {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  doSystemRequest();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } else {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  QLineEdit::keyPressEvent(event);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
  &nbsp;&nbsp;&nbsp; }<br>
    由于某些原因，你会在event()中处理事件，而不是在特定的handler中，如keyPressEvent(),这个过程会有些不同。event() 会返回一个布尔值，来告诉调用者是否事件被accept或ignore,(true表示accept),从event()中调用accept()或是 ignore()是没有意义的。&ldquo;Accept&rdquo;标记是event()与特定事件handler之间的一种通讯机制。而从event()返回的布尔值却是 用来与QApplication:notify()通讯的。在QWidgetk中缺省的event()实现是转换&ldquo;Accept&rdquo;标记为一个布尔值，如下 所示：<br>
    bool QWidget::event(QEvent *event)<br>
  &nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  switch (e-&gt;type()) {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  case QEvent::KeyPress:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  keyPressEvent((QKeyEvent *)event);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (!((QKeyEvent *)event)-&gt;isAccepted())<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return false;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  case QEvent::KeyRelease:<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  keyReleaseEvent((QKeyEvent *)event);<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (!((QKeyEvent *)event)-&gt;isAccepted())<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return false;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  break;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ...<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  return true;<br>
  &nbsp;&nbsp;&nbsp;  }<br>
    到现在为至，我们所说的内容不仅仅适用于key事件，也适用于mouse,wheel,tablet,context menu等事件。 <br>
    Close事件有点不同，调用QCloseEvent:ignore()取消了关闭操作，而accept()告诉Qt继续执行正常的关闭操作。为了避免混乱，最好是在closeEvent()的新实现中明确地进行accept()与ignore()的调用：<br>
  &nbsp;void MainWindow::closeEvent(QCloseEvent  *event)<br>
  &nbsp;&nbsp;&nbsp; {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  if (userReallyWantsToQuit()) {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  event-&gt;accept();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  } else {<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  event-&gt;ignore();<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  }<br>
  &nbsp;&nbsp;&nbsp; }</p>
<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
