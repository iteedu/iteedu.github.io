<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->

  <h1> Cgicc体系结构</h1>
  <p><strong>站长原创，版权所有<a href="http://www.iteedu.com/index.html">ITEEDU</a>，2011-07-25</strong></p>
  <h2>Cgicc体系结构剖析</h2>
  <p>cgicc是开发cgi程序的c++库，它是基于stl的，从使用上来说，可以把它分成两个部分：第一部分是输入输出的处理和封装，它包括&nbsp;Cgicc、CgiEnvironment、CgiInput、FormEntry和FormFile类，第二部分是数据输出模块，它们是以&nbsp;MStreamable为基类的封装了HTTPHeader和HTML元素的一系列子类。HTTPCookie是继承MStreamable的，但是，对&nbsp;于输入Cookie来说，也是通过HTTPCookie来表示的，也许这是因为Cookie通常需要在不同请求中保留而设计的。<br />
    &#160;<br />
    &#160;&nbsp;Cgicc：封装了Web&nbsp;Server和CGI程序之间的数据过渡功能，对于Web&nbsp;Server来说它是参数的输出对象，对于CGI程序来说它是提取Web&nbsp;Server传递过来的数据(包括浏览器信息、Web&nbsp;Server自身的数据和用户提交的数据)的代理。<br />
    &#160;&nbsp;<br />
    &#160;&nbsp;CgiEnvironment：表示CGI运行的环境变量，这些环境变量是Web&nbsp;Server初始化的，也就CGI需要处理的数据，它是作为Cgicc对象的数据成员而保存的，当然开发者也可以通过getEnvironment()来&nbsp;直接获得CgiEnvironment的const引用。<br />
    &#160;&nbsp;<br />
    &#160;&nbsp;CgiInput：这是对于Web&nbsp;Server数据输入方式的抽象，对于传统CGI程序来说它就是标准输入，对于FastCGI来说，它是一个独立的sockket，而且对于&nbsp;FastCGI或者是用户自定义的参数输入方式来说，可以通过继承CgiInput来生成定制的类，只要在子类中覆盖read、getenv成员函数就能&nbsp;够很好地工作。<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;<br />
    &#160;&nbsp;FormEntry和FormFile是对于用户提交的数据的抽象，FormEntry是描述普通name-value对的抽象，而FormFile则是&nbsp;对用户上传的文件的抽象。事实上FormEntry和FormFile的本质差别就是FomFile多了一个文件名和文件类型。&nbsp;<br />
    &#160;&nbsp;<br />
    &#160;&nbsp;输出数据的封装类比较多，这里只是说说它设计的基本思想，如果需要详细的接口说明，可以参看cgicc的帮助文档。<br />
    &#160;&nbsp;cgicc中重载了流输出函数：CGICC_API&nbsp;std::ostream&amp;&nbsp;operator&lt;&lt;(std::ostream&amp;&nbsp;out,&nbsp;const&nbsp;MStreamable&amp;&nbsp;obj);在具有输出功能的基类MStreamable里声明为友元函数，这样只要以&nbsp;<br />
    &#160;&#160;&#160;&nbsp;&quot;outstream&nbsp;&lt;&lt;&nbsp;MStreamable&quot;&nbsp;<br />
  的形式调用的话，就会调用这个自定义的输出流函数，在这个自定义的流输出函数中，会调用&nbsp;MStreamable.render(outstream),&nbsp;也就是说只要在MStreamable的子类中覆盖render成员函数就能够定制之类的输出。在应用中，通常之类会把自己的内部数据转换为字符串，然后&nbsp;调用outstream&nbsp;&lt;&lt;&nbsp;data_str&nbsp;,只要在outstream的成员函数中覆盖&lt;&lt;操作符，就能够实现各种输出协议(当然也包括FastCGI协议)，在传统的CGI中，这个&nbsp;outstream就是std::cout对象。&#160;</p>
  <h2>    cgicc的数据处理流程&#160;&nbsp;&#160;</h2>
  <h3>    HTTP请求的参数解析</h3>
  <p> &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;创建Cgicc对象<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;Cgicc&nbsp;cgi&nbsp;--&gt;&nbsp;构造函数可以带一个表示输入流的指针（CgiInput的子类）<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;Cgicc(CgiInput&nbsp;*input&nbsp;=&nbsp;0)&nbsp;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&nbsp;Cgicc的成员变量只有3个：CgiEnvironment&nbsp;fEnvironment,&nbsp;FormEntry的vector、FormFile的vector<br />
    &#160;&#160;&nbsp;&#160;&nbsp;构着成员变量CgiEnvironment&nbsp;fEnvironment(input)<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;CgiEnvironment(CgiInput&nbsp;*input)<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;创建默认的local&nbsp;CgiInput变量&nbsp;CgiInput&nbsp;local_input<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&nbsp;CgiInput()--&gt;什么都不做，事实上CgiInput是包含数据成员的，<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&nbsp;它只是stdin的一个非常简单的封装。它提供的成员函数read是直接<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&nbsp;从std::cin中读取数据，而getenv函数则是直接调用std::getenv<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&nbsp;但是开发者可以继承CgiInput来处理更加复杂的数据传递方式<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;（例如:FastCGI）。<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|CgiInput做的事情很少，环境变量和标准输入都是Web&nbsp;Server设置好的<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;从环境中提取参数readEnvironmentVariables(input&nbsp;==&nbsp;0&nbsp;?&nbsp;&amp;local_input:&nbsp;input)<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|调用input-&gt;getenv()提取cgi变量,如:PATH_INFO、SCRIPT_NAME等等。<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|这里得到的变量都是字符串，如果需要转换，就需要调用转换函数<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;在环境变量中CONTENT_LENGTH、REQUEST_METHOD环境变量和后面对于<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;stdin的处理相关的。<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;将标准输入设置成二进制读取(对于windows平台)<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;根据请求的方法（get/post）处理标准输入stdin<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;我们这里假设为post方式<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;创建缓冲区std::vector&lt;char&gt;&nbsp;data(getContentLength());<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;读取数据input-&gt;read(&amp;data[0],&nbsp;getContentLength())&nbsp;!=&nbsp;getContentLength()<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;将数据转换为strin：fPostData&nbsp;=&nbsp;std::string(&amp;data[0],&nbsp;getContentLength());<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;处理cookie，parseCookies();<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&nbsp;cookie的处理比较简单，是基于字符串操作：<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&nbsp;1、通过&quot;;&quot;找到cookie的分割，然后把cookie分片，也就是普通的名值对name=value传递<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;给parseCookie<br />
    &#160;&nbsp;&#160;&nbsp;&#160;&nbsp;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&nbsp;2、parseCookie根据&quot;=&quot;划分name、value，其中前导的空白字符已经过滤了，根据name、<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;value创建HTTPCookie&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&nbsp;解析并保存客户端提交的数据，当HTTP请求方式是post时，从stdin中提取，实际上参数的保存已经在CgiEnvironment成员变量初始化&nbsp;的时候已经完成：<br />
    &#160;&nbsp;parseFormInput(getEnvironment().getPostData())<br />
    &#160;&nbsp;当HTTP请求的方式是get、head等的时候直接在QUERY_STRING中提取参数<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;parseFormInput(getEnvironment().getQueryString())<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;检查CONTENT_TYPE环境变量,&nbsp;当浏览器提交的数据是multipart/form-data时，提取划分边界的<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;参数boundary，然后就通过边界参数循环查找各个form-data,并通过parseMIME(data)进行解析<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;，这个查找算法非常简单，只是基于string::find调用，也就是普通的字符串操作（在代码中<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;我们可以看到在HTTP提交的数据流中分行都是通过&quot;\r\n&quot;来实现的^_^，这些信息一般的报文查<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;看软件都只是简单地显示换行）<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;如果浏览器提交只是普通的name-value字符串，那么就根据&#8220;&amp;&#8221;字符划分出name-value对，并<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;调用parsePair函数进行处理。需要说明的是parseFormInput的输入参数是string，它并不依赖<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;于HTTP请求的方式，也就是说根据请求方式的不同，传给parseFormInput的参数的不同是在外<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;不考虑的。<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;parseMIME(const&nbsp;string&amp;&nbsp;)<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&nbsp;|--&gt;首先划分form-data的header和value，在源代码中我们可以看到一些细节：<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;1、传入的参数是包含最后的&quot;\r\n&quot;的，而且header和value通过&quot;\r\n\r\n&quot;类分割<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;2、划分算法只是基于简单的字符查找功能<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;使用header的值创建MultipartHeader<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|MultipartHeader&nbsp;head&nbsp;=&nbsp;parseHeader(data.substr(0,&nbsp;valueStart));<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|根据字符串的查找截取Content-Disposition、name、filename、Content-Type的值<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|对filename进行url解码form_urldecode(filename),这是因为浏览器在提交信息的<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|时候会对文件的文件名进行url编码。<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&nbsp;创建并返回MultipartHeader(disposition,&nbsp;name,&nbsp;filename,&nbsp;cType);<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;根据是否存在filename，创建FormEntry或者是FormFile<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;fFormData.push_back(FormEntry(head.getName(),&nbsp;value))<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;fFormFiles.push_back(FormFile(head.getName(),head.getFilename(),head.getContentType(),value));<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&nbsp;实际上FormEntry和FormFile基本相同，只是FormFile多了ctype和filename两个成员变量。<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&nbsp;parsePair(data)<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&nbsp;|--&gt;通过&quot;=&quot;划分name和value，并对name、value进行form_urldecode解码<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|&#160;&nbsp;创建FormEntry,并把它加入到fFormData中fFormData.push_back(FormEntry(name,&nbsp;value));<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&nbsp;Cgicc&nbsp;实例初始化完成<br />
    &#160;&#160;&nbsp;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&nbsp;从Cgicc变量的创建过程可以看到，一个CGI程序应该只应创建一个Cgicc实例，它的成员变量fEnvironment已经包含了所有的环境变量的&nbsp;信息，fFormEntry、fFormFile成员变量分别保存了用户提交的name-value对和上传的文件。<br />
    &#160;&#160;&nbsp;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&nbsp;Cgicc提供了很多的成员函数来访问用互提交的数据和上传的文件内容，getElement*函数系列都是非常简单的，都是stl的&nbsp;std::find_if算法，而比较算法包括两种；FF_compare和FE_valueCompare，它们都是忽略大小写的。<br />
    &#160;&#160;&nbsp;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;2.2、HTTP响应数据的处理<br />
    &#160;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;重载输出操作符&quot;&lt;&lt;&quot;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;CGICC_API&nbsp;std::ostream&amp;&nbsp;operator&lt;&lt;(std::ostream&amp;&nbsp;out,&nbsp;const&nbsp;MStreamable&amp;&nbsp;obj);<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;调用obj.render(out)<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;所有需要输出对象都是通过继承MStreamable基类实现的，它们覆盖render函数来定制自己的输出.<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;由于这里类比较多，我们看看最常用的几个类看看它们的实现^_^。<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;HTTPResponseHeader：它是HTTP响应header的比较完整的封装，它的成员变量包括：<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;sting&nbsp;fHTTPVersion&nbsp;---&gt;表示HTTP协议的版本&nbsp;&quot;HTTP/1.1&quot;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;int&#160;&#160;&nbsp;fStatusCode&nbsp;---&gt;&nbsp;表示响应的结果：1XX--&gt;&nbsp;表示信息请求已经接收到，等待处理<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;2XX--&gt;&nbsp;请求处理完成<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;3XX--&gt;&nbsp;HTTP重定向<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;4XX--&gt;&nbsp;客户端提交的请求错误（参数错误）<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;5XX--&gt;&nbsp;服务器内部错误<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;string&nbsp;fReasonPhrase&nbsp;--&gt;表示响应的说明&quot;200&nbsp;OK&quot;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;vector&lt;string&gt;&nbsp;fHeaders&nbsp;--&gt;&nbsp;表示HTTP响应的头信息，这里的header是一个完整的<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;string--&gt;&quot;Location:&nbsp;XXXXXXX&quot;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;vector&lt;HTTPCoolie&gt;&nbsp;fCoolkies&nbsp;--&gt;&nbsp;表示响应的cookies<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;现在我们看看HTTPResponseHeader的render函数：<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;输出HTTP版本、状态字、状态字符串<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;out&nbsp;&lt;&lt;&nbsp;fHTTPVersion&nbsp;&lt;&lt;&nbsp;'&nbsp;'&nbsp;&lt;&lt;&nbsp;fStatusCode&nbsp;&lt;&lt;&nbsp;'&nbsp;'&nbsp;&lt;&lt;&nbsp;fReasonPhrase&nbsp;&lt;&lt;&nbsp;endl;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;输出headers信息<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;out&nbsp;&lt;&lt;&nbsp;*iter==&gt;(&nbsp;fHeaders.begin())&nbsp;&lt;&lt;&nbsp;std::endl;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;输出cookies信息<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;out&nbsp;&lt;&lt;&nbsp;*cookie_iter==&gt;(fCookies.begin())&nbsp;&lt;&lt;&nbsp;std::endl;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|---&gt;事实上这里调用的是HTTPCookie的render函数<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;输出&quot;Set-Cookie：&quot;+name+&quot;=&quot;+value+&quot;;Comment=&quot;+comment+&quot;;Domain=&quot;+domain+<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&quot;;Max-Age=&quot;+maxage+&quot;;Path=&quot;+path+&quot;;Secure&quot;+&quot;;Version=1&quot;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;(如果有些部分的内容为空，就忽略相应的name-value)<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;HTMLElement:&nbsp;它表示HTML元素，它的成员变量包括：<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;HTMLAttributeList&nbsp;*&nbsp;fAttribute&nbsp;--&gt;&nbsp;表示html元素的属性<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;HTMLElementList&nbsp;*&#160;&#160;&nbsp;fEmbeddedElement&nbsp;--&gt;&nbsp;表示内嵌的html元素<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;string&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;fData&nbsp;--&gt;&nbsp;表示html中的文本信息<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;EElementType&nbsp;fType--&gt;表示html元素的类型，这里的类型是指元素是否为对称型还是独立型的<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;bool&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;fDataSpecified&nbsp;--&gt;&nbsp;表示该html元素是否包含内部文本信息<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&nbsp;HTMLElement包含很多成员函数，基本上都是围绕成员变量的读写操作，现在我们看看render函数的处理流程：<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;对于对称型的html元素：<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;1、如果该元素没有data（文本信息）并且没有子元素，那么HTMLElement通过内部状态记录元素的输出状，如果它包含子元素，那么在输出的时候&nbsp;会一次性输出完整的html元素（包括元素属性和所有的子元素），如果通过这种形式输出，必须保证该元素的所有子元素都必须是完整的。<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;2、如果该元素带有data（文本信息），并且没有子元素，那么输出该html元素，并且输出data信息。如果存在子元素，那么输出子元素，并且忽略&nbsp;data数据。<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&nbsp;对于独立型的html元素：直接输出元素的属性，而且这种类型的元素不能带有子元素。<br />
    &#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;<br />
    &#160;&#160;&#160;&#160;&#160;&#160;&nbsp;现在我们对于HTMLElement的实现已经比较清楚了。还有一点需要说明的是，HTMLElement只是基类的设置，它是不能被实例化的，因为它有&nbsp;一个纯虚函数getName，而且它的swapState函数和getState函数都不是&quot;有效&quot;的。下面我们看看cgicc是怎么处理这些细节的：<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;对于对称型的html标签cgicc定义了一个模板：<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;template&lt;class&nbsp;Tag&gt;<br />
    &#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;class&nbsp;HTMLBooleanElement&nbsp;:&nbsp;public&nbsp;HTMLElement&nbsp;<br />
    &#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;{<br />
    &#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;...<br />
    &#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;//覆盖getName函数<br />
    &#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;virtual&nbsp;inline&nbsp;const&nbsp;char*<br />
    &#160;&#160;&nbsp;&#160;&#160;&nbsp;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;getName()&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;const<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&nbsp;&#160;&#160;&#160;&nbsp;{&nbsp;return&nbsp;Tag::getName();&nbsp;}<br />
    &#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;//定义静态成员变量<br />
    &#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;static&nbsp;bool&nbsp;sState;--&gt;这个是表示当前html元素的状态&quot;打开/闭合&quot;<br />
    &#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;}<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;//初始化静态成员变量<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;template&lt;class&nbsp;Tag&gt;<br />
    &#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&nbsp;bool&nbsp;cgicc::HTMLBooleanElement&lt;Tag&gt;::sState&nbsp;=&nbsp;false;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;而且定义了辅助的宏：<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;#define&nbsp;TAG(name,&nbsp;tag)&nbsp;\<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;class&nbsp;name##Tag&#160;&#160;&nbsp;\<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;{&nbsp;public:&nbsp;inline&nbsp;static&nbsp;const&nbsp;char*&nbsp;getName()&nbsp;{&nbsp;return&nbsp;tag;&nbsp;}&nbsp;}<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;#define&nbsp;BOOLEAN_ELEMENT(name,&nbsp;tag)&nbsp;\<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&nbsp;&#160;&#160;&nbsp;&#160;&#160;&nbsp;TAG(name,&nbsp;tag);&nbsp;typedef&nbsp;HTMLBooleanElement&lt;name##Tag&gt;&nbsp;name<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;当我们定义&quot;html&quot;标签的时候<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;BOOLEAN_ELEMENT&nbsp;(html,&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;&quot;html&quot;);<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;经过宏展开就会得到：<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;class&nbsp;htmlTag<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;{<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&nbsp;&#160;&nbsp;public:inline&nbsp;static&nbsp;const&nbsp;char*&nbsp;getName(){return&nbsp;&quot;html&quot;;}<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;}<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;typedef&nbsp;HTMLBooleanElement&lt;htmlTag&gt;&nbsp;html;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&nbsp;|<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;模板实例化以后就会得到：<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&nbsp;&#160;&nbsp;class&nbsp;HTMLBooleanElement&lt;htmlTag&gt;&nbsp;&#160;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;{<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;...<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;virtual&nbsp;inline&nbsp;const&nbsp;char*<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&nbsp;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;getName()&nbsp;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;const<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;{&nbsp;return&nbsp;htmlTag::getName();&nbsp;}<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;static&nbsp;bool&nbsp;sState;<br />
    &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&#160;&#160;&nbsp;}<br />
  &#160;&#160;&nbsp;&#160;&#160;&#160;&nbsp;&#160;&#160;&nbsp;bool&nbsp;cgicc::HTMLBooleanElement&lt;htmlTag&gt;::sState&nbsp;=&nbsp;false; </p>
  <p >整体感觉<br />
    &#160;&#160;&nbsp;1、cgicc使用了stl来维护cgi的环境变量和用户提交的数据，从而减少了很多保存和查找这些参数的代码，使得整个库在结构上显得比较清晰。&#160;&nbsp;&#160;<br />
  &#160;&#160;&nbsp;2、cgicc只是比较简单的cgi开发包，它没有session、数据库支持和模板功能，这些需要开发者自己去扩展 。</p>
<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
