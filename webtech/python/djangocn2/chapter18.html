<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->




      
        
        
        
        	<a href="chapter17.html">| 上一章</a> |
        	<a href="index.html">目  录</a> |
        	<a href="chapter19.html">下一章 </a> |
        
     


  
    
    
    
<h1  >第十八章： 集成已有的数据库和应用</h1>
<p>Django最适合于所谓的green-field开发，即从头开始的一个项目，正如你在一块还长着青草的未开垦的土地上从零开始建造一栋建筑一般。 然而，尽管Django偏爱从头开始的项目，将这个框架和以前遗留的数据库和应用相整合仍然是可能的。 本章就将介绍一些整合的技巧。</p>

<h2  >与遗留数据库整合</h2>
<p>Django的数据库层从Python代码生成SQL schemas&#8212;但是对于遗留数据库，你已经拥有SQL schemas. 这种情况,你需要为已经存在的数据表创建model. 为此,Django自带了一个可以通过读取您的数据表结构来生成model的工具. 该辅助工具称为inspectdb,你可以通过执行<tt >manage.py inspectdb</tt>来调用它.</p>

<h3  >使用 <tt >inspectdb</tt></h3>
<p>The <tt >inspectdb</tt> 工具内省检查你的配置文件（setting file）指向的数据库，针对你的每一个表生成一个Django model的表现，然后将这些Python model的代码显示在系统的标准输出里面。</p>
<p>下面是一个从头开始的针对一个典型的遗留数据库的整合过程 The only assumptions are that Django is installed and that you have a
legacy database.</p>
<blockquote>
<p>通过运行django-admin.py startproject mysite (这里 <tt >mysite</tt> 是你的项目的名字)建立一个Django项目。 好的，那我们在这个例子中就用这个 <tt >mysite</tt> 作为项目的名字。</p>
<p>编辑项目中的配置文件, <tt >mysite/settings.py</tt> ,告诉Django你的数据库连接参数和数据库名。 具体的说，要提供 <tt >DATABASE_NAME</tt> , <tt >DATABASE_ENGINE</tt> , <tt >DATABASE_USER</tt> , <tt >DATABASE_PASSWORD</tt> , <tt >DATABASE_HOST</tt> , 和 <tt >DATABASE_PORT</tt> 这些配置信息. (注意,这里面有些配置项是可选的，更多信息参考第五章） (Note that some of
these settings are optional. Refer to Chapter 5 for more information.)</p>
<p>通过运行 <tt >python mysite/manage.py startapp myapp</tt> (这里 <tt >myapp</tt> 是你的应用的名字)创建一个Django应用.那么,我们就以 <tt >myapp</tt> 做为这个应用的名字. 这里我们使用<tt >myapp</tt> 做为应用名.</p>
<p>运行命令 <tt >python mysite/manage.py inspectdb</tt> . 这将在 <tt >DATABASE_NAME</tt> 数据库中检查所有的表和打印出为每张表生成的model class. 看一看输出结果想一下 inspectdb 能做些什么.</p>
<p>将标准shell的输出重定向，保存输出到你的应用的 <tt >models.py</tt> 文件里：</p>
</blockquote>
<pre class="code">
python mysite/manage.py inspectdb &gt; mysite/myapp/models.py
</pre>
<blockquote>
<p>编辑 <tt >mysite/myapp/models.py</tt> 文件以清理生成的 models 以及一些必要的定制化。 下一个章节对此有些好的建议。</p>
</blockquote>


<h3  >清理生成的Models</h3>
<p>如你可能会预料到的，数据库自省不是完美的，你需要对产生的模型代码做些许清理。 这里提醒一点关于处理生成 models 的要点:</p>
<blockquote>
<p>数据库的每一个表都会被转化为一个model类 (也就是说，数据库的表和model 的类之间做一对一的映射)。 这意味着你需要为多对多连接的表，重构其models 为 <tt >ManyToManyField</tt> 的对象。</p>
<p>所生成的每一个model中的每个字段都拥有自己的属性，包括id主键字段。 但是，请注意，如果某个model没有主键的话，那么Django会自动为其增加一个Id主键字段。 这样一来，你也许希望使用如下代码来对任意行执行删除操作：</p>
</blockquote>
<pre class="code">
id = models.IntegerField(primary_key=True)
</pre>
<blockquote>
<p>这样做并不是仅仅因为这些行是冗余的，而且如果当你的应用需要向这些表中增加新记录时，这些行会导致某些问题。</p>
<p>每一个字段类型，如CharField、DateField， 是通过查找数据库列类型如VARCHAR,DATE来确定的。 如果inspectdb无法对某个model字段类型根据数据库列类型进行映射，那么它会使用TextField字段进行代替，并且会在所生成model字段后面加入Python注释“该字段类型是猜的”。</p>
<p>如果你的数据库中的某个字段在Django中找不到合适的对应物，你可以放心的略过它，因为Django层并没有要求必须包含你的表中的每一个字段。 The Django model layer is not required to include every field
in your table(s).</p>
<p>如果数据库中某个列的名字是Python的保留字，比如pass、class或者for等，inspectdb会在每个属性名后附加上_field，并将db_column属性设置为真实的字段名，比如pass,class或者for等。</p>
<p>例如，某张表中包含一个INT类型的列，其列名为for，那么所生成的model将会包含如下所示的一个字段：</p>
</blockquote>
<pre class="code">
for_field = models.IntegerField(db_column='for')
</pre>
<blockquote>
<p><tt >inspectdb</tt> 会在该字段后加注 <tt >‘字段重命名，因为它是一个Python保留字’</tt> 。</p>
<p>如果数据库中某张表引用了其他表（正如大多数数据库系统所做的那样），你需要适当的修改所生成model的顺序，以使得这种引用能够正确映射。 例如，model Book拥有一个针对于model Author的外键，那么后者应该先于前者被定义。</p>
<p>对于PostgreSQL,MySQL和SQLite数据库系统，inspectdb能够自动检测出主键关系。 也就是说，它会在合适的位置插入primary_key=True。 而对于其他数据库系统，你必须为每一个model中至少一个字段插入这样的语句，因为Django的model要求必须拥有一个primary_key=True的字段。</p>
<p>外键检测仅对PostgreSQL，还有MySQL表中的某些特定类型生效。 至于其他数据库，外键字段都将在假定其为INT列的情况下被自动生成为IntegerField。</p>
</blockquote>



<h2  >与认证系统的整合</h2>
<p>将Django与其他现有认证系统的用户名和密码或者认证方法进行整合是可以办到的。</p>
<p>例如，你所在的公司也许已经安装了LDAP，并且为每一个员工都存储了相应的用户名和密码。 如果用户在LDAP和基于Django的应用上拥有独立的账号，那么这时无论对于网络管理员还是用户自己来说，都是一件很令人头痛的事儿。</p>
<p>为了解决这样的问题，Django认证系统能让您以插件方式与其他认证资源进行交互。 您可以覆盖Diangos的默认基于数据库模式，您还可以使用默认的系统与其他系统进行交互。</p>

<h3  >指定认证后台</h3>
<p>在后台，Django维护了一个用于检查认证的后台列表。 当某个人调用 <tt >django.contrib.auth.authenticate()</tt> (如12章中所述)时，Django会尝试对其认证后台进行遍历认证。 如果第一个认证方法失败，Django会尝试认证第二个，以此类推，一直到尝试完。</p>
<p>认证后台列表在AUTHENTICATION_BACKENDS设置中进行指定，它应该是指向知道如何认证的Python类的Python路径的名字数组，这些类可以放置在您的Python路径的任何位置上。 This should be a tuple of Python path
names that point to Python classes that know how to authenticate. These classes
can be anywhere on your Python path.</p>
<p>默认情况下，AUTHENTICATION_BACKENDS被设置为如下：</p>
<pre class="code">
('django.contrib.auth.backends.ModelBackend',)
</pre>
<p>那就是检测Django用户数据库的基本认证模式。</p>
<p>对于多个顺序组合的AUTHENTICATION_BACKENDS，如果其用户名和密码在多个后台中都是有效的，那么Django将会在第一个正确通过认证后停止进一步的处理。</p>


<h3  >如何写一个认证后台</h3>
<p>一个认证后台其实就是一个实现了如下两个方法的类：
<tt >get_user(id)</tt> 和 <tt >authenticate(**credentials)</tt> 。</p>
<p>方法 <tt >get_user</tt> 需要一个参数 <tt >id</tt> ，这个 <tt >id</tt> 可以是用户名，数据库ID或者其他任何数值，该方法会返回一个 <tt >User</tt> 对象。</p>
<p>方法 <tt >authenticate</tt> 使用证书作为关键参数。 大多数情况下，该方法看起来如下：</p>
<pre class="code">
class MyBackend(object):
    def authenticate(self, username=None, password=None):
        # Check the username/password and return a User.
</pre>
<p>但是有时候它也可以认证某个令牌，例如：</p>
<pre class="code">
class MyBackend(object):
    def authenticate(self, token=None):
        # Check the token and return a User.
</pre>
<p>每一个方法中， <tt >authenticate</tt> 都应该检测它所获取的证书，并且当证书有效时，返回一个匹配于该证书的 <tt >User</tt> 对象，如果证书无效那么返回 <tt >None</tt> 。 If they&#8217;re not valid, it should return <tt >None</tt> .</p>
<p>如12章中所述，Django管理系统紧密连接于其自己后台数据库的 <tt >User</tt> 对象。 实现这个功能的最好办法就是为您的后台数据库（如LDAP目录，外部SQL数据库等）中的每个用户都创建一个对应的Django User对象。 您可以提前写一个脚本来完成这个工作，也可以在某个用户第一次登陆的时候在 <tt >authenticate</tt> 方法中进行实现。</p>
<p>以下是一个示例后台程序，该后台用于认证定义在 <tt >setting.py</tt> 文件中的username和password变量，并且在该用户第一次认证的时候创建一个相应的Django <tt >User</tt> 对象。</p>
<pre class="code">
from django.conf import settings
from django.contrib.auth.models import User, check_password

class SettingsBackend(object):
    &quot;&quot;&quot;
    Authenticate against the settings ADMIN_LOGIN and ADMIN_PASSWORD.

    Use the login name, and a hash of the password. For example:

    ADMIN_LOGIN = 'admin'
    ADMIN_PASSWORD = 'sha1$4e987$afbcf42e21bd417fb71db8c66b321e9fc33051de'
    &quot;&quot;&quot;
    def authenticate(self, username=None, password=None):
        login_valid = (settings.ADMIN_LOGIN == username)
        pwd_valid = check_password(password, settings.ADMIN_PASSWORD)
        if login_valid and pwd_valid:
            try:
                user = User.objects.get(username=username)
            except User.DoesNotExist:
                # Create a new user. Note that we can set password
                # to anything, because it won't be checked; the password
                # from settings.py will.
                user = User(username=username, password='get from settings.py')
                user.is_staff = True
                user.is_superuser = True
                user.save()
            return user
        return None

    def get_user(self, user_id):
        try:
            return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None
</pre>
<p>For more on authentication backends, see the official Django documentation.</p>



<h2  >和遗留Web应用集成</h2>
<p>同由其他技术驱动的应用一样，在相同的Web服务器上运行Django应用也是可行的。 最简单直接的办法就是利用Apaches配置文件httpd.conf，将不同的URL类型代理至不同的技术。 （请注意，第20章包含了在Apache/mod_python上配置Django的相关内容，因此在尝试本章集成之前花些时间去仔细阅读第20章或许是值得的。</p>
<p>关键在于只有在您的httpd.conf文件中进行了相关定义，Django对某个特定的URL类型的驱动才会被激活。 在第20章中解释的缺省部署方案假定您需要Django去驱动某个特定域上的每一个页面。</p>
<pre class="code">
&lt;Location &quot;/&quot;&gt;
    SetHandler python-program
    PythonHandler django.core.handlers.modpython
    SetEnv DJANGO_SETTINGS_MODULE mysite.settings
    PythonDebug On
&lt;/Location&gt;
</pre>
<p>这里, <tt >&lt;Location &quot;/&quot;&gt;</tt> 这一行表示用Django处理每个以根开头的URL.</p>
<p>精妙之处在于Django将&lt;location&gt;指令值限定于一个特定的目录树上。 举个例子，比如说您有一个在某个域中驱动大多数页面的遗留PHP应用，并且您希望不中断PHP代码的运行而在../admin/位置安装一个Django域。 要做到这一点，您只需将&lt;location&gt;值设置为/admin/即可。</p>
<pre class="code">
&lt;Location &quot;/admin/&quot;&gt;
    SetHandler python-program
    PythonHandler django.core.handlers.modpython
    SetEnv DJANGO_SETTINGS_MODULE mysite.settings
    PythonDebug On
&lt;/Location&gt;
</pre>
<p>有了这样的设置，只有那些以/admin/开头的URL地址才会触发Django去进行处理，而任何其他页面依旧按之前已经存在的那些设置进行处理。 Any other page will use whatever infrastructure already existed.</p>
<p>请注意，把Diango绑定到的合格的URL（比如在本章例子中的 <tt >/admin/</tt> ）并不会影响其对URL的解析。 绝对路径对Django才是有效的（例如 <tt >/admin/people/person/add/</tt> ），而非截断后的URL（例如 <tt >/people/person/add/</tt> ）。这意味着你的根URLconf必须包含前缀 <tt >/admin/</tt> 。</p>


<h2  >下一章</h2>
<p>If you&#8217;re a native English speaker, you might not have noticed one of the
coolest features of Django&#8217;s admin site: its available in more than 50
different languages! This is made possible by Django&#8217;s internationalization
framework (and the hard work of Django&#8217;s volunteer translators). The <a  href="chapter19.html">next
chapter</a> explains how to use this framework to provide localized Django sites.</p>



    
    
  



        
	<a href="chapter17.html">| 上一章</a> |
    	<a href="index.html">目  录</a> |
    	<a href="chapter19.html">下一章 </a> |










<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->