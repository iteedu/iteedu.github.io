<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->




      
        
        
        
        	<a href="chapter18.html">| 上一章</a> |
        	<a href="index.html">目  录</a> |
        	<a href="chapter20.html">下一章 </a> |
        
     


  
    
    
    
<h1  >第十九章： 国际化</h1>
<p>Django诞生于美国中部堪萨斯的劳伦斯，距美国的地理中心不到40英里。 像大多数开源项目一样，Djano社区逐渐开始包括来自全球各地的许多参与者。 鉴于Django社区逐渐变的多样性，<em>国际化</em>和<em>本地化</em>逐渐变的很重要。 由于很多开发者对这些措辞比较困惑，所以我们将简明的定义一下它们。</p>
<ul >
<li  ><p>国际化* 是指为了该软件在任何地区的潜在使用而进行程序设计的过程。 它包括了为将来翻译而标记的文本（比如用户界面要素和错误信息等）、日期和时间的抽象显示以便保证不同地区的标准得到遵循、为不同时区提供支持，并且一般确保代码中不会存在关于使用者所在地区的假设。 您会经常看到国际化被缩写为“I18N”(18表示Internationlization这个单词首字母I和结尾字母N之间的字母有18个)。</p>
</li>
</ul>
<ul >
<li  ><p>本地化* 是指使一个国际化的程序为了在某个特定地区使用而进行实际翻译的过程。 有时，本地化缩写为 <em>L10N</em> 。</p>
</li>
</ul>
<p>Django本身是完全国际化了的，所有的字符串均因翻译所需而被标记，并且设定了与地域无关的显示控制值，如时间和日期。 Django是带着40个不同的本地化文件发行的。 即使您的母语不是英语，Django也很有可能已经被翻译为您的母语了。</p>
<p>这些本地化文件所使用的国际化框架同样也可以被用在您自己的代码和模板中。</p>
<p>简要地说，您只需要添加少量的异常分支指令到您的Python代码和模板中。 这些异常分支指令被称为* 翻译字符串* 。它们告诉Django：这段文本应被翻译为终端用户指定的语言，如果这种语言的译文可以提供的话。</p>
<p>Django会根据用户的语言偏好，在线地运用这些异常分支指令去翻译Web应用程序。</p>
<p>本质上来说，Django做两件事情：</p>
<ul >
<li  ><p>它让开发者和模板的作者指定他们的应用程序的哪些部分应该被翻译。</p>
</li>
</ul>
<ul >
<li  ><p>Django根据用户的语言偏好来翻译Web应用程序。</p>
</li>
</ul>
<p>备注:</p>
<p>Django的翻译机制是使用 GNU <tt >gettext</tt> (<a  href="http://www.gnu.org/software/gettext/">http://www.gnu.org/software/gettext/</a>)，具体为Python自带的标准模块 <tt >gettext</tt> 。</p>
<p>如果您不需要国际化:</p>
<p>Django的国际化异常分支指令是默认开启的，这可能会给Django的运行增加一点点开销。 如果您不需要国际化支持，那么您可以在您的设置文件中设置 <tt >USE_I18N = False</tt> 。 如果 <tt >USE_I18N</tt> 被设为 False ，那么Django会进行一些优化，而不加载国际化支持机制。</p>
<p>您也可以从您的 <tt >TEMPLATE_CONTEXT_PROCESSORS</tt> 设置中移除 <tt >'django.core.context_processors.i18n'</tt> 。</p>
<p>对你的Django应用进行国际化的三个步骤:</p>
<ol >
<li  ><p>第一步：在你的python代码和模板中嵌入待翻译的字符串。</p>
</li>
</ol>
<ol  start="2">
<li  ><p>第二步：把那些字符串翻译成你要支持的语言</p>
</li>
</ol>
<ol  start="3">
<li  ><p>第三步：在你的django settings文件中激活做要地区的中间件</p>
</li>
</ol>
<p>我们将详细地对以上步骤逐一进行描述。</p>

<h2  >1、如何指定待翻译字符串</h2>
<p>翻译字符串指定这段需要被翻译的文本。 这些字符串可以出现在您的Python代码和模板中。 而标记出这些翻译字符串则是您的责任；系统仅能翻译出它所知道的东西。</p>

<h3  >在Python 代码中</h3>

<h4  >标准翻译</h4>
<p>使用函数 <tt >ugettext()</tt> 来指定一个翻译字符串。 作为惯例，使用短别名 <tt >_</tt> 来引入这个函数以节省键入时间.</p>
<p>在下面这个例子中，文本 <tt >&quot;Welcome to my site&quot;</tt> 被标记为待翻译字符串：</p>
<pre class="code">
from django.utils.translation import ugettext as _

def my_view(request):
    output = _(&quot;Welcome to my site.&quot;)
    return HttpResponse(output)
</pre>
<p>显然，你也可以不使用别名来编码。 下面这个例子和前面两个例子相同：</p>
<pre class="code">
from django.utils.translation import ugettext

def my_view(request):
    output = ugettext(&quot;Welcome to my site.&quot;)
    return HttpResponse(output)
</pre>
<p>翻译字符串对于语句同样有效。 下面这个例子等同前面一种</p>
<pre class="code">
def my_view(request):
    words = ['Welcome', 'to', 'my', 'site.']
    output = _(' '.join(words))
    return HttpResponse(output)
</pre>
<p>翻译对变量也同样有效。 这里是一个同样的例子：</p>
<pre class="code">
def my_view(request):
    sentence = 'Welcome to my site.'
    output = _(sentence)
    return HttpResponse(output)
</pre>
<p>（以上两个例子中，对于使用变量或计算值，需要注意的一点是Django的待翻译字符串检测工具， <tt >make-messages.py</tt> ，将不能找到这些字符串。 稍后，在
<tt >makemessages</tt> 中会有更多讨论。</p>
<p>你传递给 <tt >_()</tt> 或 <tt >gettext()</tt> 的字符串可以接受占位符，由Python标准命名字符串插入句法指定的。 例如：</p>
<pre class="code">
def my_view(request, m, d):
    output = _('Today is %(month)s %(day)s.') % {'month': m, 'day': d}
    return HttpResponse(output)
</pre>
<p>这项技术使得特定语言的译文可以对这段文本进行重新排序。 比如，一段英语译文可能是 <tt >&quot;Today is November 26.&quot;</tt> ，而一段西班牙语译文会是 <tt >&quot;Hoy es 26 de Noviembre.&quot;</tt> 使用占位符（月份和日期）交换他们的位置。</p>
<p>为了这个原因，无论何时当你有多于一个单一参数时，你应当使用命名字符串插入（例如： <tt >%(day)s</tt> ）来替代位置插入（例如： <tt >%s</tt> or <tt >%d</tt> ） 如果你使用位置插入的话，翻译动作将不能重新排序占位符文本。</p>


<h4  >标记字符串为不操作</h4>
<p>使用 <tt >django.utils.translation.gettext_noop()</tt> 函数来标记一个不需要立即翻译的字符串。 这个串会稍后从变量翻译。</p>
<p>使用这种方法的环境是，有字符串必须以原始语言的形式存储（如储存在数据库中的字符串）而在最后需要被翻译出来，如当其在用户前显示出来时。</p>


<h4  >惰性翻译</h4>
<p>使用 <tt >django.utils.translation.gettext_lazy()</tt> 函数，使得其中的值只有在访问时才会被翻译，而不是在 <tt >gettext_lazy()</tt> 被调用时翻译。</p>
<p>例如：要翻译一个模型的 <tt >help_text</tt>，按以下进行</p>
<pre class="code">
from django.utils.translation import ugettext_lazy

class MyThing(models.Model):
    name = models.CharField(help_text=ugettext_lazy('This is the help text'))
</pre>
<p>在这个例子中， <tt >ugettext_lazy()</tt> 将字符串作为惰性参照存储，而不是实际翻译。 翻译工作将在字符串在字符串上下文中被用到时进行，比如在Django管理页面提交模板时。</p>
<p>在Python中，无论何处你要使用一个unicode 字符串（一个<tt >unicode</tt> 类型的对象），您都可以使用一个 <tt >ugettext_lazy()</tt> 调用的结果。 一个<tt >ugettext_lazy()</tt>对象并不知道如何转换它自己到一个字节串。如果你尝试在一个期待字节串的地方使用它，事情将不会像期待的那样发生。 同样，你也不能在一个字节串中使用一个 unicode 字符串。所以，这同常规的Python行为是一致的。 例如：</p>
<pre class="code">
# This is fine: putting a unicode proxy into a unicode string.
u&quot;Hello %s&quot; % ugettext_lazy(&quot;people&quot;)

# This will not work, since you cannot insert a unicode object
# into a bytestring (nor can you insert our unicode proxy there)
&quot;Hello %s&quot; % ugettext_lazy(&quot;people&quot;)
</pre>
<p>如果你曾经见到到像<tt >&quot;hello&quot;</tt>这样的输出，你就尝试过了在一个字节串中插入<tt >ugettext_lazy()</tt>的结果。
在您的代码中，那是一个漏洞。</p>
<p>如果觉得 <tt >gettext_lazy</tt> 太过冗长，可以用 <tt >_</tt> （下划线）作为别名，就像这样：</p>
<pre class="code">
from django.utils.translation import ugettext_lazy as _

class MyThing(models.Model):
    name = models.CharField(help_text=_('This is the help text'))
</pre>
<p>在Django模型中总是无一例外的使用惰性翻译。 为了翻译，字段名和表名应该被标记。（否则的话，在管理界面中它们将不会被翻译） 这意味着即使在<tt >Meta</tt>类中直截了当的写<tt >verbose_nane</tt>和<tt >verbose_name_plural</tt>选项，也不看着模型的类名，对Django的默认的<tt >verbose_name</tt>和<tt >verbose_name_plural</tt>缺省决定进行回复。</p>
<pre class="code">
from django.utils.translation import ugettext_lazy as _

class MyThing(models.Model):
    name = models.CharField(_('name'), help_text=_('This is the help text'))
    class Meta:
        verbose_name = _('my thing')
        verbose_name_plural = _('mythings')
</pre>


<h4  >复数的处理</h4>
<p>使用<tt >django.utils.translation.ungettext()</tt>来指定以复数形式表示的消息。 例如：</p>
<pre class="code">
from django.utils.translation import ungettext

def hello_world(request, count):
    page = ungettext('there is %(count)d object',
        'there are %(count)d objects', count) % {
            'count': count,
        }
    return HttpResponse(page)
</pre>
<p><tt >ngettext</tt> 函数包括三个参数： 单数形式的翻译字符串，复数形式的翻译字符串，和对象的个数（将以 <tt >count</tt> 变量传递给需要翻译的语言）。</p>



<h3  >模板代码</h3>
<p>Django模板使用两种模板标签，且语法格式与Python代码有些许不同。 为了使得模板访问到标签，需要将 <tt >{% load i18n %}</tt> 放在模板最前面。</p>
<p>这个<tt >{% trans %}</tt>模板标记翻译一个常量字符串 (括以单或双引号) 或 可变内容：</p>
<pre class="code">
&lt;title&gt;{% trans &quot;This is the title.&quot; %}&lt;/title&gt;
&lt;title&gt;{% trans myvar %}&lt;/title&gt;
</pre>

<p>System Message: ERROR/3 (<tt >&lt;string&gt;</tt>, line 353)</p>
<p>Error in &#8220;cnid&#8221; directive:
no content permitted.</p>
<pre class="code">
.. cnid:: 73


  如果
</pre>


<p>System Message: WARNING/2 (<tt >&lt;string&gt;</tt>, line 357)</p>
<p>Explicit markup ends without a blank line; unexpected unindent.</p>

<p><tt >noop</tt> 选项是当前的，变量查询还会取代但翻译会跳过。&nbsp; 当欠缺内容要求将来再翻译时，这很有用。</p>
<pre class="code">
&lt;title&gt;{% trans &quot;myvar&quot; noop %}&lt;/title&gt;
</pre>
<p>在一个带 <tt >{% trans
%}</tt> 的字符串中，混进一个模板变量是不可能的。如果你的译文要求字符串带有变量(占位符placeholders)，请使用
<tt >{% blocktrans %}</tt> ：</p>
<pre class="code">
{% blocktrans %}This string will have {{ value }} inside.{% endblocktrans %}
</pre>
<p>使用模板过滤器来翻译一个模板表达式，需要在翻译的这段文本中将表达式绑定到一个本地变量中：</p>
<pre class="code">
{% blocktrans with value|filter as myvar %}
This will have {{ myvar }} inside.
{% endblocktrans %}
</pre>
<p>如果需要在 <tt >blocktrans</tt> 标签内绑定多个表达式，可以用 <tt >and</tt> 来分隔：</p>
<pre class="code">
{% blocktrans with book|title as book_t and author|title as author_t %}
This is {{ book_t }} by {{ author_t }}
{% endblocktrans %}
</pre>
<p>为了表示单复数相关的内容，需要在 <tt >{% blocktrans %}</tt> 和 <tt >{% endblocktrans %}</tt> 之间使用 <tt >{% plural %}</tt> 标签来指定单复数形式，例如：</p>
<pre class="code">
{% blocktrans count list|length as counter %}
There is only one {{ name }} object.
{% plural %}
There are {{ counter }} {{ name }} objects.
{% endblocktrans %}
</pre>
<p>其内在机制是，所有的块和内嵌翻译调用相应的 <tt >gettext</tt> 或 <tt >ngettext</tt> 。</p>
<p>每一个<tt >RequestContext</tt>可以访问三个指定翻译变量：</p>
<ul >
<li  ><p><tt >{{ LANGUAGES }}</tt> 是一系列元组组成的列表，每个元组的第一个元素是语言代码，第二个元素是用该语言表示的语言名称。</p>
</li>
</ul>
<ul >
<li  ><p>作为一二字符串，<tt >LANGUAGE_CODE</tt>是当前用户的优先语言。
例如： <tt >en-us</tt>。（请参见下面的Django如何发现语言偏好）</p>
</li>
</ul>
<ul >
<li  ><p><tt >LANGUAGE_BIDI</tt>就是当前地域的说明。 如果为真（True），它就是从右向左书写的语言，例如： 希伯来语，阿拉伯语。 如果为假（False），它就是从左到右书写的语言，如： 英语，法语，德语等。</p>
</li>
</ul>
<p>如果你不用这个<tt >RequestContext</tt>扩展，你可以用3个标记到那些值：</p>
<pre class="code">
{% get_current_language as LANGUAGE_CODE %}
{% get_available_languages as LANGUAGES %}
{% get_current_language_bidi as LANGUAGE_BIDI %}
</pre>
<p>这些标记亦要求一个 <tt >{% load i18n %}</tt> 。</p>
<p>翻译的hook在任何接受常量字符串的模板块标签内也是可以使用的。 此时，使用 <tt >_()</tt> 表达式来指定翻译字符串，例如：</p>
<pre class="code">
{% some_special_tag _(&quot;Page not found&quot;) value|yesno:_(&quot;yes,no&quot;) %}
</pre>
<p>在这种情况下，标记和过滤器两个都会看到已经翻译的字符串，所有它们并不需要提防翻译操作。</p>
<p>备注:</p>
<p>在这个例子中，翻译结构将放过字符串<tt >&quot;yes,no&quot;</tt>，而不是单独的字符串<tt >&quot;yes&quot;</tt>和<tt >&quot;no&quot;</tt>。翻译的字符串将需要包括逗号以便过滤器解析代码明白如何分割参数。 例如， 一个德语翻译器可能会翻译字符串 <tt >&quot;yes,no&quot;</tt> 为 <tt >&quot;ja,nein&quot;</tt> (保持逗号原封不动)。</p>


<h3  >与惰性翻译对象一道工作</h3>
<p>在模型和公用函数中，使用<tt >ugettext_lazy()</tt>和<tt >ungettext_lazy()</tt>来标记字符串是很普遍的操作。 当你在你的代码中其它地方使用这些对象时，你应当确定你不会意外地转换它们成一个字符串，因为它们应被尽量晚的转换（以便正确的地域生效） 这需要使用及个帮助函数。</p>

<h4  >拼接字符串： string_concat()</h4>
<p>标准Python字符串拼接(<tt >''.join([...])</tt> ) 将不会工作在包括惰性翻译对象的列表上。 作为替代，你可以使用<tt >django.utils.translation.string_concat()</tt>， 这个函数创建了一个惰性对象，其连接起它的内容 <em>并且</em> 仅当结果被包括在一个字符串中时转换它们为字符串 。 例如：</p>
<pre class="code">
from django.utils.translation import string_concat
# ...
name = ugettext_lazy(u'John Lennon')
instrument = ugettext_lazy(u'guitar')
result = string_concat([name, ': ', instrument])
</pre>

<p>System Message: ERROR/3 (<tt >&lt;string&gt;</tt>, line 521)</p>
<p>Error in &#8220;cnid&#8221; directive:
no content permitted.</p>
<pre class="code">
.. cnid:: 109


  在这种情况下，当
</pre>


<p>System Message: WARNING/2 (<tt >&lt;string&gt;</tt>, line 525)</p>
<p>Explicit markup ends without a blank line; unexpected unindent.</p>

<p><tt >result</tt> 自己被用与一个字符串时， <tt >result</tt> 中的惰性翻译将仅被转换为字符串(通常在模板渲染时间)。</p>


<h4  >allow_lazy() 修饰符</h4>
<p>Django提供很多功能函数（如：取一个字符串作为他们的第一个参数并且对那个字符串做些什么）。(尤其在 <tt >django.utils</tt> 中) 这些函数被模板过滤器像在其他代码中一样直接使用。</p>
<p>如果你写你自己的类似函数并且与翻译打交道，当第一个参数是惰性翻译对象是，你会面临“做什么”的难题。
因为你可能在视图之外使用这个函数（并且因此当前线程的本地设置将会不正确），所以你不想立即转换其为一个字符串。</p>
<p>象这种情况，请使用 <tt >django.utils.functional.allow_lazy()</tt>
修饰符。 它修改这个函数以便 <em>if</em> 作为第一个参数被一个惰性翻译调用， 这个函数的赋值会被延后直到它需要被转化为一个字符串为止。</p>
<p>例如：</p>
<pre class="code">
from django.utils.functional import allow_lazy

def fancy_utility_function(s, ...):
    # Do some conversion on string 's'
    # ...
fancy_utility_function = allow_lazy(fancy_utility_function, unicode)
</pre>
<p><tt >allow_lazy()</tt> 装饰符 采用了另外的函数来装饰，以及一定量的，原始函数可以返回的特定类型的额外参数 (<tt >*args</tt> ) 。 通常，在这里包括 <tt >unicode</tt> 就足够了并且确定你的函数将仅返回Unicode字符串。</p>
<p>使用这个修饰符意味着你能写你的函数并且假设输入是合适的字符串，然后在末尾添加对惰性翻译对象的支持。</p>




<h2  >2、如何创建语言文件</h2>
<p>当你标记了翻译字符串，你就需要写出（或获取已有的）对应的语言翻译信息。 这里就是它如何工作的。</p>
<p>地域限制</p>
<p>Django不会支持本地化你的应用到一个连它自己都还没被翻译的地域。 在这种情况下，它将忽略你的翻译文件。 如果你想尝试这个并且Django支持它，你会不可避免地见到这样一个混合体&#8211;&#8211;参杂着你的译文和来自Django自己的英文。 如果你的应用需要你支持一个Django中没有的地域，你将至少需要做一个Django core的最小翻译。</p>

<h3  >消息文件</h3>
<p>第一步，就是为一种语言创建一个信息文件。 一个信息文件是包含了某一语言翻译字符串和对这些字符串的翻译的一个文本文件。 信息文件以 <tt >.po</tt> 为后缀名。</p>
<p>Django中带有一个工具， <tt >bin/make-messages.py</tt> ，它完成了这些文件的创建和维护工作。 运行以下命令来创建或更新一个信息文件：</p>
<pre class="code">
django-admin.py makemessages -l de
</pre>
<p>其中 <tt >de</tt> 是所创建的信息文件的语言代码。 在这里，语言代码是以本地格式给出的。 例如，巴西地区的葡萄牙语为 <tt >pt_BR</tt> ，澳大利亚地区的德语为 <tt >de_AT</tt> 。可查看 <tt >django/conf/locale</tt> 目录获取Django所支持的语言代码。</p>
<p>这段脚本应该在三处之一运行：</p>
<ul >
<li  ><p>Django项目根目录</p>
</li>
</ul>
<ul >
<li  ><p>您Django应用的根目录。</p>
</li>
</ul>
<ul >
<li  ><p><tt >django</tt> 根目录（不是Subversion检出目录，而是通过 <tt >$PYTHONPATH</tt> 链接或位于该路径的某处）
这仅和你为Django自己创建一个翻译时有关。</p>
</li>
</ul>
<p>这段脚本遍历你的项目源树或你的应用程序源树并且提取出所有为翻译而被标记的字符串。 它在 <tt >conf/locale</tt> 目录下创建（或更新）了一个信息文件。</p>
<p>作为默认， <tt >django-admin.py makemessages</tt> 检测每一个有
<tt >.html</tt> 扩展名的文件。&nbsp; 以备你要重载缺省值，使用
<tt >--extension</tt> 或 <tt >-e</tt> 选项指定文件扩展来检测。</p>
<pre class="code">
django-admin.py makemessages -l de -e txt
</pre>
<p>用逗号和（或）使用<tt >-e</tt>或<tt >--extension</tt>来分隔多项扩展项：</p>
<pre class="code">
django-admin.py makemessages -l de -e html,txt -e xml
</pre>
<p>当创建JavaScript翻译目录时，你需要使用特殊的Django域：<strong>not</strong> <tt >-e js</tt> 。</p>
<p>没有gettext?</p>
<p>如果没有安装 <tt >gettext</tt> 组件， <tt >make-messages.py</tt> 将会创建空白文件。 这种情况下，安装 <tt >gettext</tt> 组件或只是复制英语信息文件( <tt >conf/locale/en/LC_MESSAGES/django.po</tt> )来作为一个起点；只是一个空白的翻译信息文件而已。</p>
<p>工作在Windows上么？</p>
<p>如果你正在使用Windows，且需要安装GNU gettext共用程序以便
<tt >django-admin makemessages</tt> 可以工作，请参看下面Windows小节中gettext部分以获得更多信息。</p>
<p><tt >.po</tt> 文件格式很直观。 每个 <tt >.po</tt> 文件包含一小部分的元数据，比如翻译维护人员的联系信息，而文件的大部分内容是简单的翻译字符串和对应语言翻译结果的映射关系的列表。</p>
<p>举个例子，如果Django应用程序包括一个 <tt >&quot;Welcome to my site.&quot;</tt> 的待翻译字符串 ，像这样：</p>
<pre class="code">
_(&quot;Welcome to my site.&quot;)
</pre>
<p>则<tt >django-admin.py makemessages</tt>将创建一个 <tt >.po</tt> 文件来包含以下片段的消息：</p>
<pre class="code">
#: path/to/python/module.py:23
msgid &quot;Welcome to my site.&quot;
msgstr &quot;&quot;
</pre>
<p>一个快速解释：</p>
<ul >
<li  ><p><tt >msgid</tt> 是在源文件中出现的翻译字符串。 不要做改动。</p>
</li>
</ul>
<ul >
<li  ><p><tt >msgstr</tt> 是相应语言的翻译结果。 刚创建时它只是空字符串，此时就需要你来完成它。 注意不要丢掉语句前后的引号。</p>
</li>
</ul>
<ul >
<li  ><p>作为方便之处，每一个消息都包括：以 <tt >#</tt> 为前缀的一个注释行并且定位上边的<tt >msgid</tt> 行，文件名和行号。</p>
</li>
</ul>
<p>对于比较长的信息也有其处理方法。 <tt >msgstr</tt> （或 <tt >msgid</tt> ）后紧跟着的字符串为一个空字符串。 然后真正的内容在其下面的几行。 这些字符串会被直接连在一起。 同时，不要忘了字符串末尾的空格，因为它们会不加空格地连到一起。</p>
<p>若要对新创建的翻译字符串校验所有的源代码和模板中，并且更新所有语言的信息文件，可以运行以下命令：</p>
<pre class="code">
django-admin.py makemessages -a
</pre>


<h3  >编译信息文件</h3>
<p>创建信息文件之后，每次对其做了修改，都需要将它重新编译成一种更有效率的形式，供 <tt >gettext</tt> 使用。</p>
<p>这个工具作用于所有有效的 <tt >.po</tt> 文件，创建优化过的二进制 <tt >.mo</tt> 文件供 <tt >gettext</tt> 使用。</p>
<pre class="code">
django-admin.py compilemessages
</pre>
<p>就是这样了。 你的翻译成果已经可以使用了。</p>



<h2  >Django如何处理语言偏好</h2>
<p>一旦你准备好了翻译，如果希望在Django中使用，那么只需要激活这些翻译即可。</p>
<p>在这些功能背后，Django拥有一个灵活的模型来确定在安装和使用应用程序的过程中选择使用的语言。</p>
<p>要设定一个安装阶段的语种偏好，请设定<tt >LANGUAGE_CODE</tt>。如果其他翻译器没有找到一个译文，Django将使用这个语种作为缺省的翻译最终尝试。</p>
<p>如果你只是想要用本地语言来运行Django，并且该语言的语言文件存在，只需要简单地设置 <tt >LANGUAGE_CODE</tt> 即可。</p>
<p>如果要让每一个使用者各自指定语言偏好，就需要使用 <tt >LocaleMiddleware</tt> 。 <tt >LocaleMiddleware</tt> 使得Django基于请求的数据进行语言选择，从而为每一位用户定制内容。 它为每一个用户定制内容。</p>
<p>使用 <tt >LocaleMiddleware</tt> 需要在 <tt >MIDDLEWARE_CLASSES</tt> 设置中增加 <tt >'django.middleware.locale.LocaleMiddleware'</tt> 。中间件的顺序是有影响的，最好按照依照以下要求： 因为中间件的顺序因素，你应当跟从这些准则：</p>
<ul >
<li  ><p>保证它是第一批安装的中间件类。</p>
</li>
</ul>
<ul >
<li  ><p>因为 <tt >LocalMiddleware</tt> 要用到session数据，所以需要放在 <tt >SessionMiddleware</tt> 之后。</p>
</li>
</ul>
<ul >
<li  ><p>如果你使用<tt >CacheMiddleware</tt>把<tt >LocaleMiddleware</tt>放在它后面。</p>
</li>
</ul>
<p>例如， <tt >MIDDLE_CLASSES</tt> 可能会是如此：</p>
<pre class="code">
MIDDLEWARE_CLASSES = (
   'django.contrib.sessions.middleware.SessionMiddleware',
   'django.middleware.locale.LocaleMiddleware',
   'django.middleware.common.CommonMiddleware',
)
</pre>
<p>（更多关于中间件的内容，请参阅第17章）</p>
<p><tt >LocaleMiddleware</tt> 按照如下算法确定用户的语言:</p>
<ul >
<li  ><p>首先，在当前用户的 session 的中查找<tt >django_language</tt>键；</p>
</li>
</ul>
<ul >
<li  ><p>如未找到，它会找寻一个cookie</p>
</li>
</ul>
<ul >
<li  ><p>还找不到的话，它会在 HTTP 请求头部里查找<tt >Accept-Language</tt>， 该头部是你的浏览器发送的，并且按优先顺序告诉服务器你的语言偏好。 Django会尝试头部中的每一个语种直到它发现一个可用的翻译。</p>
</li>
</ul>
<ul >
<li  ><p>以上都失败了的话, 就使用全局的 <tt >LANGUAGE_CODE</tt> 设定值。</p>
</li>
</ul>
<p>备注：</p>
<blockquote>
<p>在上述每一处，语种偏好应作为字符串，以标准的语种格式出现。 例如，巴西葡萄牙语是<tt >pt-br</tt></p>
<p>如果一个基本语种存在而亚语种没有指定，Django将使用基本语种。 比如，如果用户指定了 <tt >de-at</tt> （澳式德语）但Django只有针对 <tt >de</tt> 的翻译，那么 <tt >de</tt> 会被选用。</p>
<p>只有在 <tt >LANGUAGES</tt> 设置中列出的语言才能被选用。 若希望将语言限制为所提供语言中的某些（因为应用程序并不提供所有语言的表示），则将 <tt >LANGUAGES</tt> 设置为所希望提供语言的列表，例如： 例如：</p>
</blockquote>
<pre class="code">
LANGUAGES = (
  ('de', _('German')),
  ('en', _('English')),
)
</pre>
<blockquote>
<p>上面这个例子限制了语言偏好只能是德语和英语（包括它们的子语言，如 <tt >de-ch</tt> 和 <tt >en-us</tt> ）。</p>
<p>如果自定义了 <tt >LANGUAGES</tt> ，将语言标记为翻译字符串是可以的，但是，请不要使用 <tt >django.utils.translation</tt> 中的 <tt >gettext()</tt> （决不要在settings文件中导入 <tt >django.utils.translation</tt> ，因为这个模块本身是依赖于settings，这样做会导致无限循环），而是使用一个“虚构的” <tt >gettext()</tt> 。</p>
<p>解决方案就是使用一个“虚假的” <tt >gettext()</tt> 。以下是一个settings文件的例子： 这里是一个设置文件的样例。</p>
</blockquote>
<pre class="code">
ugettext = lambda s: s

LANGUAGES = (
    ('de', ugettext('German')),
    ('en', ugettext('English')),
)
</pre>
<blockquote>
<p>这样做的话， <tt >make-messages.py</tt> 仍会寻找并标记出将要被翻译的这些字符串，但翻译不会再运行时进行，故而需要在任何使用 <tt >LANGUAGES</tt> 的代码中用“真实的” <tt >gettext()</tt> 来修饰这些语言。
<tt >ugettext()</tt> 在运行时使用 <tt >LANGUAGES</tt>的任何代中。</p>
<p><tt >LocaleMiddleware</tt> 只能选择那些Django已经提供了基础翻译的语言。 如果想要在应用程序中对Django中还没有基础翻译的语言提供翻译，那么必须至少先提供该语言的基本的翻译。 例如，Django使用特定的信息ID来翻译日期和时间格式，故要让系统正常工作，至少要提供这些基本的翻译。</p>
<p>以英语的 <tt >.po</tt> 文件为基础，翻译其中的技术相关的信息，可能还包括一些使之生效的信息。</p>
<p>技术相关的信息ID很容易被人出来： 它们都是大写的。 这些信息ID的翻译与其他信息不同:你需要提供其对应的本地化内容。 例如，对于 <tt >DATETIME_FORMAT</tt> （或 <tt >DATE_FORMAT</tt> 、 <tt >TIME_FORMAT</tt> ），应该提供希望在该语言中使用的格式化字符串。</p>
</blockquote>
<p>一旦<tt >LocaleMiddleware</tt>决定用户的偏好，它会让这个偏好作为<tt >request.LANGUAGE_CODE</tt>对每一个<tt >HttpRequest</tt>有效。请随意在你的视图代码中读一读这个值。 以下是一个简单的例子：</p>
<pre class="code">
def hello_world(request):
    if request.LANGUAGE_CODE == 'de-at':
        return HttpResponse(&quot;You prefer to read Austrian German.&quot;)
    else:
        return HttpResponse(&quot;You prefer to read another language.&quot;)
</pre>
<p>注意，对于静态翻译（无中间件）而言，此语言在<tt >settings.LANGUAGE_CODE</tt>中，而对于动态翻译（中间件），它在<tt >request.LANGUAGE_CODE</tt>中。</p>


<h2  >在你自己的项目中使用翻译</h2>
<p>Django使用以下算法寻找翻译：</p>
<ul >
<li  ><p>首先，Django在该视图所在的应用程序文件夹中寻找 <tt >locale</tt> 目录。 若找到所选语言的翻译，则加载该翻译。</p>
</li>
</ul>
<ul >
<li  ><p>第二步，Django在项目目录中寻找 <tt >locale</tt> 目录。 若找到翻译，则加载该翻译。</p>
</li>
</ul>
<ul >
<li  ><p>最后，Django使用 <tt >django/conf/locale</tt> 目录中的基本翻译。</p>
</li>
</ul>
<p>以这种方式，你可以创建包含独立翻译的应用程序，可以覆盖项目中的基本翻译。 或者，你可以创建一个包含几个应用程序的大项目，并将所有需要的翻译放在一个大的项目信息文件中。 决定权在你手中。</p>
<p>所有的信息文件库都是以同样方式组织的： 它们是：</p>
<ul >
<li  ><p><tt >$APPPATH/locale/&lt;language&gt;/LC_MESSAGES/django.(po|mo)</tt></p>
</li>
</ul>
<ul >
<li  ><p><tt >$PROJECTPATH/locale/&lt;language&gt;/LC_MESSAGES/django.(po|mo)</tt></p>
</li>
</ul>
<ul >
<li  ><p>所有在settings文件中 <tt >LOCALE_PATHS</tt> 中列出的路径以其列出的顺序搜索 <tt >&lt;language&gt;/LC_MESSAGES/django.(po|mo)</tt></p>
</li>
</ul>
<ul >
<li  ><p><tt >$PYTHONPATH/django/conf/locale/&lt;language&gt;/LC_MESSAGES/django.(po|mo)</tt></p>
</li>
</ul>
<p>要创建信息文件，也是使用 <tt >make-messages.py</tt> 工具，和Django信息文件一样。 需要做的就是改变到正确的目录下—— <tt >conf/locale</tt> （在源码树的情况下）或者 <tt >locale/</tt> （在应用程序信息或项目信息的情况下）所在的目录下。 同样地，使用 <tt >compile-messages.py</tt> 生成 <tt >gettext</tt> 需要使用的二进制 <tt >django.mo</tt> 文件。</p>
<p>您亦可运行<tt >django-admin.py compilemessages
--settings=path.to.settings</tt> 来使编译器处理所有存在于您 <tt >LOCALE_PATHS</tt> 设置中的目录。</p>
<p>应用程序信息文件稍微难以发现——因为它们需要 <tt >LocaleMiddle</tt> 。如果不使用中间件，Django只会处理Django的信息文件和项目的信息文件。</p>
<p>最后，需要考虑一下翻译文件的结构。 若应用程序要发放给其他用户，应用到其它项目中，可能需要使用应用程序相关的翻译。 但是，使用应用程序相关的翻译和项目翻译在使用 <tt >make-messages</tt> 时会产生古怪的问题。</p>
<p>最容易的解决方法就是将不属于项目的应用程序（因此附带着本身的翻译）存储在项目树之外。 这样做的话，项目级的 <tt >make-messages</tt> 将只会翻译与项目精确相关的，而不包括那些独立发布的应用程序中的字符串。</p>


<h2  ><tt >set_language</tt> 重定向视图</h2>
<p>方便起见，Django自带了一个 <tt >django.views.i18n.set_language</tt> 视图，作用是设置用户语言偏好并重定向返回到前一页面。</p>
<p>在URLconf中加入下面这行代码来激活这个视图：</p>
<pre class="code">
(r'^i18n/', include('django.conf.urls.i18n')),
</pre>
<p>（注意这个例子使得这个视图在 <tt >/i18n/setlang/</tt> 中有效。</p>
<p>这个视图是通过 <tt >GET</tt> 方法调用的，在Query String中包含了 <tt >language</tt> 参数。 如果session已启用，这个视图会将语言选择保存在用户的session中。 否则，它会以缺省名<tt >django_language</tt>在cookie中保存这个语言选择。(这个名字可以通过<tt >LANGUAGE_COOKIE_NAME</tt>设置来改变)</p>
<p>保存了语言选择后，Django根据以下算法来重定向页面：</p>
<ul >
<li  ><p>Django 在 <tt >POST</tt> 数据中寻找一个 <tt >下一个</tt> 参数。</p>
</li>
</ul>
<ul >
<li  ><p>如果 <tt >next</tt> 参数不存在或为空，Django尝试重定向页面为HTML头部信息中 <tt >Referer</tt> 的值。</p>
</li>
</ul>
<ul >
<li  ><p>如果 <tt >Referer</tt> 也是空的，即该用户的浏览器并不发送 <tt >Referer</tt> 头信息，则页面将重定向到 <tt >/</tt> （页面根目录）。</p>
</li>
</ul>
<p>这是一个HTML模板代码的例子：</p>
<pre class="code">
&lt;form action=&quot;/i18n/setlang/&quot; method=&quot;post&quot;&gt;
&lt;input name=&quot;next&quot; type=&quot;hidden&quot; value=&quot;/next/page/&quot; /&gt;
&lt;select name=&quot;language&quot;&gt;
    {% for lang in LANGUAGES %}
    &lt;option value=&quot;{{ lang.0 }}&quot;&gt;{{ lang.1 }}&lt;/option&gt;
    {% endfor %}
&lt;/select&gt;
&lt;input type=&quot;submit&quot; value=&quot;Go&quot; /&gt;
&lt;/form&gt;
</pre>


<h2  >翻译与JavaScript</h2>
<p>将翻译添加到JavaScript会引起一些问题：</p>
<ul >
<li  ><p>JavaScript代码无法访问一个 <tt >gettext</tt> 的实现。</p>
</li>
</ul>
<ul >
<li  ><p>JavaScript 代码并不访问 .po或 .mo 文件；它们需要由服务器分发。</p>
</li>
</ul>
<ul >
<li  ><p>针对JavaScript的翻译目录应尽量小。</p>
</li>
</ul>
<p>Django已经提供了一个集成解决方案： 它会将翻译传递给JavaScript，因此就可以在JavaScript中调用 <tt >gettext</tt> 之类的代码。</p>

<h3  ><tt >javascript_catalog</tt>视图</h3>
<p>这些问题的主要解决方案就是 <tt >javascript_catalog</tt> 视图。 该视图生成一个JavaScript代码库，包括模仿 <tt >gettext</tt> 接口的函数，和翻译字符串的数组。</p>
<p>像这样使用：</p>
<pre class="code">
js_info_dict = {
    'packages': ('your.app.package',),
}

urlpatterns = patterns('',
    (r'^jsi18n/$', 'django.views.i18n.javascript_catalog', js_info_dict),
)
</pre>
<p><tt >packages</tt> 里的每个字符串应该是Python中的点分割的包的表达式形式（和在 <tt >INSTALLED_APPS</tt> 中的字符串相同的格式），而且应指向包含 <tt >locale</tt> 目录的包。 如果指定了多个包，所有的目录会合并成一个目录。 如果有用到来自不同应用程序的字符串的JavaScript，这种机制会很有帮助。</p>
<p>你可以动态使用视图，将包放在urlpatterns里：</p>
<pre class="code">
urlpatterns = patterns('',
    (r'^jsi18n/(?P&lt;packages&gt;\S+)/$', 'django.views.i18n.javascript_catalog'),
)
</pre>
<p>这样的话，就可以在URL中指定由加号（ <tt >+</tt> ）分隔包名的包了。 如果页面使用来自不同应用程序的代码，且经常改变，还不想将其放在一个大的目录文件中，对于这些情况，显然这是很有用的。 出于安全考虑，这些值只能是 <tt >django.conf</tt> 或 <tt >INSTALLED_APPS</tt> 设置中的包。</p>


<h3  >使用JavaScript翻译目录</h3>
<p>要使用这个目录，只要这样引入动态生成的脚本：</p>
<pre class="code">
&lt;script type=&quot;text/javascript&quot; src=&quot;/path/to/jsi18n/&quot;&gt;&lt;/script&gt;
</pre>
<p>这就是管理页面如何从服务器获取翻译目录。 当目录加载后，JavaScript代码就能通过标准的 <tt >gettext</tt> 接口进行访问：</p>
<pre class="code">
document.write(gettext('this is to be translated'));
</pre>
<p>亦有一个<tt >ngettext</tt>接口：</p>
<pre class="code">
var object_cnt = 1 // or 0, or 2, or 3, ...
s = ngettext('literal for the singular case',
        'literal for the plural case', object_cnt);
</pre>
<p>甚至有一个字符串插入函数：</p>
<pre class="code">
function interpolate(fmt, obj, named);
</pre>
<p>插入句法是从Python借用的，所以<tt >interpolate</tt>
函数对位置和命名插入均提供支持：</p>
<blockquote>
<p>位置插入 <tt >obj</tt>包括一个JavaScript数组对象，要素值在它们的对应于<tt >fmt</tt>的占位符中以它们出现的相同次序顺序插值 。 例如：</p>
</blockquote>
<pre class="code">
fmts = ngettext('There is %s object. Remaining: %s',
        'There are %s objects. Remaining: %s', 11);
s = interpolate(fmts, [11, 20]);
// s is 'There are 11 objects. Remaining: 20'
</pre>
<blockquote>
<p>命名插入 通过传送为真（TRUE）的布尔参数<tt >name</tt>来选择这个模式。 <tt >obj</tt>包括一个 JavaScript 对象或相关数组。 例如：</p>
</blockquote>
<pre class="code">
d = {
    count: 10
    total: 50
};

fmts = ngettext('Total: %(total)s, there is %(count)s object',
'there are %(count)s of a total of %(total)s objects', d.count);
s = interpolate(fmts, d, true);
</pre>
<p>你不应同字符串插值一起升到顶部，尽管： 这还是JavaScript，所以这段代码不得不重复做正则表达式置换。
它不会和Python中的字符串插补一样快，因此只有真正需要的时候再使用它（例如，利用 <tt >ngettext</tt> 生成合适的复数形式）。</p>


<h3  >创建JavaScript翻译目录</h3>
<p>你可以像其他人一样以同样的方式创建和升级翻译目录</p>
<p>Django翻译目录支持 django-admin.py makemessages  工具。 唯一的差别是需要提供一个 <tt >-d djangojs</tt> 的参数，就像这样：</p>
<pre class="code">
django-admin.py makemessages -d djangojs -l de
</pre>
<p>这样来创建或更新JavaScript的德语翻译目录。
和普通的Django翻译目录一样，更新了翻译目录后，运行 <tt >compile-messages.py</tt> 即可。</p>



<h2  >熟悉 <tt >gettext</tt> 用户的注意事项</h2>
<p>如果你了解 <tt >gettext</tt> ，你可能会发现Django进行翻译时的一些特殊的东西：</p>
<ul >
<li  ><p>字符串域为 <tt >django</tt> 或 <tt >djangojs</tt> 。字符串域是用来区别将数据存储在同一信息文件库（一般是 <tt >/usr/share/locale/</tt> ）的不同程序。 <tt >django</tt> 域是为Python和模板翻译字符串服务的，被加载到全局翻译目录。</p>
</li>
</ul>
<ul >
<li  ><p>Django不单独使用 <tt >xgettext</tt> ， 而是经过Python包装后的<tt >xgettext</tt>和msgfmt。这主要是为了方便。</p>
</li>
</ul>


<h2  >Windows下的<tt >gettext</tt></h2>
<p>对于那些要提取消息或编译消息文件(的人们来说，这就是仅需的。翻译工作本身仅仅参与编辑这个类型的现存文件，但如果你要创建你自己的消息文件，或想要测试或编译一个更改过的消息文件，你将需要这个<tt >.po</tt>)<tt >gettext</tt>公用程序。</p>
<ul>
<li  ><blockquote >
<p>从<a  href="http://sourceforge.net/projects/gettext">http://sourceforge.net/projects/gettext</a>下载以下zip文件</p>
</blockquote>
<ul >
<li  ><p><tt >gettext-runtime-X.bin.woe32.zip</tt></p>
</li>
</ul>
<ul >
<li  ><p><tt >gettext-tools-X.bin.woe32.zip</tt></p>
</li>
</ul>
<ul >
<li  ><p><tt >libiconv-X.bin.woe32.zip</tt></p>
</li>
</ul>
</li>
</ul>
<ul >
<li  ><p>在同一文件夹下展开这3个文件。 <tt >C:\Program
Files\gettext-utils</tt> )</p>
</li>
</ul>
<ul>
<li  ><p>更新系统路径：</p>
<ul >
<li  ><p><tt >Control Panel &gt; System &gt; Advanced &gt; Environment Variables</tt></p>
</li>
</ul>
<ul >
<li  ><p>在<tt >System variables</tt>列表中，点击<tt >Path</tt>，点击<tt >Edit</tt></p>
</li>
</ul>
<ul >
<li  ><p>把<tt >;C:\Program Files\gettext-utils\bin</tt>加到<tt >Variable value</tt>字段的末尾。</p>
</li>
</ul>
</li>
</ul>
<p>只要<tt >xgettext --version</tt>命令正常工作，你亦可使用从别处获得的<tt >gettext</tt>的二进制代码。 有些版本的0.14.4二进制代码被发现不支持这个命令。 不要试图与Django公用程序一起使用一个<tt >gettext</tt>。在一个windows命令提示窗口输入命令 `` xgettext &#8212;version <a href="#id15">``</a>将导致出现一个错误弹出窗口&#8211;“xgettext.exe产生错误并且将被windows关闭”。</p>

<p>System Message: WARNING/2 (<tt >&lt;string&gt;</tt>, line 1348); <em><a href="#id16">backlink</a></em></p>
<p>Inline literal start-string without end-string.</p>



<h2  >下一章</h2>
<p><a  href="chapter20.html">未章</a> 将关注于安全，如何帮助你的用户和网站远离恶意软件的攻击。</p>



    
    
  



        
	<a href="chapter18.html">| 上一章</a> |
    	<a href="index.html">目  录</a> |
    	<a href="chapter20.html">下一章 </a> |










<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->