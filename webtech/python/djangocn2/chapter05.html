<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->




      
        
        
        
        	<a href="chapter04.html">| 上一章</a> |
        	<a href="index.html">目  录</a> |
        	<a href="chapter06.html">下一章 </a> |
        
     


  
    
    
    
<h1  >第5章 模型</h1>
<p>在第三章，我们讲述了用 Django 建造网站的基本途径： 建立视图和 URLConf 。正如我们所阐述的，视图负责处理 <em>一些任意逻辑</em> ，然后返回响应结果。 在范例中，我们的任意逻辑就是计算当前的日期和时间。 作为例子之一，我们的主观逻辑是要计算当前的日期和时间。</p>
<p>在当代 Web 应用中，任意逻辑经常牵涉到与数据库的交互。 <em>数据库驱动网站</em> 在后台连接数据库服务器，从中取出一些数据，然后在 Web 页面用漂亮的格式展示这些数据。 这个网站也许也提供网站访问者取得自己数据库的方法。</p>
<p>许多复杂的网站都提供了以上两个功能的某种结合。 例如 Amazon.com 就是一个数据库驱动站点的良好范例。 本质上，每个产品页都是从数据库中取出的数据被格式化为 HTML，而当你发表客户评论时，该评论被插入评论数据库中。</p>
<p>由于先天具备 Python 简单而强大的数据库查询执行方法，Django 非常适合开发数据库驱动网站。 本章深入介绍了该功能： Django 数据库层。</p>
<p>（注意： 尽管对 Django 数据库层的使用中并不特别强调，我们还是强烈建议掌握一些数据库和 SQL 原理。 对这些概念的介绍超越了本书的范围，但就算你是数据库方面的菜鸟，我们也建议你继续阅读。 你也许能够跟上进度，并在上下文学习过程中掌握一些概念。</p>

<h2  >在视图中进行数据库查询的笨方法</h2>
<p>正如第三章详细介绍的那个在视图中输出 HTML 的笨方法（通过在视图里对文本直接硬编码HTML），在视图中也有笨方法可以从数据库中获取数据。 很简单：
用现有的任何 Python 类库执行一条 SQL 查询并对结果进行一些处理。</p>
<p>在本例的视图中，我们使用了 <tt >MySQLdb</tt> 类库（可以从 <a  href="http://www.djangoproject.com/r/python-mysql/">http://www.djangoproject.com/r/python-mysql/</a> 获得）来连接 MySQL 数据库，取回一些记录，将它们提供给模板以显示一个网页：</p>
<pre class="code">
from django.shortcuts import render_to_response
import MySQLdb

def book_list(request):
    db = MySQLdb.connect(user='me', db='mydb', passwd='secret', host='localhost')
    cursor = db.cursor()
    cursor.execute('SELECT name FROM books ORDER BY name')
    names = [row[0] for row in cursor.fetchall()]
    db.close()
    return render_to_response('book_list.html', {'names': names})
</pre>
<p>这个方法可用，但很快一些问题将出现在你面前：</p>
<ul >
<li  ><p>我们将数据库连接参数硬行编码于代码之中。 理想情况下，这些参数应当保存在 Django 配置中。</p>
</li>
</ul>
<ul >
<li  ><p>我们不得不重复同样的代码： 创建数据库连接、创建数据库游标、执行某个语句、然后关闭数据库。 理想情况下，我们所需要应该只是指定所需的结果。</p>
</li>
</ul>
<ul >
<li  ><p>它把我们栓死在 MySQL 之上。 如果过段时间，我们要从 MySQL 换到 PostgreSQL，就不得不使用不同的数据库适配器（例如 <tt >psycopg</tt> 而不是 <tt >MySQLdb</tt> ），改变连接参数，根据 SQL 语句的类型可能还要修改SQL 。 理想情况下，应对所使用的数据库服务器进行抽象，这样一来只在一处修改即可变换数据库服务器。 （如果你正在建立一个开源的Django应用程序来尽可能让更多人使用的话，这个特性是非常适当的。）</p>
</li>
</ul>
<p>正如你所期待的，Django数据库层正是致力于解决这些问题。 以下提前揭示了如何使用 Django 数据库 API 重写之前那个视图。</p>
<pre class="code">
from django.shortcuts import render_to_response
from mysite.books.models import Book

def book_list(request):
    books = Book.objects.order_by('name')
    return render_to_response('book_list.html', {'books': books})
</pre>
<p>我们将在本章稍后的地方解释这段代码。 目前而言，仅需对它有个大致的认识。</p>


<h2  >MTV 开发模式</h2>
<p>在钻研更多代码之前，让我们先花点时间考虑下 Django 数据驱动 Web 应用的总体设计。</p>
<p>我们在前面章节提到过，Django 的设计鼓励松耦合及对应用程序中不同部分的严格分割。 遵循这个理念的话，要想修改应用的某部分而不影响其它部分就比较容易了。 在视图函数中，我们已经讨论了通过模板系统把业务逻辑和表现逻辑分隔开的重要性。 在数据库层中，我们对数据访问逻辑也应用了同样的理念。</p>
<p>把数据存取逻辑、业务逻辑和表现逻辑组合在一起的概念有时被称为软件架构的 <em>Model-View-Controller</em> (MVC)模式。 在这个模式中， Model 代表数据存取层，View 代表的是系统中选择显示什么和怎么显示的部分，Controller 指的是系统中根据用户输入并视需要访问模型，以决定使用哪个视图的那部分。</p>
<p>为什么用缩写？</p>
<p>像 MVC 这样的明确定义模式的主要用于改善开发人员之间的沟通。 与其告诉同事：</p>
<p>Django 紧紧地遵循这种 MVC 模式，可以称得上是一种 MVC 框架。 以下是 Django 中 M、V 和 C 各自的含义：</p>
<ul >
<li  ><p><em>M</em> ，数据存取部分，由django数据库层处理，本章要讲述的内容。</p>
</li>
</ul>
<ul >
<li  ><p><em>V</em> ，选择显示哪些数据要及怎样显示的部分，由视图和模板处理。</p>
</li>
</ul>
<ul >
<li  ><p><em>C</em> ，根据用户输入委派视图的部分，由 Django 框架通过按照 URLconf 设置，对给定 URL 调用合适的 python 函数来自行处理。</p>
</li>
</ul>
<p>由于 C 由框架自行处理，而 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），Django 也被称为 <em>MTV 框架</em> 。在 MTV 开发模式中：</p>
<ul >
<li  ><p><em>M</em> 代表模型（Model），即数据存取层。 该层处理与数据相关的所有事务： 如何存取、如何确认有效性、包含哪些行为以及数据之间的关系等。</p>
</li>
</ul>
<ul >
<li  ><p><em>T</em> 代表模板(Template)，即表现层。 该层处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。</p>
</li>
</ul>
<ul >
<li  ><p><em>V</em> 代表视图（View），即业务逻辑层。 该层包含存取模型及调取恰当模板的相关逻辑。 你可以把它看作模型与模板之间的桥梁。</p>
</li>
</ul>
<p>如果你熟悉其它的 MVC Web开发框架，比方说 Ruby on Rails，你可能会认为 Django 视图是控制器，而 Django 模板是视图。 很不幸，这是对 MVC 不同诠释所引起的错误认识。 在 Django 对 MVC 的诠释中，视图用来描述要展现给用户的数据；不是数据看起来 <em>怎么样</em> ,而是要呈现 <em>哪些</em> 数据。 相比之下，Ruby on Rails 及一些同类框架提倡控制器负责决定向用户展现哪些数据，而视图则仅决定 <em>如何</em> 展现数据，而不是展现 <em>哪些</em> 数据。</p>
<p>两种诠释中没有哪个更加正确一些。 重要的是要理解底层概念。</p>


<h2  >数据库配置</h2>
<p>记住这些理念之后，让我们来开始 Django 数据库层的探索。 首先，我们需要做些初期配置；我们需要告诉Django使用什么数据库以及如何连接数据库。</p>
<p>我们将假定你已经完成了数据库服务器的安装和激活，并且已经在其中创建了数据库（例如，用 <tt >CREATE DATABASE</tt> 语句）。 如果你使用SQLite，不需要这步安装，因为SQLite使用文件系统上的独立文件来存储数据。</p>
<p>象前面章节提到的 <tt >TEMPLATE_DIRS</tt> 一样，数据库配置也是在Django的配置文件里，缺省 是 <tt >settings.py</tt> 。 打开这个文件并查找数据库配置：</p>
<pre class="code">
DATABASE_ENGINE = ''
DATABASE_NAME = ''
DATABASE_USER = ''
DATABASE_PASSWORD = ''
DATABASE_HOST = ''
DATABASE_PORT = ''
</pre>
<p>配置纲要如下。</p>
<blockquote>
<p><tt >DATABASE_ENGINE</tt> 告诉Django使用哪个数据库引擎。 如果你在 Django 中使用数据库， <tt >DATABASE_ENGINE</tt> 必须是 Table 5-1 中所列出的值。</p>
<table  >
<caption>表 5-1.  数据库引擎设置</caption>
<thead valign="bottom">
<tr><th >设置</th>
<th >数据库</th>
<th >必要的适配器</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>`` postgresql``</td>
<td>PostgreSQL</td>
<td><tt >psycopg</tt> 1.x版，
<a  href="http://www.djangoproject.com/r/python-pgsql/1/">http://www.djangoproject.com/r/python-pgsql/1/</a>。</td>
</tr>
<tr><td><tt >postgresql_psycopg2</tt></td>
<td>PostgreSQL</td>
<td><tt >psycopg</tt> 2.x版，
<a  href="http://www.djangoproject.com/r/python-pgsql/">http://www.djangoproject.com/r/python-pgsql/</a>。</td>
</tr>
<tr><td><tt >mysql</tt></td>
<td>MySQL</td>
<td><tt >MySQLdb</tt> ,
<a  href="http://www.djangoproject.com/r/python-mysql/">http://www.djangoproject.com/r/python-mysql/</a>.</td>
</tr>
<tr><td><tt >sqlite3</tt></td>
<td>SQLite</td>
<td>如果使用Python 2.5+则不需要适配器。 否则就使用 <tt >pysqlite</tt> ，
<a  href="http://www.djangoproject.com/r/python-sqlite/">http://www.djangoproject.com/r/python-sqlite/</a>。</td>
</tr>
<tr><td><tt >oracle</tt></td>
<td>Oracle</td>
<td><tt >cx_Oracle</tt> ,
<a  href="http://www.djangoproject.com/r/python-oracle/">http://www.djangoproject.com/r/python-oracle/</a>.</td>
</tr>
</tbody>
</table>
<p>要注意的是无论选择使用哪个数据库服务器，都必须下载和安装对应的数据库适配器。 访问表 5-1 中“所需适配器”一栏中的链接，可通过互联网免费获取这些适配器。 如果你使用Linux，你的发布包管理系统会提供方便包。 比如说查找`` python-postgresql`` 或者`` python-psycopg`` 的软件包。</p>
<p>配置示例：</p>
</blockquote>
<pre class="code">
DATABASE_ENGINE = 'postgresql_psycopg2'
</pre>
<blockquote>
<p><tt >DATABASE_NAME</tt> 将数据库名称告知 Django 。 例如：</p>
</blockquote>
<pre class="code">
DATABASE_NAME = 'mydb'
</pre>
<blockquote>
<p>如果使用 SQLite，请对数据库文件指定完整的文件系统路径。
例如：</p>
</blockquote>
<pre class="code">
DATABASE_NAME = '/home/django/mydata.db'
</pre>
<blockquote>
<p>对于SQLite数据库的存放，这个例子将其存放在/home/django目录下，你可以使用任意对你来说最便捷的目录。</p>
<p><tt >DATABASE_USER</tt> 告诉 Django 用哪个用户连接数据库。 例如： 如果用SQLite，空白即可。</p>
<p><tt >DATABASE_PASSWORD</tt> 告诉Django连接用户的密码。 SQLite 用空密码即可。</p>
<p><tt >DATABASE_HOST</tt> 告诉 Django 连接哪一台主机的数据库服务器。 如果数据库与 Django 安装于同一台计算机（即本机），可将此项保留空白。
如果你使用SQLite，此项留空。</p>
<p>此处的 MySQL 是一个特例。 如果使用的是 MySQL 且该项设置值由斜杠（ <tt >'/'</tt> ）开头，MySQL 将通过 Unix socket 来连接指定的套接字，例如：</p>
</blockquote>
<pre class="code">
DATABASE_HOST = '/var/run/mysql'
</pre>
<p>一旦在输入了那些设置并保存之后应当测试一下你的配置。 我们可以在`` mysite`` 项目目录下执行上章所提到的`` python manage.py shell`` 来进行测试。 （我们上一章有提到在正确的Django配置前提下，`` manager.py shell`` 命令是启用Python交互解释器的一种方法。） 这个方法在这里是很有必要的，因为Django可以通过它知晓数据库连接信息的配置文件</p>
<p>输入下面这些命令来测试你的数据库配置：</p>
<pre class="code">
&gt;&gt;&gt; from django.db import connection
&gt;&gt;&gt; cursor = connection.cursor()
</pre>
<p>如果没有显示什么错误信息，那么你的数据库配置是正确的。 否则，你就得 查看错误信息来纠正错误。 表 5-2 是一些常见错误。</p>
<table  >
<caption>表 5-2. 数据库配置错误信息</caption>
<thead valign="bottom">
<tr><th >错误信息</th>
<th >解决方法</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>You haven&#8217;t set the
DATABASE_ENGINE
setting yet.</td>
<td>未正确配置`` DATABASE_ENGINE`` 的值。
表格 5-1 列出可用的值。</td>
</tr>
<tr><td>Environment variable
DJANGO_SETTINGS_MODULE
is undefined.</td>
<td>使用`` python manager.py shell`` 命令启动的交互解释器，而非`` python`` 命令启动的交互解释器。</td>
</tr>
<tr><td>Error loading _____
module: No module
named _____.</td>
<td>未安装合适的数据库适配器 (例如, <tt >psycopg</tt> 或 <tt >MySQLdb</tt> ).</td>
</tr>
<tr><td>_____ isn&#8217;t an
available database
backend.</td>
<td>设置正确的 <tt >DATABASE_ENGINE</tt> 配置。 也许是拼写错误？</td>
</tr>
<tr><td>database _____ does
not exist</td>
<td>设置`` DATABASE_NAME`` 指向存在的数据库，或者先在数据库客户端中执行合适的`` CREATE DATABASE`` 语句创建数据库。</td>
</tr>
<tr><td>role _____ does not
exist</td>
<td>设置`` DATABASE_USER`` 指向存在的用户，或者先在数据库客户端中执创建用户。</td>
</tr>
<tr><td>could not connect to
server</td>
<td>查看DATABASE_HOST和DATABASE_PORT是否已正确配置，并确认数据库服务器是否已正常运行。</td>
</tr>
</tbody>
</table>


<h2  >第一个应用程序</h2>
<p>你现在已经确认数据库连接正常工作了，让我们来创建一个 <em>Django app</em> ，开始编码模型和视图。</p>
<p>在这里要先解释一些术语，初学者可能会混淆它们。 在第二章我们已经创建了 <em>project</em> , 那么 <em>project</em> 和 <em>app</em> 之间到底有什么不同呢？ 它们的区别就是一个是配置另一个是代码：</p>
<blockquote>
<p>一个project包含很多个Django app以及对它们的配置。</p>
<p>技术上，project的作用是提供配置文件，比方说哪里定义数据库连接信息, 安装的app列表， <tt >TEMPLATE_DIRS</tt> ，等等。</p>
<p>一个app是一套Django功能的集合，通常包括模型和视图，按Python的包结构的方式存在。</p>
<p>例如，Django本身内建有一些app，例如注释系统和自动管理界面。 app的一个关键点是它们是很容易移植到其他project和被多个project重用。</p>
</blockquote>
<p>对于如何架构Django代码并没有快速成套的规则。 如果你只是建造一个简单的web站点，那么可能你只需要一个app就可以了； 但如果是一个包含许多不相关的模块的复杂的网站，例如电子商务和社区之类的站点，那么你可能需要把这些模块划分成不同的app，以便以后重用。</p>
<p>确实，你还可以不用创建app，例如以前写的视图，只是简单的放在 views.py 。 在之前那些例子中，我们只是简单的创建了一个称为views.py的文件，编写了一些函数并将在URLconf中设置各个函数的映射。 这些情况都不需要使用apps。</p>
<p>但是，系统对app有一个约定： 如果你使用了Django的数据库层（模型），你 必须创建一个django app。 模型必须存放在apps中。 因此，为了开始建造 我们的模型，我们必须创建一个新的app。</p>
<p>在`` mysite`` 项目文件下输入下面的命令来创建`` books``  app</p>
<pre class="code">
python manage.py startapp books
</pre>
<p>这个命令并没有输出什么，它只在 <tt >mysite</tt> 的目录里创建了一个 <tt >books</tt> 目录。 让我们来看看这个目录的内容：</p>
<pre class="code">
books/
    __init__.py
    models.py
    tests.py
    views.py
</pre>
<p>这个目录包含了这个app的模型和视图。</p>
<p>看一下 <tt >models.py</tt> 和 <tt >views.py</tt> 文件。 它们都是空的，除了 <tt >models.py</tt> 里有一个 import。</p>


<h2  >在Python代码里定义模型</h2>
<p>我们早些时候谈到。 MTV里的M代表模型。 Django模型是用Python代码形式表述的数据在数据库 中的定义。 对数据层来说它等同于 <tt >CREATE TABLE</tt> 语句，只不过执行的是Python代码而不是 SQL，而且还包含了比数据库字段定义更多的含义。
Django用模型在后台执行SQL代码并把结果 用Python的数据结构来描述，这样你可以很方便的使用这些数据。</p>
<p>如果你对数据库很熟悉，你可能马上就会想到，用Python <em>和</em> SQL来定义数据模型是不是有点多余？ Django这样做是有下面几个原因的：</p>
<blockquote>
<p>自省（运行时自动识别数据库）会导致过载和有数据完整性问题。 为了提供方便的数据访问API， Django需要以 <em>某种方式</em> 知道数据库层内部信息，有两种实现方式。
第一种方式是用Python明确的定义数据模型，第二种方式是通过运行时扫描数据库来自动侦测识别数据模型。</p>
<p>第二种方式看起来更清晰，因为数据表信息只存放在一个地方-数据库里，但是会带来一些问题。 首先，运行时扫描数据库会带来严重的系统过载。 如果每个请求都要扫描数据库的表结构，或者即便是 服务启动时做一次都是会带来不能接受的系统过载。
（有人认为这个程度的系统过载是可以接受的，而Django开发者的目标是尽可能地降低框架的系统过载）。第二，某些数据库，尤其是老版本的MySQL,并未完整存储那些精确的自省元数据。</p>
<p>编写Python代码是非常有趣的，保持用Python的方式思考会避免你的大脑在不同领域来回切换。 这可以帮助你提高生产率。 不得不去重复写SQL，再写Python代码，再写SQL，&#8230;，会让你头都要裂了。</p>
<p>把数据模型用代码的方式表述来让你可以容易对它们进行版本控制。 这样，你可以很容易了解数据层 的变动情况。</p>
<p>SQL只能描述特定类型的数据字段。 例如，大多数数据库都没有数据字段类型描述Email地址、URL。 而用Django的模型可以做到这一点。 好处就是高级的数据类型带来高生产力和更好的代码重用。</p>
<p>SQL还有在不同数据库平台的兼容性问题。 你必须为不同的数据库编写不同的SQL脚本， 而Python的模块就不会有这个问题。</p>
</blockquote>
<p>当然，这个方法也有一个缺点，就是Python代码和数据库表的同步问题。 如果你修改了一个Django模型， 你要自己做工作来保证数据库和模型同步。 我们将在稍后讲解解决这个问题的几种策略。</p>
<p>最后,我们要提醒你Django提供了实用工具来从现有的数据库表中自动扫描生成模型。 这对已有的数据库来说是非常快捷有用的。 我们将在第18章中对此进行讨论。</p>


<h2  >第一个模型</h2>
<p>在本章和后续章节里，我们将集中到一个基本的 书籍/作者/出版商 数据层上。 我们这样做是因为 这是一个众所周知的例子，很多SQL有关的书籍也常用这个举例。 你现在看的这本书也是由作者 创作再由出版商出版的哦！</p>
<p>我们来假定下面的这些概念、字段和关系：</p>
<ul >
<li  ><p>一个作者有姓，有名及email地址。</p>
</li>
</ul>
<ul >
<li  ><p>出版商有名称，地址，所在城市、省，国家，网站。</p>
</li>
</ul>
<ul >
<li  ><p>书籍有书名和出版日期。 它有一个或多个作者（和作者是多对多的关联关系[many-to-many]）， 只有一个出版商（和出版商是一对多的关联关系[one-to-many]，也被称作外键[foreign key]）</p>
</li>
</ul>
<p>第一步是用Python代码来描述它们。 打开由`` startapp`` 命令创建的<tt >models.py</tt> 并输入下面的内容：</p>
<pre class="code">
from django.db import models

class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField()

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()
</pre>
<p>让我们来快速讲解一下这些代码的含义。 首先要注意的事是每个数据模型都是 <tt >django.db.models.Model</tt> 的子类。 它的父类 <tt >Model</tt> 包含了所有和数据库 打交道的方法，并提供了一个简洁漂亮的定义语法。</p>
<p>每个模型相当于单个数据库表，每个属性也是这个表中的一个字段。 属性名就是字段名，它的类型（例如 <tt >CharField</tt> ）相当于数据库的字段类型 （例如 <tt >varchar</tt> ）。例如， <tt >Publisher</tt> 模块等同于下面这张表（用Postgresql 的 <tt >CREATE TABLE</tt> 语法描述）：</p>
<pre class="code">
CREATE TABLE &quot;books_publisher&quot; (
    &quot;id&quot; serial NOT NULL PRIMARY KEY,
    &quot;name&quot; varchar(30) NOT NULL,
    &quot;address&quot; varchar(50) NOT NULL,
    &quot;city&quot; varchar(60) NOT NULL,
    &quot;state_province&quot; varchar(30) NOT NULL,
    &quot;country&quot; varchar(50) NOT NULL,
    &quot;website&quot; varchar(200) NOT NULL
);
</pre>
<p>事实上，正如过一会儿我们所要展示的，Django 可以自动生成这些 <tt >CREATE TABLE</tt> 语句。</p>
<p>“每个数据库表对应一个类”这条规则的例外情况是多对多关系。 在我们的范例模型中， <tt >Book</tt> 有一个 <tt >多对多字段</tt> 叫做 <tt >authors</tt> 。 该字段表明一本书籍有一个或多个作者，但 <tt >Book</tt> 数据库表却并没有 <tt >authors</tt> 字段。
相反，Django创建了一个额外的表（多对多连接表）来处理书籍和作者之间的映射关系。</p>
<p>请查看附录 B 了解所有的字段类型和模型语法选项。</p>
<p>最后需要注意的是： 我们并没有显式地为这些模型定义任何主键。</p>


<h2  >模型安装</h2>
<p>完成这些代码之后，现在让我们来在数据库中创建这些表。 要完成该项工作，第一步是在 Django 项目中 <em>激活</em> 这些模型。 将 <tt >books</tt> app 添加到配置文件的已 installed apps 列表中即可完成此步骤。</p>
<p>再次编辑 <tt >settings.py</tt> 文件， 找到 <tt >INSTALLED_APPS</tt> 设置。 <tt >INSTALLED_APPS</tt> 告诉 Django 项目哪些 app 处于激活状态。 缺省情况下如下所示：</p>
<pre class="code">
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
)
</pre>
<p>把这四个设置前面加#临时注释起来。 （这四个app是经常使用到的，我们将在后续章节里讨论如何使用它们）。同时，注释掉MIDDLEWARE_CLASSES的默认设置条目，因为这些条目是依赖于刚才我们刚在INSTALLED_APPS注释掉的apps。
然后，添加`` &#8216;mysite.books&#8217;`` 到`` INSTALLED_APPS`` 的末尾，此时设置的内容看起来应该是这样的：</p>
<pre class="code">
MIDDLEWARE_CLASSES = (
    # 'django.middleware.common.CommonMiddleware',
    # 'django.contrib.sessions.middleware.SessionMiddleware',
    # 'django.contrib.auth.middleware.AuthenticationMiddleware',
)

INSTALLED_APPS = (
    # 'django.contrib.auth',
    # 'django.contrib.contenttypes',
    # 'django.contrib.sessions',
    # 'django.contrib.sites',
    'mysite.books',
)
</pre>
<p>(就像我们在上一章设置TEMPLATE_DIRS所提到的逗号，同样在INSTALLED_APPS的末尾也需添加一个逗号，因为这是个单元素的元组。 另外，本书的作者喜欢在 <em>每一个</em> tuple元素后面加一个逗号，不管它是不是 只有一个元素。 这是为了避免忘了加逗号)</p>
<p><tt >'mysite.books'</tt> 标识 <tt >books</tt> app。 <tt >INSTALLED_APPS</tt> 中的每个app都用 Python的路径描述，包的路径，用小数点(.)区分。</p>
<p>现在我们可以创建数据库表了。 首先，用下面的命令对校验模型的有效性：</p>
<pre class="code">
python manage.py validate
</pre>
<p><tt >validate</tt> 命令检查你的模型的语法和逻辑是否正确。 如果一切正常，你会看到 <tt >0 errors found</tt> 消息。 如果有问题，它会给出非常有用的错误信息来帮助你 修正你的模型。</p>
<p>一旦你觉得你的模型可能有问题，运行 <tt >python manage.py validate</tt> 。 它可以帮助你捕获一些常见的模型定义错误。</p>
<p>模型确认没问题了，运行下面的命令来生成 <tt >CREATE TABLE</tt> 语句：</p>
<pre class="code">
python manage.py sqlall books
</pre>
<p>在这个命令行中， <tt >books</tt> 是app的名称。 和你运行 <tt >manage.py startapp</tt> 中的一样。</p>
<pre class="code">
BEGIN;
CREATE TABLE &quot;books_publisher&quot; (
    &quot;id&quot; serial NOT NULL PRIMARY KEY,
    &quot;name&quot; varchar(30) NOT NULL,
    &quot;address&quot; varchar(50) NOT NULL,
    &quot;city&quot; varchar(60) NOT NULL,
    &quot;state_province&quot; varchar(30) NOT NULL,
    &quot;country&quot; varchar(50) NOT NULL,
    &quot;website&quot; varchar(200) NOT NULL
)
;
CREATE TABLE &quot;books_author&quot; (
    &quot;id&quot; serial NOT NULL PRIMARY KEY,
    &quot;first_name&quot; varchar(30) NOT NULL,
    &quot;last_name&quot; varchar(40) NOT NULL,
    &quot;email&quot; varchar(75) NOT NULL
)
;
CREATE TABLE &quot;books_book&quot; (
    &quot;id&quot; serial NOT NULL PRIMARY KEY,
    &quot;title&quot; varchar(100) NOT NULL,
    &quot;publisher_id&quot; integer NOT NULL REFERENCES &quot;books_publisher&quot; (&quot;id&quot;) DEFERRABLE INITIALLY DEFERRED,
    &quot;publication_date&quot; date NOT NULL
)
;
CREATE TABLE &quot;books_book_authors&quot; (
    &quot;id&quot; serial NOT NULL PRIMARY KEY,
    &quot;book_id&quot; integer NOT NULL REFERENCES &quot;books_book&quot; (&quot;id&quot;) DEFERRABLE INITIALLY DEFERRED,
    &quot;author_id&quot; integer NOT NULL REFERENCES &quot;books_author&quot; (&quot;id&quot;) DEFERRABLE INITIALLY DEFERRED,
    UNIQUE (&quot;book_id&quot;, &quot;author_id&quot;)
)
;
CREATE INDEX &quot;books_book_publisher_id&quot; ON &quot;books_book&quot; (&quot;publisher_id&quot;);
COMMIT;
</pre>
<p>注意：</p>
<ul >
<li  ><p>自动生成的表名是app名称（ <tt >books</tt> ）和模型的小写名称 （ <tt >publisher</tt> , <tt >book</tt> , <tt >author</tt> )的组合。</p>
</li>
</ul>
<ul >
<li  ><p>我们前面已经提到，Django为每个表格自动添加加了一个 <tt >id</tt> 主键，
你可以重新设置它。</p>
</li>
</ul>
<ul >
<li  ><p>按约定，Django添加 <tt >&quot;_id&quot;</tt> 后缀到外键字段名。 这个同样也是可自定义的。</p>
</li>
</ul>
<ul >
<li  ><p>外键是用 <tt >REFERENCES</tt> 语句明确定义的。</p>
</li>
</ul>
<ul >
<li  ><p>这些 <tt >CREATE TABLE</tt> 语句会根据你的数据库而作调整，这样象数据库特定的一些字段例如： <tt >auto_increment</tt> (MySQL), <tt >serial</tt> (PostgreSQL), <tt >integer primary key</tt> (SQLite) 可以自动处理。 同样的，字段名称也是自动处理（例如单引号还好是双引号）。</p>
</li>
</ul>
<p><tt >sqlall</tt> 命令并没有在数据库中真正创建数据表，只是把SQL语句段打印出来。 如果要创建数据表，你可以复制那些SQL语句到你使用数据库客户端后执行，或者通过Unix管道直接进行操作（例如，`` python manager.py sqlall books | psql mydb`` ）。不过，Django提供了一种更为简易的提交SQL语句至数据库的方法： `` syncdb`` 命令</p>
<pre class="code">
python manage.py syncdb
</pre>
<p>执行这个命令后，将看到类似以下的内容：</p>
<pre class="code">
Creating table books_publisher
Creating table books_author
Creating table books_book
Installing index for books.Book model
</pre>
<p><tt >syncdb</tt> 命令是同步你的模型到数据库的一个简单方法。 它会根据 <tt >INSTALLED_APPS</tt> 里设置的app来检查数据库， 如果表不存在，它就会创建它。 需要注意的是， <tt >syncdb</tt> 并 <em>不能</em> 同步模型的修改到数据库。 （本章的最后将详细讨论修改数据库的架构）</p>
<p>如果你再次运行 <tt >python manage.py syncdb</tt> ，什么也没发生，因为你没有添加新的模型或者 添加新的app。</p>
<p>如果你有兴趣，花点时间用你的SQL客户端登录进数据库服务器看看刚才Django创建的数据表。 你可以手动启动命令行客户端（例如，执行PostgreSQL的`` psql`` 命令），也可以执行 `` python manage.py dbshell``  ，这个命令将依据`` DATABASE_SERVER`` 的里设置自动检测使用何种命令行客户端。 常言说，后来者居上。</p>


<h2  >基本数据访问</h2>
<p>一旦你创建了模型，Django自动为这些模型提供了高级的Python API。 运行 <tt >python manage.py shell</tt> 并输入下面的内容试试看：</p>
<pre class="code">
&gt;&gt;&gt; from books.models import Publisher
&gt;&gt;&gt; p1 = Publisher(name='Apress', address='2855 Telegraph Avenue',
...     city='Berkeley', state_province='CA', country='U.S.A.',
...     website='http://www.apress.com/')
&gt;&gt;&gt; p1.save()
&gt;&gt;&gt; p2 = Publisher(name=&quot;O'Reilly&quot;, address='10 Fawcett St.',
...     city='Cambridge', state_province='MA', country='U.S.A.',
...     website='http://www.oreilly.com/')
&gt;&gt;&gt; p2.save()
&gt;&gt;&gt; publisher_list = Publisher.objects.all()
&gt;&gt;&gt; publisher_list
[&lt;Publisher: Publisher object&gt;, &lt;Publisher: Publisher object&gt;]
</pre>
<p>这短短几行代码干了不少的事。 这里简单的说一下：</p>
<ul >
<li  ><p>首先，导入Publisher模型类， 通过这个类我们可以与包含 出版社 的数据表进行交互。</p>
</li>
</ul>
<ul >
<li  ><p>接着，创建一个`` Publisher`` 类的实例并设置了字段`` name, address`` 等的值。</p>
</li>
</ul>
<ul >
<li  ><p>调用该对象的 <tt >save()</tt> 方法，将对象保存到数据库中。 Django 会在后台执行一条 <tt >INSERT</tt> 语句。</p>
</li>
</ul>
<ul >
<li  ><p>最后，使用`` Publisher.objects`` 属性从数据库取出出版商的信息，这个属性可以认为是包含出版商的记录集。 这个属性有许多方法， 这里先介绍调用`` Publisher.objects.all()`` 方法获取数据库中`` Publisher`` 类的所有对象。这个操作的幕后，Django执行了一条SQL `` SELECT`` 语句。</p>
</li>
</ul>
<p>这里有一个值得注意的地方，在这个例子可能并未清晰地展示。 当你使用Django modle API创建对象时Django并未将对象保存至数据库内，除非你调用`` save()`` 方法：</p>
<pre class="code">
p1 = Publisher(...)
# At this point, p1 is not saved to the database yet!
p1.save()
# Now it is.
</pre>
<p>如果需要一步完成对象的创建与存储至数据库，就使用`` objects.create()`` 方法。 下面的例子与之前的例子等价：</p>
<pre class="code">
&gt;&gt;&gt; p1 = Publisher.objects.create(name='Apress',
...     address='2855 Telegraph Avenue',
...     city='Berkeley', state_province='CA', country='U.S.A.',
...     website='http://www.apress.com/')
&gt;&gt;&gt; p2 = Publisher.objects.create(name=&quot;O'Reilly&quot;,
...     address='10 Fawcett St.', city='Cambridge',
...     state_province='MA', country='U.S.A.',
...     website='http://www.oreilly.com/')
&gt;&gt;&gt; publisher_list = Publisher.objects.all()
&gt;&gt;&gt; publisher_list
</pre>
<p>自然，你肯定想执行更多的Django数据库API试试看，不过，还是让我们先解决一点烦人的小问题。</p>


<h2  >添加模块的字符串表现</h2>
<p>当我们打印整个publisher列表时，我们没有得到想要的有用的信息：</p>
<pre class="code">
[&lt;Publisher: Publisher object&gt;, &lt;Publisher: Publisher object&gt;]
</pre>
<p>我们可以简单解决这个问题，只需要添加一个方法 <tt >__unicode__()</tt> 到 <tt >Publisher</tt> 对象。 <tt >__unicode__()</tt> 方法告诉Python如何实现对象的unicode表示。 请看下面：</p>
<pre class="code">
from django.db import models

class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

    **def __unicode__(self):**
        **return self.name**

class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField()

    **def __unicode__(self):**
        **return u'%s %s' % (self.first_name, self.last_name)**

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()

    **def __unicode__(self):**
        **return self.title**
</pre>
<p>就象你看到的一样， <tt >__unicode__()</tt> 方法可以进行任何处理来返回对一个对象的表示。 <tt >__str__()</tt> 必须返回字符串， 如果是其他类型，Python将会抛出 <tt >TypeError</tt> 错误消息 <tt >&quot;__str__ returned non-string&quot;</tt> 出来。</p>
<p>对__unicode__()的唯一要求就是它要返回一个unicode对象 如果`` __unicode__()`` 方法未返回一个Unicode对象，而返回比如说一个整型数字，那么Python将抛出一个`` TypeError`` 错误，并提示：&#8221;coercing to Unicode: need string or buffer, int found&#8221; 。</p>
<p>Unicode对象</p>
<p>什么是Unicode对象呢？</p>
<p>你可以认为一个unicode对象就是一个python的可以处理不仅上百万不同类别字符的字符串——从古老版本的Latin字符到非Latin字符，再到曲折的引用和艰涩的符号。</p>
<p>普通的python字符串是经过<a href="#id9">**</a>，意思就是它们已经经过某种编码（如ASCII，ISO-8859-1或者UTF-8）来编码。 如果你在保存奇特的字符（其它任何超出标准128个如0-9和A-Z之类的ASCII字符）在一个普通的python字符串里，你一定要跟踪你的字符串是用什么编码的，否则这些奇特的字符可能会在显示或者打印的时候出现乱码。 当你尝试要将用某种编码保存的数据结合到另外一种编码的数据中，或者你想要把它显示在已经假定了某种编码的程序中的时候，问题就会发生。 我们都已经见到过网页和邮件被???弄得乱七八糟。 ?????? 或者其它出现在奇怪位置的字符：这一般来说就是存在编码问题了。</p>

<p>System Message: WARNING/2 (<tt >&lt;string&gt;</tt>, line 944); <em><a href="#id10">backlink</a></em></p>
<p>Inline strong start-string without end-string.</p>

<p>但是Unicode对象并没有编码。它们使用Unicode，一个一致的，通用的字符编码集。 当你在Python中处理Unicode对象的时候，你可以直接将它们混合使用和互相匹配而不必去考虑编码细节。</p>
<p>Django 在其内部的各个方面都使用到了 Unicode 对象。 模型 对象中，检索匹配方面的操作使用的是 Unicode 对象，视图 函数之间的交互使用的是 Unicode 对象，模板的渲染也是用的 Unicode 对象。 通常，我们不必担心编码是否正确，后台会处理的很好。</p>
<p>注意，我们这里只是对Unicode对象进行非常浅显的概述，若要深入了解你可能需要查阅相关的资料。 一个很好的起点在：http://www.joelonsoftware.com/articles/Unicode.html。</p>
<p>为了让我们的修改生效，先退出Python Shell，然后再次运行 <tt >python manage.py shell</tt> 进入。</p>
<pre class="code">
&gt;&gt;&gt; from books.models import Publisher
&gt;&gt;&gt; publisher_list = Publisher.objects.all()
&gt;&gt;&gt; publisher_list
[&lt;Publisher: Apress&gt;, &lt;Publisher: O'Reilly&gt;]
</pre>
<p>请确保你的每一个模型里都包含 <tt >__unicode__()</tt> 方法，这不只是为了交互时方便，也是因为 Django会在其他一些地方用 <tt >__unicode__()</tt> 来显示对象。</p>
<p>最后， <tt >__unicode()__</tt> 也是一个很好的例子来演示我们怎么添加 <em>行为</em> 到模型里。 Django的模型不只是为对象定义了数据库表的结构，还定义了对象的行为。 <tt >__unicode__()</tt> 就是一个例子来演示模型知道怎么显示它们自己。</p>


<h2  >插入和更新数据</h2>
<p>你已经知道怎么做了： 先使用一些关键参数创建对象实例，如下：</p>
<pre class="code">
&gt;&gt;&gt; p = Publisher(name='Apress',
...         address='2855 Telegraph Ave.',
...         city='Berkeley',
...         state_province='CA',
...         country='U.S.A.',
...         website='http://www.apress.com/')
</pre>
<p>这个对象实例并 <em>没有</em> 对数据库做修改。 在调用`` save()`` 方法之前，记录并没有保存至数据库，像这样：</p>
<pre class="code">
&gt;&gt;&gt; p.save()
</pre>
<p>在SQL里，这大致可以转换成这样：</p>
<pre class="code">
INSERT INTO books_publisher
    (name, address, city, state_province, country, website)
VALUES
    ('Apress', '2855 Telegraph Ave.', 'Berkeley', 'CA',
     'U.S.A.', 'http://www.apress.com/');
</pre>
<p>因为 <tt >Publisher</tt> 模型有一个自动增加的主键 <tt >id</tt> ，所以第一次调用 <tt >save()</tt> 还多做了一件事： 计算这个主键的值并把它赋值给这个对象实例：</p>
<pre class="code">
&gt;&gt;&gt; p.id
52    # this will differ based on your own data
</pre>
<p>接下来再调用 <tt >save()</tt> 将不会创建新的记录，而只是修改记录内容（也就是 执行 <tt >UPDATE</tt> SQL语句，而不是 <tt >INSERT</tt> 语句）：</p>
<pre class="code">
&gt;&gt;&gt; p.name = 'Apress Publishing'
&gt;&gt;&gt; p.save()
</pre>
<p>前面执行的 <tt >save()</tt> 相当于下面的SQL语句：</p>
<pre class="code">
UPDATE books_publisher SET
    name = 'Apress Publishing',
    address = '2855 Telegraph Ave.',
    city = 'Berkeley',
    state_province = 'CA',
    country = 'U.S.A.',
    website = 'http://www.apress.com'
WHERE id = 52;
</pre>
<p>注意，并不是只修改来期望的那个字段，所有的字段都会被更新。
这个操作有可能引起竞态条件，取决于你的应用程序。 参阅后面的“更新多个对象”小节查看以下的查询与“更新多个对象”使用的方法之间的不同。</p>
<pre class="code">
UPDATE books_publisher SET
    name = 'Apress Publishing'
WHERE id=52;
</pre>


<h2  >选择对象</h2>
<p>当然，创建新的数据库，并更新之中的数据是必要的，但是，对于 Web 应用程序来说，更多的时候是在检索查询数据库。
我们已经知道如何从一个给定的模型中取出所有记录：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.all()
[&lt;Publisher: Apress&gt;, &lt;Publisher: O'Reilly&gt;]
</pre>
<p>这相当于这个SQL语句：</p>
<pre class="code">
SELECT id, name, address, city, state_province, country, website
FROM books_publisher;
</pre>
<p>注意</p>
<p>注意到Django在选择所有数据时并没有使用 <tt >SELECT*</tt> ，而是显式列出了所有字段。 就是这样设计的： <tt >SELECT*</tt> 会更慢，而且最重要的是列出所有字段遵循了Python 界的一个信条： 明确比不明确好。</p>
<p>有关Python之禅(戒律) :-），在Python提示行输入 <tt >import this</tt> 试试看。</p>
<p>让我们来仔细看看 <tt >Publisher.objects.all()</tt> 这行的每个部分：</p>
<blockquote>
<p>首先，我们有一个已定义的模型 <tt >Publisher</tt> 。没什么好奇怪的： 你想要查找数据， 你就用模型来获得数据。</p>
<p>其次， <tt >objects</tt> 是干什么的？ 它被称为管理器，我们将在第10章中详细讨论它。 目前，我们只需了解管理器管理着所有针对数据包含、还有最重要的数据查询的表格级操作。</p>
<p>所有的模型都自动拥有一个 <tt >objects</tt> 管理器；你可以在想要查找数据时是使用它。</p>
<p>最后，还有 <tt >all()</tt> 方法。 这是 <tt >objects</tt> 管理器返回所有记录的一个方法。 尽管这个对象 <em>看起来</em> 象一个列表（list），它实际是一个 <em>QuerySet</em> 对象， 这个对象是数据库中一些记录的集合。
附录C将详细描述QuerySet，现在，我们 就先当它是一个仿真列表对象好了。</p>
</blockquote>
<p>所有的数据库查找都遵循一个通用模式：</p>

<h3  >数据过滤</h3>
<p>我们很少会一次性从数据库中取出所有的数据；通常都只针对一部分数据进行操作。 在Django API中，我们可以使用`` filter()`` 方法对数据进行过滤：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.filter(name='Apress')
[&lt;Publisher: Apress&gt;]
</pre>
<p><tt >filter()</tt> 根据关键字参数来转换成 <tt >WHERE</tt> SQL语句。
前面这个例子 相当于这样：</p>
<pre class="code">
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name = 'Apress';
</pre>
<p>你可以传递多个参数到 <tt >filter()</tt> 来缩小选取范围：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.filter(country=&quot;U.S.A.&quot;, state_province=&quot;CA&quot;)
[&lt;Publisher: Apress&gt;]
</pre>
<p>多个参数会被转换成 <tt >AND</tt> SQL语句， 因此上面的代码可以转化成这样：</p>
<pre class="code">
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE country = 'U.S.A.'
AND state_province = 'CA';
</pre>
<p>注意，SQL缺省的 <tt >=</tt> 操作符是精确匹配的， 包含性查找可以使用：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.filter(name__contains=&quot;press&quot;)
[&lt;Publisher: Apress&gt;]
</pre>
<p>在 <tt >name</tt> 和 <tt >contains</tt> 之间有双下划线。</p>
<pre class="code">
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name LIKE '%press%';
</pre>
<p>其他的一些查找类型有： <tt >icontains</tt> (大小写无关的 <tt >LIKE</tt> ), <tt >startswith</tt> 和 <tt >endswith</tt> , 还有 <tt >range</tt> (SQL <tt >BETWEEN</tt> 查询）。</p>


<h3  >获取单个对象</h3>
<p>上面的例子中`` filter()`` 函数返回一个记录集，这个记录集是一个列表。
相对列表来说，有些时候我们更需要获取单个的对象， `` get()`` 方法就是在此时使用的：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.get(name=&quot;Apress&quot;)
&lt;Publisher: Apress&gt;
</pre>
<p>这样，就返回了单个对象，而不是列表（更准确的说，QuerySet)。 所以，如果结果是多个对象，会导致抛出异常：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.get(country=&quot;U.S.A.&quot;)
Traceback (most recent call last):
    ...
MultipleObjectsReturned: get() returned more than one Publisher --
    it returned 2! Lookup parameters were {'country': 'U.S.A.'}
</pre>
<p>如果查询没有返回结果也会抛出异常：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.get(name=&quot;Penguin&quot;)
Traceback (most recent call last):
    ...
DoesNotExist: Publisher matching query does not exist.
</pre>
<p>这个 <tt >DoesNotExist</tt> 异常 是 Publisher 这个 model 类的一个属性，即 <tt >Publisher.DoesNotExist</tt>。在你的应用中，你可以捕获并处理这个异常，像这样：</p>
<pre class="code">
try:
    p = Publisher.objects.get(name='Apress')
except Publisher.DoesNotExist:
    print &quot;Apress isn't in the database yet.&quot;
else:
    print &quot;Apress is in the database.&quot;
</pre>


<h3  >数据排序</h3>
<p>在运行前面的例子中，你可能已经注意到返回的结果是无序的。 我们还没有告诉数据库 怎样对结果进行排序，所以我们返回的结果是无序的。</p>
<p>在你的 Django 应用中，你或许希望对检索结果，根据某字段的值，按字母顺序排序。 那么，使用 <tt >order_by()</tt> 这个方法就可以搞定了。</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.order_by(&quot;name&quot;)
[&lt;Publisher: Apress&gt;, &lt;Publisher: O'Reilly&gt;]
</pre>
<p>跟以前的 <tt >all()</tt> 例子差不多，SQL语句里多了指定排序的部分：</p>
<pre class="code">
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
ORDER BY name;
</pre>
<p>我们可以对任意字段进行排序：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.order_by(&quot;address&quot;)
[&lt;Publisher: O'Reilly&gt;, &lt;Publisher: Apress&gt;]

&gt;&gt;&gt; Publisher.objects.order_by(&quot;state_province&quot;)
[&lt;Publisher: Apress&gt;, &lt;Publisher: O'Reilly&gt;]
</pre>
<p>如果需要以多个字段为标准进行排序（第二个字段会在第一个字段的值相同的情况下被使用到），使用多个参数就可以了，如下：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.order_by(&quot;state_province&quot;, &quot;address&quot;)
 [&lt;Publisher: Apress&gt;, &lt;Publisher: O'Reilly&gt;]
</pre>
<p>我们还可以指定逆向排序，在前面加一个减号 <tt >-</tt> 前缀：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.order_by(&quot;-name&quot;)
[&lt;Publisher: O'Reilly&gt;, &lt;Publisher: Apress&gt;]
</pre>
<p>每次都要用 <tt >order_by()</tt> 显得有点啰嗦。 大多数时间你通常只会对某些 字段进行排序。 在这种情况下，Django让你可以指定模型的缺省排序方式：</p>
<pre class="code">
class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

    def __unicode__(self):
        return self.name

    **class Meta:**
        **ordering = ['name']**
</pre>
<p>现在，让我们来接触一个新的概念。 <tt >class Meta</tt>，内嵌于 <tt >Publisher</tt> 这个类的定义中（如果 <tt >class Publisher</tt> 是顶格的，那么 <tt >class Meta</tt> 在它之下要缩进4个空格－－按 Python 的传统 ）。你可以在任意一个 模型 类中使用 <tt >Meta</tt> 类，来设置一些与特定模型相关的选项。 在 附录B 中有 <tt >Meta</tt> 中所有可选项的完整参考，现在，我们关注 <tt >ordering</tt> 这个选项就够了。 如果你设置了这个选项，那么除非你检索时特意额外地使用了 <tt >order_by()</tt>，否则，当你使用 Django 的数据库 API 去检索时，<tt >Publisher</tt>对象的相关返回值默认地都会按 <tt >name</tt> 字段排序。</p>


<h3  >连锁查询</h3>
<p>我们已经知道如何对数据进行过滤和排序。 当然，通常我们需要同时进行过滤和排序查询的操作。 因此，你可以简单地写成这种“链式”的形式：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.filter(country=&quot;U.S.A.&quot;).order_by(&quot;-name&quot;)
[&lt;Publisher: O'Reilly&gt;, &lt;Publisher: Apress&gt;]
</pre>
<p>你应该没猜错，转换成SQL查询就是 <tt >WHERE</tt> 和 <tt >ORDER BY</tt> 的组合：</p>
<pre class="code">
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE country = 'U.S.A'
ORDER BY name DESC;
</pre>


<h3  >限制返回的数据</h3>
<p>另一个常用的需求就是取出固定数目的记录。 想象一下你有成千上万的出版商在你的数据库里， 但是你只想显示第一个。 你可以这样做：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.order_by('name')[0]
&lt;Publisher: Apress&gt;
</pre>
<p>这相当于：</p>
<pre class="code">
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
ORDER BY name
LIMIT 1;
</pre>
<p>类似的，你可以用python的range-slicing语法来取出数据的特定子集</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.order_by('name')[0:2]
</pre>
<p>这个例子返回两个对象，等同于以下的SQL语句：</p>
<pre class="code">
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
ORDER BY name
OFFSET 0 LIMIT 2;
</pre>
<p>注意，不支持Python的负索引(negative slicing)：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.order_by('name')[-1]
Traceback (most recent call last):
  ...
AssertionError: Negative indexing is not supported.
</pre>
<p>虽然不支持负索引，但是我们可以使用其他的方法。 比如，稍微修改 order_by() 语句来实现：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.order_by('-name')[0]
</pre>


<h3  >更新多个对象</h3>
<p>在“插入和更新数据”小节中，我们有提到模型的save()方法，这个方法会更新一行里的所有列。 而某些情况下，我们只需要更新行里的某几列。</p>
<p>例如说我们现在想要将Apress Publisher的名称由原来的&#8221;Apress&#8221;更改为&#8221;Apress Publishing&#8221;。若使用save()方法，如：</p>
<pre class="code">
&gt;&gt;&gt; p = Publisher.objects.get(name='Apress')
&gt;&gt;&gt; p.name = 'Apress Publishing'
&gt;&gt;&gt; p.save()
</pre>
<p>这等同于如下SQL语句：</p>
<pre class="code">
SELECT id, name, address, city, state_province, country, website
FROM books_publisher
WHERE name = 'Apress';

UPDATE books_publisher SET
    name = 'Apress Publishing',
    address = '2855 Telegraph Ave.',
    city = 'Berkeley',
    state_province = 'CA',
    country = 'U.S.A.',
    website = 'http://www.apress.com'
WHERE id = 52;
</pre>
<p>（注意在这里我们假设Apress的ID为52）</p>
<p>在这个例子里我们可以看到Django的save()方法更新了不仅仅是name列的值，还有更新了所有的列。 若name以外的列有可能会被其他的进程所改动的情况下，只更改name列显然是更加明智的。 更改某一指定的列，我们可以调用结果集（QuerySet）对象的update()方法： 示例如下：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.filter(id=52).update(name='Apress Publishing')
</pre>
<p>与之等同的SQL语句变得更高效，并且不会引起竞态条件。</p>
<pre class="code">
UPDATE books_publisher
SET name = 'Apress Publishing'
WHERE id = 52;
</pre>
<p>update()方法对于任何结果集（QuerySet）均有效，这意味着你可以同时更新多条记录。
以下示例演示如何将Publisher的country字段值为&#8217;U.S.A&#8217;更改为&#8217;USA&#8217;：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.all().update(country='USA')
2
</pre>
<p>update()方法会返回一个整型数值，表示受影响的记录条数。 在上面的例子中，这个值是2。</p>



<h2  >删除对象</h2>
<p>删除数据库中的对象只需调用该对象的delete()方法即可：</p>
<pre class="code">
&gt;&gt;&gt; p = Publisher.objects.get(name=&quot;O'Reilly&quot;)
&gt;&gt;&gt; p.delete()
&gt;&gt;&gt; Publisher.objects.all()
[&lt;Publisher: Apress Publishing&gt;]
</pre>
<p>同样我们可以在结果集上调用delete()方法同时删除多条记录。这一点与我们上一小节提到的update()方法相似：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.filter(country='USA').delete()
&gt;&gt;&gt; Publisher.objects.all().delete()
&gt;&gt;&gt; Publisher.objects.all()
[]
</pre>
<p>删除数据时要谨慎！ 为了预防误删除掉某一个表内的所有数据，Django要求若要删除表内所有数据时要使用all()来明确指定。 比如，下面的操作将会出错：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.delete()
Traceback (most recent call last):
  File &quot;&lt;console&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Manager' object has no attribute 'delete'
</pre>
<p>而一旦使用all()方法，所有数据将会被删除：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.all().delete()
</pre>
<p>如果只需要删除部分的数据，就不需要调用all()方法。再看一下之前的例子：</p>
<pre class="code">
&gt;&gt;&gt; Publisher.objects.filter(country='USA').delete()
</pre>


<h2  >下一章</h2>
<p>通过本章的学习，你应该可以熟练地使用Django模型来编写一些简单的数据库应用程序。 在第十章我们将讨论Django数据库层的高级应用。</p>
<p>一旦你定义了你的模型，接下来就是要把数据导入数据库里了。 你可能已经有现成的数据了，请看第十六章，如何集成现有的数据库。
也可能数据是用户提供的，第七章中还会教你怎么处理用户提交的数据。</p>
<p>有时候，你和你的团队成员也需要手工输入数据，这时候如果能有一个基于Web的数据输入和管理的界面 就很有帮助。 下一章将介绍解决手工录入问题的方法——Django管理界面。</p>
<p>the GNU Free Document License Hosting graciously provided by</p>



    
    
  



        
	<a href="chapter04.html">| 上一章</a> |
    	<a href="index.html">目  录</a> |
    	<a href="chapter06.html">下一章 </a> |










<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->