<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->




      
        
        
        
        	<a href="chapter13.html">| 上一章</a> |
        	<a href="index.html">目  录</a> |
        	<a href="chapter15.html">下一章 </a> |
        
     


  
    
    
    
<h1  >第十四章： 会话、用户和注册</h1>
<p>是时候承认了： 我们有意的避开了web开发中极其重要的方面。 到目前为止，我们都在假定，网站流量是大量的匿名用户带来的。</p>
<p>这当然不对，浏览器的背后都是活生生的人(至少某些时候是)。 我们忽略了一件重要的事情： 互联网服务于人而不是机器。 要开发一个真正令人心动的网站，我们必须面对浏览器后面活生生的人。 要开发一个真正令人心动的网站，我们必须面对浏览器后面活生生的人。</p>
<p>很不幸，这并不容易。 HTTP被设计为&#8221;无状态&#8221;，每次请求都处于相同的空间中。 在一次请求和下一次请求之间没有任何状态保持，我们无法根据请求的任何方面(IP地址，用户代理等)来识别来自同一人的连续请求。</p>
<p>在本章中你将学会如何搞定状态的问题。 好了，我们会从较低的层次(<em>cookies</em>)开始，然后过渡到用高层的工具来搞定会话，用户和注册的问题。</p>

<h2  >Cookies</h2>
<p>浏览器的开发者在很早的时候就已经意识到， HTTP&#8217;s 的无状态会对Web开发者带来很大的问题，于是(<em>cookies</em>)应运而生。 cookies 是浏览器为 Web 服务器存储的一小段信息。 每次浏览器从某个服务器请求页面时，它向服务器回送之前收到的cookies</p>
<p>来看看它是怎么工作的。 当你打开浏览器并访问 <tt >google.com</tt> ，你的浏览器会给Google发送一个HTTP请求，起始部分就象这样：</p>
<pre class="code">
GET / HTTP/1.1
Host: google.com
...
</pre>
<p>当 Google响应时，HTTP的响应是这样的：</p>
<pre class="code">
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: PREF=ID=5b14f22bdaf1e81c:TM=1167000671:LM=1167000671;
            expires=Sun, 17-Jan-2038 19:14:07 GMT;
            path=/; domain=.google.com
Server: GWS/2.1
...
</pre>
<p>注意 <tt >Set-Cookie</tt> 的头部。 你的浏览器会存储cookie值( <tt >PREF=ID=5b14f22bdaf1e81c:TM=1167000671:LM=1167000671</tt> ) ，而且每次访问google 站点都会回送这个cookie值。 因此当你下次访问Google时，你的浏览器会发送像这样的请求：</p>
<pre class="code">
GET / HTTP/1.1
Host: google.com
Cookie: PREF=ID=5b14f22bdaf1e81c:TM=1167000671:LM=1167000671
...
</pre>
<p>于是 <tt >Cookies</tt> 的值会告诉Google，你就是早些时候访问过Google网站的人。 这个值可能是数据库中存储用户信息的key，可以用它在页面上显示你的用户名。 Google会（以及目前）使用它在网页上显示你账号的用户名。</p>

<h3  >存取Cookies</h3>
<p>在Django中处理持久化，大部分时候你会更愿意用高层些的session 和/或 后面要讨论的user 框架。 但在此之前，我们需要停下来在底层看看如何读写cookies。 这会帮助你理解本章节后面要讨论的工具是如何工作的，而且如果你需要自己操作cookies，这也会有所帮助。</p>
<p>读取已经设置好的cookies极其简单，每个request对象都有一个 <tt >COOKIES</tt> 对象，可以象使用字典般使用它，你可以读取任何浏览器发给视图(view)的任何cookies: 每一个`` HttpRequest`` 对象都有一个`` COOKIES`` 对象，该对象的行为类似一个字典，你可以使用它读取任何浏览器发送给视图（view）的cookies。</p>
<pre class="code">
def show_color(request):
    if &quot;favorite_color&quot; in request.COOKIES:
        return HttpResponse(&quot;Your favorite color is %s&quot; %             request.COOKIES[&quot;favorite_color&quot;])
    else:
        return HttpResponse(&quot;You don't have a favorite color.&quot;)
</pre>
<p>写cookies稍微复杂点，需要用 <tt >HttpResponse</tt> 对象的 <tt >set_cookie()</tt> 方法来写。 这儿有个基于 <tt >GET</tt> 参数来设置 <tt >favorite_color</tt> cookie的例子： 这里有一个设置了基于`` GET`` 参数的`` favorite_color`` cookie的例子：</p>
<pre class="code">
def set_color(request):
    if &quot;favorite_color&quot; in request.GET:

        # Create an HttpResponse object...
        response = HttpResponse(&quot;Your favorite color is now %s&quot; %             request.GET[&quot;favorite_color&quot;])

        # ... and set a cookie on the response
        response.set_cookie(&quot;favorite_color&quot;,
                            request.GET[&quot;favorite_color&quot;])

        return response

    else:
        return HttpResponse(&quot;You didn't give a favorite color.&quot;)
</pre>
<p>你可以给 <tt >response.set_cookie()</tt> 传递一些可选的参数来控制cookie的行为，详见表12-1。</p>

<p>System Message: ERROR/3 (<tt >&lt;string&gt;</tt>, line 144)</p>
<p>Error parsing content block for the &#8220;table&#8221; directive: exactly one table expected.</p>
<pre class="code">
.. table:: 表 14-1: Cookie 选项

   +---------------------------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   |参数                             |缺省值                     |Description                                                                                                                                                                         |
   +=================================+===========================+====================================================================================================================================================================================+
   |``max_age``                      |``None``                   |cookie需要延续的时间（以秒为单位） 如果参数是\ `` None`` ，这个cookie会延续到浏览器关闭为止。                                                                                       |
   +---------------------------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``expires``                      |``None``                   |cookie失效的实际日期/时间。 它的格式必须是：\ `` &quot;Wdy, DD-Mth-YY HH:MM:SS GMT&quot;`` 。如果给出了这个参数，它会覆盖\ `` max_age`` 参数。                                                |
   +---------------------------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``path``                         |``&quot;/&quot;``                    |cookie生效的路径前缀， 浏览器只会把cookie回传给带有该路径的页 面，这样你可以避免将cookie传给站点中的其他的应用。                                                                    |
   |                                 |                           |                                                                                                                                                                                    |
   |                                 |                           |当你不是控制你的站点的顶层时，这样做是特别有用的。                                                                                                                                  |
   +---------------------------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``domain``                       |``None``                   |这个cookie有效的站点。 你可以使用这个参数设置一个跨站点（cross-domain）的cookie。 比如，\ `` domain=&quot;.example.com&quot;`` 可以设置一个在\ `` www.example.com`` 、\ `` www2.example.com`` 以及\ `` an.other.sub.domain.example.com`` 站点下都可读到的cookie。|
   |                                 |                           |                                                                                                                                                                                    |
   |                                 |                           |如果这个参数被设成\ `` None`` ，cookie将只能在设置它的站点下可以读到。                                                                                                              |
   +---------------------------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``False``                        |``False``                  |如果设置为 ``True`` ，浏览器将通过HTTPS来回传cookie。                                                                                                                               |
   +---------------------------------+---------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

</pre>



<h3  >好坏参半的Cookies</h3>
<p>也许你已经注意到了，cookies的工作方式可能导致的问题，一起来看看其中一些重要的方面： 让我们看一下其中一些比较重要的问题：</p>
<blockquote>
<p>cookie的存储是自愿的，一个客户端不一定要去接受或存储cookie。 事实上，所有的浏览器都让用户自己控制 是否接受cookies。 如果你想知道cookies对于web应用有多重要，你可以试着打开这个浏览器的 选项：</p>
<p>尽管cookies广为使用，但仍被认为是不可靠的的。 这意味着，开发者使用cookies之前必须 检查用户是否可以接收cookie。</p>
<p>Cookie(特别是那些没通过HTTPS传输的)是非常不安全的。 因为HTTP数据是以明文发送的，所以 特别容易受到嗅探攻击。 也就是说，嗅探攻击者可以在网络中拦截并读取cookies，因此你要 绝对避免在cookies中存储敏感信息。 这就意味着您不应该使用cookie来在存储任何敏感信息。</p>
<p>还有一种被称为&#8221;中间人&#8221;的攻击更阴险，攻击者拦截一个cookie并将其用于另一个用户。
第19章将深入讨论这种攻击的本质以及如何避免。</p>
<p>即使从预想中的接收者返回的cookie也是不安全的，因为大多数浏览器都提供了很方便的方法来 修改cookies的内容，有技术背景的用户甚至可以用像mechanize ( <a  href="http://wwwsearch.sourceforge.net/mechanize/">http://wwwsearch.sourceforge.net/mechanize/</a> ) 这样的工具来手工构造HTTP请求。 在大多数浏览器中您可以非常容易地修改cookies中的信息。有经验的用户甚至可以通过像mechanize(<a  href="http://wwwsearch.sourceforge.net/mechanize/">http://wwwsearch.sourceforge.net/mechanize/</a>)
这样的工具手工构造一个HTTP请求。</p>
<p>因此不能在cookies中存储可能会被篡改的敏感数据，“经典”错误是： 在cookies中存储 <tt >IsLoggedIn=1</tt> ，以标识用户已经登录。 犯这类错误的站点数量多的令人难以置信； 绕过这些网站的安全系统也是易如反掌。</p>
</blockquote>



<h2  >Django的 Session 框架</h2>
<p>由于存在的限制与安全漏洞，cookies和持续性会话已经成为Web开发中令人头疼的典范。 好消息是，Django的目标正是高效的“头疼杀手”，它自带的session框架会帮你搞定这些问题。</p>
<p>你可以用session 框架来存取每个访问者任意数据，这些数据在服务器端存储，并用通过cookie来传输数据摘要。 cookies只存储数据的哈希会话ID，而不是数据本身，从而避免了大部分的常见cookie问题。 Cookies use only a hashed session ID not the data itself thus
protecting you from most of the common cookie problems.</p>
<p>下面我们来看看如何打开session功能，并在视图中使用它。</p>

<h3  >打开 Sessions功能</h3>
<p>Sessions 功能是通过一个中间件(middleware)和一个模型(model)来实现的。 要打开sessions功能，需要以下几步操作：</p>
<ol >
<li  ><p>编辑 <tt >MIDDLEWARE_CLASSES</tt> 配置，确保 <tt >MIDDLEWARE_CLASSES</tt> 中包含 <tt >'django.contrib.sessions.middleware.SessionMiddleware'</tt></p>
</li>
</ol>
<ol  start="2">
<li  ><p>确认 <tt >INSTALLED_APPS</tt> 中有 <tt >'django.contrib.sessions'</tt> (如果你是刚打开这个应用，别忘了运行 <tt >manage.py syncdb</tt> )</p>
</li>
</ol>
<p>如果项目是用 <tt >startproject</tt> 来创建的，配置文件中都已经安装了这些东西，除非你自己删除，正常情况下，你无需任何设置就可以使用session功能。</p>
<p>如果不需要session功能，你可以删除 <tt >MIDDLEWARE_CLASSES</tt> 设置中的 <tt >SessionMiddleware</tt> 和 <tt >INSTALLED_APPS</tt> 设置中的 <tt >'django.contrib.sessions'</tt> 。虽然这只会节省很少的开销，但积少成多啊。</p>


<h3  >在视图中使用Session</h3>
<p><tt >SessionMiddleware</tt> 激活后，每个传给视图(view)函数的第一个参数``HttpRequest`` 对象都有一个 <tt >session</tt> 属性，这是一个字典型的对象。 你可以象用普通字典一样来用它。 例如，在视图(view)中你可以这样用：</p>
<pre class="code">
# Set a session value:
request.session[&quot;fav_color&quot;] = &quot;blue&quot;

# Get a session value -- this could be called in a different view,
# or many requests later (or both):
fav_color = request.session[&quot;fav_color&quot;]

# Clear an item from the session:
del request.session[&quot;fav_color&quot;]

# Check if the session has a given key:
if &quot;fav_color&quot; in request.session:
    ...
</pre>
<p>其他的映射方法，如 <tt >keys()</tt> 和 <tt >items()</tt> 对 <tt >request.session</tt> 同样有效：</p>
<p>下面是一些有效使用Django sessions的简单规则：</p>
<blockquote>
<p>用正常的字符串作为key来访问字典 <tt >request.session</tt> ， 而不是整数、对象或其它什么的。</p>
<p>Session字典中以下划线开头的key值是Django内部保留key值。 框架只会用很少的几个下划线 开头的session变量，除非你知道他们的具体含义，而且愿意跟上Django的变化，否则，最好 不要用这些下划线开头的变量，它们会让Django搅乱你的应用。</p>
<p>比如，不要象这样使用`` _fav_color`` 会话密钥(session key)：</p>
</blockquote>
<pre class="code">
request.session['_fav_color'] = 'blue' # Don't do this!
</pre>
<blockquote>
<p>不要用一个新对象来替换掉 <tt >request.session</tt> ，也不要存取其属性，象用普通Python字典一样用它。 可以像Python中的字典那样使用。 例如：</p>
</blockquote>
<pre class="code">
request.session = some_other_object # Don't do this!

request.session.foo = 'bar' # Don't do this!
</pre>
<p>我们来看个简单的例子。 这是个简单到不能再简单的例子： 在用户发了一次评论后将 <tt >has_commented</tt> 设置为 <tt >True</tt> ，这是个简单（但不很安全）的、防止用户多次评论的方法。</p>
<pre class="code">
def post_comment(request):
    if request.method != 'POST':
        raise Http404('Only POSTs are allowed')

    if 'comment' not in request.POST:
        raise Http404('Comment not submitted')

    if request.session.get('has_commented', False):
        return HttpResponse(&quot;You've already commented.&quot;)

    c = comments.Comment(comment=request.POST['comment'])
    c.save()
    request.session['has_commented'] = True
    return HttpResponse('Thanks for your comment!')
</pre>
<p>下面是一个很简单的站点登录视图(view)：</p>
<pre class="code">
def login(request):
    if request.method != 'POST':
        raise Http404('Only POSTs are allowed')
    try:
        m = Member.objects.get(username=request.POST['username'])
        if m.password == request.POST['password']:
            request.session['member_id'] = m.id
            return HttpResponseRedirect('/you-are-logged-in/')
    except Member.DoesNotExist:
        return HttpResponse(&quot;Your username and password didn't match.&quot;)
</pre>
<p>下面的例子将登出一个在上面已通过`` login()`` 登录的用户：</p>
<pre class="code">
def logout(request):
    try:
        del request.session['member_id']
    except KeyError:
        pass
    return HttpResponse(&quot;You're logged out.&quot;)
</pre>
<p>注意</p>
<p>在实践中，这是很烂的用户登录方式，稍后讨论的认证(authentication )框架会帮你以更健壮和有利的方式来处理这些问题。 这些非常简单的例子只是想让你知道这一切是如何工作的。
These examples are deliberately simplistic so that you can easily see what&#8217;s going
on.</p>


<h3  >设置测试Cookies</h3>
<p>就像前面提到的，你不能指望所有的浏览器都可以接受cookie，因此，Django为了方便，也提供了检查用户浏览器是否接受cookie的简单方法。 你只需在视图(view)中调用 <tt >request.session.set_test_cookie()</tt> ，并在后续的视图(view)、而不是当前的视图(view)中检查 <tt >request.session.test_cookie_worked()</tt> 。 Just call <tt >request.session.set_test_cookie()</tt> in a view, and check
<tt >request.session.test_cookie_worked()</tt> in a subsequent view not in the same view
call.</p>
<p>虽然把 <tt >set_test_cookie()</tt> 和 <tt >test_cookie_worked()</tt> 分开的做法看起来有些笨拙，但由于cookie的工作方式，这无可避免。 当设置一个cookie时候，只能等浏览器下次访问的时候，你才能知道浏览器是否接受cookie。</p>
<p>检查cookie是否可以正常工作后，你得自己用 <tt >delete_test_cookie()</tt> 来清除它，这是个好习惯。 在你证实了测试cookie已工作了之后这样操作。</p>
<p>这是个典型例子：</p>
<pre class="code">
def login(request):

    # If we submitted the form...
    if request.method == 'POST':

        # Check that the test cookie worked (we set it below):
        if request.session.test_cookie_worked():

            # The test cookie worked, so delete it.
            request.session.delete_test_cookie()

            # In practice, we'd need some logic to check username/password
            # here, but since this is an example...
            return HttpResponse(&quot;You're logged in.&quot;)

        # The test cookie failed, so display an error message. If this
        # were a real site, we'd want to display a friendlier message.
        else:
            return HttpResponse(&quot;Please enable cookies and try again.&quot;)

    # If we didn't post, send the test cookie along with the login form.
    request.session.set_test_cookie()
    return render_to_response('foo/login_form.html')
</pre>
<p>Note</p>
<p>再次强调，内置的认证函数会帮你做检查的。</p>


<h3  >在视图(View)外使用Session</h3>
<p>从内部来看，每个session都只是一个普通的Django model（在 <tt >django.contrib.sessions.models</tt> 中定义)。 每个session都由一个随机的32字节哈希串来标识，并存储于数据库中。</p>
<pre class="code">
&gt;&gt;&gt; from django.contrib.sessions.models import Session
&gt;&gt;&gt; s = Session.objects.get(pk='2b1189a188b44ad18c35e113ac6ceead')
&gt;&gt;&gt; s.expire_date
datetime.datetime(2005, 8, 20, 13, 35, 12)
</pre>
<p>你得用 <tt >get_decoded()</tt> 来读取实际的session数据，因为session字典经过了编码存储。 This is
necessary because the dictionary is stored in an encoded format:</p>
<pre class="code">
&gt;&gt;&gt; s.session_data
'KGRwMQpTJ19hdXRoX3VzZXJfaWQnCnAyCkkxCnMuMTExY2ZjODI2Yj...'
&gt;&gt;&gt; s.get_decoded()
{'user_id': 42}
</pre>


<h3  >何时保存Session</h3>
<p>缺省的情况下，Django只会在session发生变化的时候才会存入数据库，比如说，字典赋值或删除。</p>
<pre class="code">
# Session is modified.
request.session['foo'] = 'bar'

# Session is modified.
del request.session['foo']

# Session is modified.
request.session['foo'] = {}

# Gotcha: Session is NOT modified, because this alters
# request.session['foo'] instead of request.session.
request.session['foo']['bar'] = 'baz'
</pre>
<p>你可以设置 <tt >SESSION_SAVE_EVERY_REQUEST</tt> 为 <tt >True</tt> 来改变这一缺省行为。</p>
<p>注意，会话cookie只会在创建和修改的时候才会送出。 但如果 <tt >SESSION_SAVE_EVERY_REQUEST</tt> 设置为 <tt >True</tt> ，会话cookie会在每次请求的时候都会送出。 同时，每次会话cookie送出的时候，其 <tt >expires</tt> 参数都会更新。</p>


<h3  >浏览器关闭即失效会话 vs. 持久会话 Persistent Sessions</h3>
<p>你可能注意到了，Google给我们发送的cookie中有 <tt >expires=Sun, 17-Jan-2038 19:14:07 GMT;</tt> cookie可以有过期时间，这样浏览器就知道什么时候可以删除cookie了。 如果cookie没有设置过期时间，当用户关闭浏览器的时候，cookie就自动过期了。 你可以改变 <tt >SESSION_EXPIRE_AT_BROWSER_CLOSE</tt> 的设置来控制session框架的这一行为。</p>
<p>缺省情况下， <tt >SESSION_EXPIRE_AT_BROWSER_CLOSE</tt> 设置为 <tt >False</tt> ，这样，会话cookie可以在用户浏览器中保持有效达 <tt >SESSION_COOKIE_AGE</tt> 秒（缺省设置是两周，即1,209,600 秒）。 如果你不想用户每次打开浏览器都必须重新登陆的话，用这个参数来帮你。</p>
<p>如果 <tt >SESSION_EXPIRE_AT_BROWSER_CLOSE</tt> 设置为 <tt >True</tt> ，当浏览器关闭时，Django会使cookie失效。</p>


<h3  >其他的Session设置</h3>
<p>除了上面提到的设置，还有一些其他的设置可以影响Django session框架如何使用cookie，详见表 14-2.</p>
<table  >
<caption>表 14-2.  影响cookie行为的设置</caption>
<colgroup>
<col width="31%" />
<col width="50%" />
<col width="19%" />
</colgroup>
<thead valign="bottom">
<tr><th >设置</th>
<th >Description</th>
<th >Default</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt >SESSION_COOKIE_DOMAIN</tt></td>
<td>使用会话cookie（session cookies）的站点。
将它设成一个字符串，就好象`` &#8220;.example.com&#8221;`` 以用于跨站点（cross-domain）的cookie，或`` None`` 以用于单个站点。</td>
<td><tt >None</tt></td>
</tr>
<tr><td><tt >SESSION_COOKIE_NAME</tt></td>
<td>会话中使用的cookie的名字。 它可以是任意的字符串。</td>
<td><tt >&quot;sessionid&quot;</tt></td>
</tr>
<tr><td><tt >SESSION_COOKIE_SECURE</tt></td>
<td>是否在session中使用安全cookie， 如果设置 <tt >True</tt> , cookie就会标记为安全， 这意味着cookie只会通过HTTPS来传输</td>
<td><tt >False</tt></td>
</tr>
</tbody>
</table>
<p>技术细节</p>
<p>如果你还是好奇的话，下面是一些关于session框架内部工作方式的技术细节：</p>
<blockquote>
<p>session 字典和普通Python对象一样，支持序列化，详见Python文档中内置 <tt >pickle</tt> 模块的部分。 See
the documentation for Python&#8217;s built-in <tt >pickle</tt> module for information about
how this works.</p>
<p>Session 数据存在数据库表 <tt >django_session</tt> 中</p>
<p>Session 数据在需要的时候才会读取，如果你从不使用 <tt >request.session</tt> ， Django不会动相关数据库表的一根毛。 If you never access <tt >request.session</tt> ,
Django won&#8217;t hit that database table.</p>
<p>Django 只在需要的时候才送出cookie。 如果你压根儿就没有设置任何会话数据，它不会 送出会话cookie(除非 <tt >SESSION_SAVE_EVERY_REQUEST</tt> 设置为 <tt >True</tt> )</p>
<p>Django session 框架完全而且只能基于cookie，不会后退到把会话ID编码在URL中。 （像某些工具(PHP,JSP)那样）</p>
<p>这是一个有意而为之的设计， 把session放在URL中不只是难看，更重要的是这让你的站点 很容易受到攻击——通过 <tt >Referer</tt> header进行session ID&#8221;窃听&#8221;而实施的攻击。</p>
</blockquote>
<p>如果你还是好奇，阅读源代码是最直接办法，详见 <tt >django.contrib.sessions</tt> 。</p>



<h2  >用户与Authentication</h2>
<p>通过session，我们可以在多次浏览器请求中保持数据， 接下来的部分就是用session来处理用户登录了。 当然，不能仅凭用户的一面之词，我们就相信，所以我们需要认证。</p>
<p>当然了，Django 也提供了工具来处理这样的常见任务（就像其他常见任务一样）。
Django 用户认证系统处理用户帐号，组，权限以及基于cookie的用户会话。 这个系统一般被称为 <em>auth/auth</em> (认证与授权)系统， 这个系统的名称同时也表明了用户常见的两步处理。 我们需要</p>
<ol >
<li  ><p>验证 (<em>认证</em>) 用户是否是他所宣称的用户(一般通过查询数据库验证其用户名和密码)</p>
</li>
</ol>
<ol  start="2">
<li  ><p>验证用户是否拥有执行某种操作的 <em>授权</em> (通常会通过检查一个权限表来确认)</p>
</li>
</ol>
<p>根据这些需求，Django 认证/授权 系统会包含以下的部分：</p>
<ul >
<li  ><p><em>用户</em> : 在网站注册的人</p>
</li>
</ul>
<ul >
<li  ><p><em>权限</em> : 用于标识用户是否拥有某种操作的二进制(yes/no)标志</p>
</li>
</ul>
<ul >
<li  ><p><em>组</em> :一种可以将标记和权限应用于多个用户的常用方法</p>
</li>
</ul>
<ul >
<li  ><p><em>Messages</em> : 向用户显示队列式的系统消息的常用方法</p>
</li>
</ul>
<p>如果你已经用了admin工具(详见第6章)，就会看见这些工具的大部分。</p>

<h3  >打开认证支持</h3>
<p>像session工具一样，认证支持也是一个Django应用，放在 <tt >django.contrib</tt> 中，所以也需要安装。 与session系统相似，它也是缺省安装的，但如果它已经被删除了，通过以下步骤也能重新安装上：</p>
<ol >
<li  ><p>根据本章早前的部分确认已经安装了session 框架，需要确认用户使用cookie，这样sesson 框架才能正常使用。 Keeping track of users obviously requires cookies, and thus builds on
the session framework.</p>
</li>
</ol>
<ol  start="2">
<li  ><p>将 <tt >'django.contrib.auth'</tt> 放在你的 <tt >INSTALLED_APPS</tt> 设置中，然后运行 <tt >manage.py syncdb</tt></p>
</li>
</ol>
<ol  start="3">
<li  ><p>确认 <tt >SessionMiddleware</tt> 后面的 <tt >MIDDLEWARE_CLASSES</tt> 设置中包含 <tt >'django.contrib.auth.middleware.AuthenticationMiddleware'</tt> <tt >SessionMiddleware</tt> .</p>
</li>
</ol>
<p>这样安装后，我们就可以在视图(view)的函数中用处理user了。 在视图中存取users，主要用 <tt >request.user</tt> ；这个对象表示当前已登录的用户，如果用户还没登录，这就是一个 <tt >匿名</tt> 对象(细节见下)
If the user isn&#8217;t logged in, this will instead be an <tt >AnonymousUser</tt> object (see
below for more details).</p>
<p>你可以很容易的通过 <tt >is_authenticated()</tt> 方法来判断一个用户是否已经登录了</p>
<pre class="code">
if request.user.is_authenticated():
    # Do something for authenticated users.
else:
    # Do something for anonymous users.
</pre>


<h3  >使用User对象</h3>
<p><tt >User</tt> 实例一般从 <tt >request.user</tt> ，或是其他下面即将要讨论到的方法取得，它有很多属性和方法。 <tt >AnonymousUser</tt> 对象模拟了 <em>部分</em> 的接口，但不是全部，在把它当成真正的user对象 使用前，你得检查一下 <tt >user.is_authenticated()</tt> 表14-3和14-4分别列出了`` User`` 对象中的属性（fields)和方法。</p>
<table  >
<caption>表 14-3.  <tt >User</tt> 对象属性</caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr><th >属性</th>
<th >Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt >username</tt></td>
<td>必需的，不能多于30个字符。 仅用字母数字式字符（字母、数字和下划线）。</td>
</tr>
<tr><td><tt >first_name</tt></td>
<td>可选; 少于等于30字符.</td>
</tr>
<tr><td><tt >last_name</tt></td>
<td>可选; 少于等于30字符.</td>
</tr>
<tr><td><tt >email</tt></td>
<td>可选.  邮件地址.</td>
</tr>
<tr><td><tt >password</tt></td>
<td>必需的。 A hash of, and metadata about, the password (Django
doesn&#8217;t store the raw password). See the Passwords section for
more about this value.</td>
</tr>
<tr><td><tt >is_staff</tt></td>
<td>布尔值.  用户是否拥有网站的管理权限.</td>
</tr>
<tr><td><tt >is_active</tt></td>
<td>布尔值. 用户是否拥有所有权限，而无需任何显式的权限分配定义
用户最后登录的时间，缺省会设置为当前时间</td>
</tr>
<tr><td><tt >is_superuser</tt></td>
<td>Boolean. Designates that this user has all permissions without
explicitly assigning them.</td>
</tr>
<tr><td><tt >last_login</tt></td>
<td>用户上次登录的时间日期。 它被默认设置为当前的日期/时间。</td>
</tr>
<tr><td><tt >date_joined</tt></td>
<td>账号被创建的日期时间 当账号被创建时，它被默认设置为当前的日期/时间。</td>
</tr>
</tbody>
</table>

<p>System Message: ERROR/3 (<tt >&lt;string&gt;</tt>, line 743)</p>
<p>Error parsing content block for the &#8220;table&#8221; directive: exactly one table expected.</p>
<pre class="code">
.. table:: 表 14-4. ``User`` 对象方法

   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |方法                                                                                         |Description                                                                                                                                           |
   +=============================================================================================+======================================================================================================================================================+
   |``is_authenticated()``                                                                       |对于真实的User对象，总是返回\ `` True`` 。                                                                                                            |
   |                                                                                             |这是一个分辨用户是否已被鉴证的方法。 它并不意味着任何权限，也不检查用户是否仍是活动的。 它仅说明此用户已被成功鉴证。                                  |
   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``is_anonymous()``                                                                           |对于\ `` AnonymousUser`` 对象返回\ `` True`` （对于真实的\ `` User`` 对象返回\ `` False`` ）。                                                        |
   |                                                                                             |总的来说，比较于这个方法，你应该倾向于使用\ `` is_authenticated()`` 方法。                                                                            |
   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``get_full_name()``                                                                          |返回\ `` first_name`` 加上\ `` last_name`` ，中间插入一个空格。                                                                                       |
   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``set_password(passwd)``                                                                     |Sets the user's password to the given raw string,                                                                                                     |
   |                                                                                             |taking care of the password hashing. ``has_perm(perm)``                                                                                               |
   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``check_password(passwd)``                                                                   |如果用户拥有给定的权限，返回 ``True`` ， ``perm`` 应形如 ``&quot;package.codename&quot;`` 的格式。 比较时会使用密码哈希表。                                     |
   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``get_group_permissions()``                                                                  |返回一个用户通过其所属组获得的权限字符串列表。                                                                                                        |
   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``get_all_permissions()``                                                                    |返回一个用户通过其所属组以及自身权限所获得的权限字符串列表。                                                                                          |
   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``has_perm(perm)``                                                                           |如果用户有指定的权限，则返回\ `` True`` ，此时\ `` perm`` 的格式是\ `` &quot;package.codename&quot;`` 。如果用户已不活动，此方法总是返回\ `` False`` 。         |
   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``has_perms(perm_list)``                                                                     |如果用户拥有\ * 全部* 的指定权限，则返回\ `` True`` 。 如果用户是不活动的，这个方法总是返回\ `` False`` 。                                            |
   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``has_module_perms(app_label)``                                                              |如果用户拥有给定的\ `` app_label`` 中的任何权限，则返回\ `` True`` 。如果用户已不活动，这个方法总是返回\ `` False`` 。                                |
   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``get_and_delete_messages()``                                                                |返回一个用户队列中的\ `` Message`` 对象列表，并从队列中将这些消息删除。                                                                               |
   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |``email_user(subj, msg)``                                                                    |向用户发送一封电子邮件。 这封电子邮件是从\ `` DEFAULT_FROM_EMAIL`` 设置的地址发送的。 你还可以传送一个第三参数：\ `` from_email`` ，以覆盖电邮中的发送地址。|
   +---------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------+

</pre>

<p>最后，`` User`` 对象有两个many-to-many属性。 `` groups`` 和`` permissions`` 。正如其他的many-to-many属性使用的方法一样，`` User`` 对象可以获得他们相关的对象：</p>
<pre class="code">
# Set a user's groups:
myuser.groups = group_list

# Add a user to some groups:
myuser.groups.add(group1, group2,...)

# Remove a user from some groups:
myuser.groups.remove(group1, group2,...)

# Remove a user from all groups:
myuser.groups.clear()

# Permissions work the same way
myuser.permissions = permission_list
myuser.permissions.add(permission1, permission2, ...)
myuser.permissions.remove(permission1, permission2, ...)
myuser.permissions.clear()
</pre>


<h3  >登录和退出</h3>
<p>Django 提供内置的视图(view)函数用于处理登录和退出 (以及其他奇技淫巧)，但在开始前，我们来看看如何手工登录和退出，Django 在 <tt >django.contrib.auth</tt> 中提供了两个函数来处理这些事情—— <tt >authenticate()</tt> 和 <tt >login()</tt> 。 Django provides two functions to perform these actions in
<tt >django.contrib.auth</tt> : <tt >authenticate()</tt> and <tt >login()</tt> .</p>
<p>认证给出的用户名和密码，使用 <tt >authenticate()</tt> 函数。 它接受两个参数，用户名 <tt >username</tt> 和 密码 <tt >password</tt> ，并在密码对用给出的用户名是合法的情况下返回一个 <tt >User</tt> 对象。</p>
<pre class="code">
&gt;&gt;&gt; from django.contrib import auth
&gt;&gt;&gt; user = auth.authenticate(username='john', password='secret')
&gt;&gt;&gt; if user is not None:
...     print &quot;Correct!&quot;
... else:
...     print &quot;Invalid password.&quot;
</pre>
<p><tt >authenticate()</tt> 只是验证一个用户的证书而已。 而要登录一个用户，使用 <tt >login()</tt> 。该函数接受一个 <tt >HttpRequest</tt> 对象和一个 <tt >User</tt> 对象作为参数并使用Django的会话（ <tt >session</tt> ）框架把用户的ID保存在该会话中。</p>
<p>下面的例子演示了如何在一个视图中同时使用 <tt >authenticate()</tt> 和 <tt >login()</tt> 函数：</p>
<pre class="code">
from django.contrib import auth

def login_view(request):
    username = request.POST.get('username', '')
    password = request.POST.get('password', '')
    user = auth.authenticate(username=username, password=password)
    if user is not None and user.is_active:
        # Correct password, and the user is marked &quot;active&quot;
        auth.login(request, user)
        # Redirect to a success page.
        return HttpResponseRedirect(&quot;/account/loggedin/&quot;)
    else:
        # Show an error page
        return HttpResponseRedirect(&quot;/account/invalid/&quot;)
</pre>
<p>注销一个用户，在你的视图中使用 <tt >django.contrib.auth.logout()</tt> 。该函数接受一个 <tt >HttpRequest</tt> 对象作为参数，没有返回值。 It takes
an <tt >HttpRequest</tt> object and has no return value:</p>
<pre class="code">
from django.contrib import auth

def logout_view(request):
    auth.logout(request)
    # Redirect to a success page.
    return HttpResponseRedirect(&quot;/account/loggedout/&quot;)
</pre>
<p>注意，即使用户没有登录， <tt >logout()</tt> 也不会抛出任何异常。</p>
<p>在实际中，你一般不需要自己写登录/登出的函数；认证系统提供了一系例视图用来处理登录和登出。 使用认证视图的第一步是把它们写在你的URLconf中。 你需要这样写：</p>
<pre class="code">
from django.contrib.auth.views import login, logout

urlpatterns = patterns('',
    # existing patterns here...
    (r'^accounts/login/$',  login),
    (r'^accounts/logout/$', logout),
)
</pre>
<p><tt >/accounts/login/</tt> 和 <tt >/accounts/logout/</tt> 是Django提供的视图的默认URL。</p>
<p>缺省情况下， <tt >login</tt> 视图渲染 <tt >registragiton/login.html</tt> 模板(可以通过视图的额外参数 <tt >template_name</tt> 修改这个模板名称)。 这个表单必须包含 <tt >username</tt> 和 <tt >password</tt> 域。如下示例： 一个简单的 template 看起来是这样的</p>
<pre class="code">
{% extends &quot;base.html&quot; %}

{% block content %}

  {% if form.errors %}
    &lt;p class=&quot;error&quot;&gt;Sorry, that's not a valid username or password&lt;/p&gt;
  {% endif %}

  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;
    &lt;label for=&quot;username&quot;&gt;User name:&lt;/label&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; id=&quot;username&quot;&gt;
    &lt;label for=&quot;password&quot;&gt;Password:&lt;/label&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot; id=&quot;password&quot;&gt;

    &lt;input type=&quot;submit&quot; value=&quot;login&quot; /&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;{{ next|escape }}&quot; /&gt;
  &lt;/form&gt;

{% endblock %}
</pre>
<p>如果用户登录成功，缺省会重定向到 <tt >/accounts/profile</tt> 。表单中有一个hidden字段叫 <tt >next</tt> ，可以用在登录后指定url。 也可以把这个值（指定的url）作为 <tt >GET</tt> 参数传递给login视图，这个参数会成为Context中名为 <tt >next</tt> 的变量，你可以把这个变量设置给表单中对应的隐含字段。 You can also pass this
value as a <tt >GET</tt> parameter to the login view and it will be automatically added to
the context as a variable called <tt >next</tt> that you can insert into that hidden
field.</p>
<p>logout视图有一些不同。 缺省的它渲染 <tt >registration/logged_out.html</tt> 模板（这个视图一般包含你已经成功退出的信息）。 视图中还可以包含一个参数 <tt >next_page</tt> 用于退出后重定向。</p>


<h3  >限制已登录用户的访问</h3>
<p>有很多原因需要控制用户访问站点的某部分。</p>
<p>一个简单原始的限制方法是检查 <tt >request.user.is_authenticated()</tt> ,然后重定向到登陆页面：</p>
<pre class="code">
from django.http import HttpResponseRedirect

def my_view(request):
    if not request.user.is_authenticated():
        return HttpResponseRedirect('/accounts/login/?next=%s' % request.path)
    # ...
</pre>
<p>或者显示一个出错信息：</p>
<pre class="code">
def my_view(request):
    if not request.user.is_authenticated():
        return render_to_response('myapp/login_error.html')
    # ...
</pre>
<p>作为一个快捷方式, 你可以使用便捷的 <tt >login_required</tt> 修饰符:</p>
<pre class="code">
from django.contrib.auth.decorators import login_required

&#64;login_required
def my_view(request):
    # ...
</pre>
<p><tt >login_required</tt> 做下面的事情:</p>
<ul >
<li  ><p>如果用户没有登录, 重定向到 <tt >/accounts/login/</tt> , 把当前绝对URL作为 <tt >next</tt> 在查询字符串中传递过去, 例如: <tt >/accounts/login/?next=/polls/3/</tt> .
<tt >/accounts/login/?next=/polls/3/</tt> .</p>
</li>
</ul>
<ul >
<li  ><p>如果用户已经登录, 正常地执行视图函数. 视图代码就可以假定用户已经登录了. The view code can then
assume that the user is logged in.</p>
</li>
</ul>


<h3  >对通过测试的用户限制访问</h3>
<p>限制访问可以基于某种权限，某些检查或者为login视图提供不同的位置，这些实现方式大致相同</p>
<p>一般的方法是直接在视图的 <tt >request.user</tt> 上运行检查。 例如，下面视图检查用户登陆并是否有 <tt >polls.can_vote</tt> 的权限：</p>
<pre class="code">
def vote(request):
    if request.user.is_authenticated() and request.user.has_perm('polls.can_vote')):
        # vote here
    else:
        return HttpResponse(&quot;You can't vote in this poll.&quot;)
</pre>
<p>并且Django有一个称为 <tt >user_passes_test</tt> 的简洁方式。</p>
<pre class="code">
def user_can_vote(user):
    return user.is_authenticated() and user.has_perm(&quot;polls.can_vote&quot;)

&#64;user_passes_test(user_can_vote, login_url=&quot;/login/&quot;)
def vote(request):
    # Code here can assume a logged-in user with the correct permission.
    ...
</pre>
<p><tt >user_passes_test</tt> 使用一个必需的参数： 一个可调用的方法，当存在 <tt >User</tt> 对象并当此用户允许查看该页面时返回 <tt >True</tt> 。 注意 <tt >user_passes_test</tt> 不会自动检查 <tt >User</tt> 是否认证，你应该自己做这件事。 Note that
<tt >user_passes_test</tt> does not automatically check that the <tt >User</tt> is
authenticated; you should do that yourself.</p>
<p>例子中我们也展示了第二个可选的参数 <tt >login_url</tt> ，它让你指定你的登录页面的URL（默认为 <tt >/accounts/login/</tt> ）。 If the user doesn&#8217;t pass the test, then the <tt >user_passes_test</tt> decorator
will redirect the user to the <tt >login_url</tt> .</p>
<p>既然检查用户是否有一个特殊权限是相对常见的任务，Django为这种情形提供了一个捷径： <tt >permission_required()</tt> 装饰器 使用这个装饰器，前面的例子可以这样写: Using this decorator, the earlier example can be written as follows:</p>
<pre class="code">
from django.contrib.auth.decorators import permission_required

&#64;permission_required('polls.can_vote', login_url=&quot;/login/&quot;)
def vote(request):
    # ...
</pre>
<p>注意, <tt >permission_required()</tt> 也有一个可选的 <tt >login_url</tt> 参数, 这个参数默认为 <tt >'/accounts/login/'</tt> 。</p>
<p>限制通用视图的访问</p>
<p>在Django用户邮件列表中问到最多的问题是关于对通用视图的限制性访问。 为实现这个功能，你需要自己包装视图，并且在URLconf中，将你自己的版本替换通用视图：</p>
<pre class="code">
from django.contrib.auth.decorators import login_required
from django.views.generic.date_based import object_detail

&#64;login_required
def limited_object_detail(*args, **kwargs):
    return object_detail(*args, **kwargs)
</pre>
<p>当然, 你可以用任何其他限定修饰符来替换 <tt >login_required</tt> 。</p>


<h3  >管理 Users, Permissions 和 Groups</h3>
<p>管理认证系统最简单的方法是通过管理界面。
第六章讨论了怎样使用Django的管理界面来编辑用户和控制他们的权限和可访问性，并且大多数时间你都会只使用这个界面。</p>
<p>然而，当你需要绝对的控制权的时候，有一些低层 API 需要深入专研，我们将在下面的章节中讨论它们。</p>

<h4  >创建用户</h4>
<p>使用 <tt >create_user</tt> 辅助函数创建用户:</p>
<pre class="code">
&gt;&gt;&gt; from django.contrib.auth.models import User
&gt;&gt;&gt; user = User.objects.create_user(username='john',
...                                 email='jlennon&#64;beatles.com',
...                                 password='glass onion')
</pre>
<p>在这里， <tt >user</tt> 是 <tt >User</tt> 类的一个实例，准备用于向数据库中存储数据。 <tt >create_user()</tt> 函数并没有在数据库中创建记录，在保存数据之前，你仍然可以继续修改它的属性值。</p>
<pre class="code">
&gt;&gt;&gt; user.is_staff = True
&gt;&gt;&gt; user.save()
</pre>


<h4  >修改密码</h4>
<p>你可以使用 <tt >set_password()</tt> 来修改密码：</p>
<pre class="code">
&gt;&gt;&gt; user = User.objects.get(username='john')
&gt;&gt;&gt; user.set_password('goo goo goo joob')
&gt;&gt;&gt; user.save()
</pre>
<p>除非你清楚的知道自己在做什么，否则不要直接修改 <tt >password</tt> 属性。 其中保存的是密码的 <em>加入salt的hash值</em> ，所以不能直接编辑。</p>
<p>一般来说， <tt >User</tt> 对象的 <tt >password</tt> 属性是一个字符串，格式如下：</p>
<pre class="code">
hashtype$salt$hash
</pre>
<p>这是哈希类型，salt和哈希本身，用美元符号（$）分隔。</p>
<p><tt >hashtype</tt> 是 <tt >sha1</tt> （默认）或者 <tt >md5</tt> ，它是用来处理单向密码哈希的算法，Salt是一个用来加密原始密码来创建哈希的随机字符串，例如: <tt >salt</tt> is a random string used to salt the raw
password to create the hash, for example:</p>
<pre class="code">
sha1$a1976$a36cc8cbf81742a8fb52e221aaeab48ed7f58ab4
</pre>
<p><tt >User.set_password()</tt> 和 <tt >User.check_password()</tt> 函数在后台处理和检查这些值。</p>
<p>Salted hashes</p>
<p>一次 <em>哈希</em> 是一次单向的加密过程，你能容易地计算出一个给定值的哈希码，但是几乎不可能从一个哈希码解出它的原值。</p>
<p>如果我们以普通文本存储密码,任何能进入数据库的人都能轻易的获取每个人的密码。 使用哈希方式来存储密码相应的减少了数据库泄露密码的可能。</p>
<p>然而，攻击者仍然可以使用 <em>暴力破解</em> 使用上百万个密码与存储的值对比来获取数据库密码，这需要花一些时间，但是智能电脑惊人的速度超出了你的想象 This takes some time, but less than you might think.</p>
<p>更糟糕的是我们可以公开地得到 <em>rainbow tables</em> （一种暴力密码破解表）或预备有上百万哈希密码值的数据库。 使用rainbow tables可以在几秒之内就能搞定最复杂的一个密码。</p>
<p>在存储的hash值的基础上，加入 <em>salt</em> 值（一个随机值），增加了密码的强度，使得破解更加困难。 因为每个密码的salt值都不相同，这也限制了rainbow table的使用，使得攻击者只能使用最原始的暴力破解方法。</p>
<p>加入salt值得hash并不是绝对安全的存储密码的方法，然而在安全和方便之间有很大的中间地带需要我们来做决定。</p>


<h4  >处理注册</h4>
<p>我们可以使用这些底层工具来创建允许用户注册的视图。 最近每个开发人员都希望实现各自不同的注册方法，所以Django把写一个注册视图的工作留给了你。 幸运的是，这很容易。</p>
<p>作为这个事情的最简化处理, 我们可以提供一个小视图, 提示一些必须的用户信息并创建这些用户. Django为此提供了可用的内置表单, 在下面这个例子中很好地使用了: Django provides a built-in form you can use for
this purpose, which we&#8217;ll use in this example:</p>
<pre class="code">
from django import forms
from django.contrib.auth.forms import UserCreationForm
from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response

def register(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            new_user = form.save()
            return HttpResponseRedirect(&quot;/books/&quot;)
    else:
        form = UserCreationForm()
    return render_to_response(&quot;registration/register.html&quot;, {
        'form': form,
    })
</pre>
<p>这个表单构想了一个叫 <tt >registration/register.html</tt> 的模板. 这里是一个这个模板的可能的样子的例子:</p>
<pre class="code">
{% extends &quot;base.html&quot; %}

{% block title %}Create an account{% endblock %}

{% block content %}
  &lt;h1&gt;Create an account&lt;/h1&gt;

  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;
      {{ form.as_p }}
      &lt;input type=&quot;submit&quot; value=&quot;Create the account&quot;&gt;
  &lt;/form&gt;
{% endblock %}
</pre>



<h3  >在模板中使用认证数据</h3>
<p>当前登入的用户以及他（她）的权限可以通过 <tt >RequestContext</tt> 在模板的context中使用（详见第9章）。</p>
<p>Note</p>
<p>从技术上来说，只有当你使用了 <tt >RequestContext</tt> <em>并且</em> <tt >TEMPLATE_CONTEXT_PROCESSORS</tt> 设置包含了 <tt >&quot;django.core.context_processors.auth&quot;</tt> （默认情况就是如此）时，这些变量才能在模板context中使用。</p>
<p>当使用 <tt >RequestContext</tt> 时, 当前用户 (是一个 <tt >User</tt> 实例或一个 <tt >AnonymousUser</tt> 实例) 存储在模板变量 <tt >{{ user }}</tt> 中:</p>
<pre class="code">
{% if user.is_authenticated %}
  &lt;p&gt;Welcome, {{ user.username }}. Thanks for logging in.&lt;/p&gt;
{% else %}
  &lt;p&gt;Welcome, new user. Please log in.&lt;/p&gt;
{% endif %}
</pre>
<p>这些用户的权限信息存储在 <tt >{{ perms }}</tt> 模板变量中。</p>
<p>你有两种方式来使用 <tt >perms</tt> 对象。 你可以使用类似于 <tt >{{ perms.polls }}</tt> 的形式来检查，对于某个特定的应用，一个用户是否具有 <em>任意</em> 权限；你也可以使用 <tt >{{ perms.polls.can_vote }}</tt> 这样的形式，来检查一个用户是否拥有特定的权限。</p>
<p>这样你就可以在模板中的 <tt >{% if %}</tt> 语句中检查权限:</p>
<pre class="code">
{% if perms.polls %}
  &lt;p&gt;You have permission to do something in the polls app.&lt;/p&gt;
  {% if perms.polls.can_vote %}
    &lt;p&gt;You can vote!&lt;/p&gt;
  {% endif %}
{% else %}
  &lt;p&gt;You don't have permission to do anything in the polls app.&lt;/p&gt;
{% endif %}
</pre>



<h2  >权限、组和消息</h2>
<p>在认证框架中还有其他的一些功能。 我们会在接下来的几个部分中进一步地了解它们。</p>

<h3  >权限</h3>
<p>权限可以很方便地标识用户和用户组可以执行的操作。 它们被Django的admin管理站点所使用，你也可以在你自己的代码中使用它们。</p>
<p>Django的admin站点如下使用权限：</p>
<ul >
<li  ><p>只有设置了 <em>add</em> 权限的用户才能使用添加表单，添加对象的视图。</p>
</li>
</ul>
<ul >
<li  ><p>只有设置了 <em>change</em> 权限的用户才能使用变更列表，变更表格，变更对象的视图。</p>
</li>
</ul>
<ul >
<li  ><p>只有设置了 <em>delete</em> 权限的用户才能删除一个对象。</p>
</li>
</ul>
<p>权限是根据每一个类型的对象而设置的，并不具体到对象的特定实例。
例如，我们可以允许Mary改变新故事，但是目前还不允许设置Mary只能改变自己创建的新故事，或者根据给定的状态，出版日期或者ID号来选择权限。</p>
<p>会自动为每一个Django模型创建三个基本权限：增加、改变和删除。 Behind the scenes, these permissions are added to the
<tt >auth_permission</tt> database table when you run <tt >manage.py syncdb</tt> .</p>
<p>权限以 <tt >&quot;&lt;app&gt;.&lt;action&gt;_&lt;object_name&gt;&quot;</tt> 的形式出现。</p>
<p>就跟用户一样，权限也就是Django模型中的 <tt >django.contrib.auth.models</tt> 。因此如果你愿意，你也可以通过Django的数据库API直接操作权限。</p>


<h3  >组</h3>
<p>组提供了一种通用的方式来让你按照一定的权限规则和其他标签将用户分类。 一个用户可以隶属于任何数量的组。</p>
<p>在一个组中的用户自动获得了赋予该组的权限。 例如， <tt >Site editors</tt> 组拥有 <tt >can_edit_home_page</tt> 权限，任何在该组中的用户都拥有这个权限。</p>
<p>组也可以通过给定一些用户特殊的标记，来扩展功能。 例如，你创建了一个 <tt >'Special users'</tt> 组，并且允许组中的用户访问站点的一些VIP部分，或者发送VIP的邮件消息。</p>
<p>和用户管理一样，admin接口是管理组的最简单的方法。
然而，组也就是Django模型 <tt >django.contrib.auth.models</tt> ，因此你可以使用Django的数据库API，在底层访问这些组。</p>


<h3  >消息</h3>
<p>消息系统会为给定的用户接收消息。 每个消息都和一个 <tt >User</tt> 相关联。</p>
<p>在每个成功的操作以后，Django的admin管理接口就会使用消息机制。 例如，当你创建了一个对象，你会在admin页面的顶上看到 <tt >The object was created successfully</tt> 的消息。</p>
<p>你也可以使用相同的API在你自己的应用中排队接收和显示消息。 API非常地简单：</p>
<ul >
<li  ><p>要创建一条新的消息，使用 <tt >user.message_set.create(message='message_text')</tt> 。</p>
</li>
</ul>
<ul >
<li  ><p>要获得/删除消息，使用 <tt >user.get_and_delete_messages()</tt> ，这会返回一个 <tt >Message</tt> 对象的列表，并且从队列中删除返回的项。</p>
</li>
</ul>
<p>在例子视图中，系统在创建了播放单（playlist）以后，为用户保存了一条消息。</p>
<pre class="code">
def create_playlist(request, songs):
    # Create the playlist with the given songs.
    # ...
    request.user.message_set.create(
        message=&quot;Your playlist was added successfully.&quot;
    )
    return render_to_response(&quot;playlists/create.html&quot;,
        context_instance=RequestContext(request))
</pre>
<p>当使用 <tt >RequestContext</tt> ，当前登录的用户以及他（她）的消息，就会以模板变量 <tt >{{ messages }}</tt> 出现在模板的context中。</p>
<pre class="code">
{% if messages %}
&lt;ul&gt;
    {% for message in messages %}
    &lt;li&gt;{{ message }}&lt;/li&gt;
    {% endfor %}
&lt;/ul&gt;
{% endif %}
</pre>
<p>需要注意的是 <tt >RequestContext</tt> 会在后台调用 <tt >get_and_delete_messages</tt> ，因此即使你没有显示它们，它们也会被删除掉。</p>
<p>最后注意，这个消息框架只能服务于在用户数据库中存在的用户。 如果要向匿名用户发送消息，请直接使用会话框架。</p>



<h2  >下一章</h2>
<p>是的，会话和认证系统有太多的东西要学。 大多数情况下，你并不需要本章所提到的所有功能。</p>
<p>在<a href="chapter15.html">下一章 </a>，我们会看一下Django的缓存机制，这是一个提高你的网页应用性能的便利的办法。</p>



    
    
  



        
	<a href="chapter13.html">| 上一章</a> |
    	<a href="index.html">目  录</a> |
    	<a href="chapter15.html">下一章 </a> |










<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->