<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->




      
        
        
        
        	<a href="chapter10.html">| 上一章</a> |
        	<a href="index.html">目  录</a> |
        	<a href="chapter12.html">下一章 </a> |
        
     


  
    
    
    
<h1  >第11章 通用视图</h1>
<p>这里需要再次回到本书的主题： 在最坏的情况下， Web 开发是一项无聊而且单调的工作。 到目前为止，我们已经介绍了 Django 怎样在模型和模板的层面上减小开发的单调性，但是 Web 开发在视图的层面上，也经历着这种令人厌倦的事情。</p>
<p>Django 的 <em>generic views</em> 可以减少这些痛苦。 它抽象出一些在视图开发中常用的代码和模式，这样就可以在无需编写大量代码的情况下，快速编写出常用的数据视图。 事实上，前面章节中的几乎所有视图的示例都可以在通用视图的帮助下重写。</p>
<p>在第八章简单的向大家介绍了怎样使视图更加的“通用”。 回顾一下，我们会发现一些比较常见的任务，比如显示一系列对象，写一段代码来显示 <em>任何</em> 对象内容。 解决办法就是传递一个额外的参数到URLConf。</p>
<p>Django内建通用视图可以实现如下功能：</p>
<ul >
<li  ><p>完成常用的简单任务： 重定向到另一个页面以及渲染一个指定的模板。</p>
</li>
</ul>
<ul >
<li  ><p>显示列表和某个特定对象的详细内容页面。 第8章中提到的 <tt >event_list</tt> 和 <tt >entry_list</tt> 视图就是列表视图的一个例子。 一个单一的 event 页面就是我们所说的详细内容页面。</p>
</li>
</ul>
<ul >
<li  ><p>呈现基于日期的数据的年/月/日归档页面，关联的详情页面，最新页面。 Django Weblogs (<a  href="http://www.djangoproject.com/weblog/">http://www.djangoproject.com/weblog/</a>)的年、月、日的归档就是使用通用视图 架构的，就像是典型的新闻报纸归档。</p>
</li>
</ul>
<p>综上所述，这些视图为开发者日常开发中常见的任务提供了易用的接口。</p>

<h2  >使用通用视图</h2>
<p>使用通用视图的方法是在URLconf文件中创建配置字典，然后把这些字典作为URLconf元组的第三个成员。 (See Passing Extra Options to View Functions in
Chapter 8 for an overview of this technique.)</p>
<p>例如，下面是一个呈现静态“关于”页面的URLconf：</p>
<pre class="code">
from django.conf.urls.defaults import *
from django.views.generic.simple import direct_to_template

urlpatterns = patterns('',
    (r'^about/$', direct_to_template, {
        'template': 'about.html'
    })
)
</pre>
<p>一眼看上去似乎有点不可思议，不需要编写代码的视图！
它和第八章中的例子完全一样：</p>
<p>因为通用视图都是标准的视图函数，我们可以在我们自己的视图中重用它。 例如，我们扩展 about例子把映射的URL从 <tt >/about/&lt;whatever&gt;/</tt> 到一个静态渲染 <tt >about/&lt;whatever&gt;.html</tt> 。 我们首先修改URL配置到新的视图函数：</p>
<pre class="code">
from django.conf.urls.defaults import *
from django.views.generic.simple import direct_to_template
**from mysite.books.views import about_pages**

urlpatterns = patterns('',
    (r'^about/$', direct_to_template, {
        'template': 'about.html'
    }),
    **(r'^about/(\w+)/$', about_pages),**
)
</pre>
<p>接下来，我们编写 <tt >about_pages</tt> 视图的代码：</p>
<pre class="code">
from django.http import Http404
from django.template import TemplateDoesNotExist
from django.views.generic.simple import direct_to_template

def about_pages(request, page):
    try:
        return direct_to_template(request, template=&quot;about/%s.html&quot; % page)
    except TemplateDoesNotExist:
        raise Http404()
</pre>
<p>在这里我们象使用其他函数一样使用 <tt >direct_to_template</tt> 。因为它返回一个 <tt >HttpResponse</tt> 对象，我们只需要简单的返回它就好了。 有一个稍微复杂的地方，要处理没有找到模板的情况。 这里唯一有点棘手的事情是处理找不到模板的情况
我们不希望一个不存在的模板导致一个服务端错误，用TemplateDoesNotExist异常并且升起404 errors 取而代之。</p>
<p>这里有没有安全性问题？</p>
<p>眼尖的读者可能已经注意到一个可能的安全漏洞： 我们直接使用从客户端浏览器来的数据构造 模板名称(<tt >template=&quot;about/%s.html&quot; % page</tt> )。乍看起来，这像是一个经典的 <em>目录遍历（directory traversal）</em> 攻击（详情请看第十九章）。 事实真是这样吗？</p>
<p>完全不是。 是的，一个恶意的 <tt >page</tt> 值可以导致目录跨越，但是尽管 <tt >page</tt> <em>是</em> 从 请求的URL中获取的，并不是所有的值都被接受。 这就是URL配置的关键所在： 我们使用正则表达式 <tt >\w+</tt> 来从URL里匹配 <tt >page</tt> ，而 <tt >\w</tt> 只接受字符和数字。 因此，任何恶意的字符 （例如在这里是点 <tt >.</tt> 和正斜线 <tt >/</tt> ）将在URL解析时被拒绝，根本不会传递给视图函数。</p>


<h2  >对象的通用视图</h2>
<p><tt >direct_to_template</tt> 毫无疑问是非常有用的，但Django通用视图最有用的是在呈现 数据库中的数据。
因为这个应用实在太普遍了，Django带有很多内建的通用视图来帮助你很容易 的生成对象的列表和明细视图。</p>
<p>让我们先看看其中的一个通用视图： 对象列表视图。 我们使用第五章中的 <tt >Publisher</tt> 来举例：</p>
<pre class="code">
class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

    def __unicode__(self):
        return self.name

    class Meta:
        ordering = ['name']
</pre>
<p>要为所有的书籍创建一个列表页面，我们使用下面的URL配置：</p>
<pre class="code">
from django.conf.urls.defaults import *
from django.views.generic import list_detail
from mysite.books.models import Publisher

publisher_info = {
    'queryset': Publisher.objects.all(),
}

urlpatterns = patterns('',
    (r'^publishers/$', list_detail.object_list, publisher_info)
)
</pre>
<p>这就是所要编写的所有Python代码。 当然，我们还需要编写一个模板。 我们能够通过在额外参数字典中包含一个<tt >template_name</tt>键来显式的告诉<tt >object_list</tt>视图使用那个模板</p>
<pre class="code">
from django.conf.urls.defaults import *
from django.views.generic import list_detail
from mysite.books.models import Publisher

publisher_info = {
    'queryset': Publisher.objects.all(),
    **'template_name': 'publisher_list_page.html',**
}

urlpatterns = patterns('',
    (r'^publishers/$', list_detail.object_list, publisher_info)
)
</pre>
<p>In the absence of <tt >template_name</tt> , though, the <tt >object_list</tt> generic view
will infer one from the object&#8217;s name. 在这个例子中，这个推导出的模板名称 将是 <tt >&quot;books/publisher_list.html&quot;</tt> ，其中books部分是定义这个模型的app的名称， publisher部分是这个模型名称的小写。</p>
<p>这个模板将按照 context 中包含的变量 <tt >object_list</tt> 来渲染，这个变量包含所有的书籍对象。 一个非常简单的模板看起来象下面这样：</p>
<pre class="code">
{% extends &quot;base.html&quot; %}

{% block content %}
    &lt;h2&gt;Publishers&lt;/h2&gt;
    &lt;ul&gt;
        {% for publisher in object_list %}
            &lt;li&gt;{{ publisher.name }}&lt;/li&gt;
        {% endfor %}
    &lt;/ul&gt;
{% endblock %}
</pre>
<p>(Note that this assumes the existence of a <tt >base.html</tt> template, as we
provided in an example in Chapter 4.)</p>
<p>这就是所有要做的事。 要使用通用视图酷酷的特性只需要修改参数字典并传递给通用视图函数。 附录D是通用视图的完全参考资料；本章接下来的章节将讲到自定义和扩展通用视图的一些方法。</p>


<h2  >扩展通用视图</h2>
<p>毫无疑问，使用通用视图可以充分加快开发速度。 然而，在多数的工程中，也会出现通用视图不能 满足需求的情况。 实际上，刚接触Django的开发者最常见的问题就是怎样使用通用视图来处理更多的情况。</p>
<p>幸运的是，几乎每种情况都有相应的方法来简单的扩展通用视图来处理它。 这时总是使用下面的 这些方法。</p>

<h3  >制作友好的模板Context</h3>
<p>你也许已经注意到范例中的出版商列表模板在变量 <tt >object_list</tt> 里保存所有的书籍。 这个 方法工作的很好，只是对编写模板的人不太友好：
他们必须知道这里正在处理的是书籍。 他们不得不去了解他们现在处理的数据是什么， 比方说在这里是书籍。
更好的变量名应该是<tt >publisher_list</tt>，这样变量所代表的内容就显而易见了。</p>
<p>我们可以很容易的像下面这样修改 <tt >template_object_name</tt> 参数的名称：</p>
<pre class="code">
from django.conf.urls.defaults import *
from django.views.generic import list_detail
from mysite.books.models import Publisher

publisher_info = {
    'queryset': Publisher.objects.all(),
    'template_name': 'publisher_list_page.html',
    'template_object_name': 'publisher',
}

urlpatterns = patterns('',
    (r'^publishers/$', list_detail.object_list, publisher_info)
)
</pre>
<p>In the template, the generic view will append <tt >_list</tt> to the
<tt >template_object_name</tt> to create the variable name representing the list of
items.</p>
<p>使用有用的 <tt >template_object_name</tt> 总是个好想法。 你的设计模板的合作伙伴会感谢你的。</p>


<h3  >添加额外的Context</h3>
<p>你常常需要呈现比通用视图提供的更多的额外信息。 例如，考虑一下在每个出版商页面实现所有其他 出版商列表。 <tt >object_detail</tt> 通用视图提供了出版商到context，但是看起来没有办法在模板中 获取 <em>所有</em> 出版商列表。</p>
<p>这是解决方法： 所有的通用视图都有一个额外的可选参数 <tt >extra_context</tt> 。这个参数是一个字典数据类型，包含要添加到模板的context中的额外的对象。 所以要提供所有的出版商明细给视图，我们就用这样的info字典：</p>
<pre class="code">
publisher_info = {
    'queryset': Publisher.objects.all(),
    'template_object_name': 'publisher',
    **'extra_context': {'book_list': Book.objects.all()}**
}
</pre>
<p>这样就把一个 <tt >{{ book_list }}</tt> 变量放到模板的context中。
这个方法可以用来传递任意数据 到通用视图模板中去，非常方便。 这是非常方便的</p>
<p>不过，这里有一个很隐蔽的BUG，不知道你发现了没有？</p>
<p>我们现在来看一下， <tt >extra_context</tt> 里包含数据库查询的问题。
因为在这个例子中，我们把 <tt >Publisher.objects.all()</tt> 放在URLconf中，它只会执行一次（当URLconf第一次加载的时候）。 当你添加或删除出版商，你会发现在重启Web服务器之前，通用视图不会反映出这些修改的（有关QuerySet何时被缓存和赋值的更多信息请参考附录C中“缓存与查询集”一节）。</p>
<p>备注</p>
<p>这个问题不适用于通用视图的 <tt >queryset</tt> 参数。 因为Django知道有些特别的 QuerySet <em>永远不能</em> 被缓存，通用视图在渲染前都做了缓存清除工作。</p>
<p>解决这个问题的办法是在 <tt >extra_context</tt> 中用一个回调（callback）来 代替使用一个变量。
任何可以调用的对象（例如一个函数）在传递给 <tt >extra_context</tt> 后都会在每次视图渲染前执行（而不是只执行一次）。 你可以象这样定义一个函数：</p>
<pre class="code">
**def get_books():**
    **return Book.objects.all()**

publisher_info = {
    'queryset': Publisher.objects.all(),
    'template_object_name': 'publisher',
    'extra_context': **{'book_list': get_books}**
}
</pre>
<p>或者你可以使用另一个不是那么清晰但是很简短的方法，事实上 <tt >Publisher.objects.all</tt> 本身就是可以调用的：</p>
<pre class="code">
publisher_info = {
    'queryset': Publisher.objects.all(),
    'template_object_name': 'publisher',
    'extra_context': **{'book_list': Book.objects.all}**
}
</pre>
<p>注意 <tt >Book.objects.all</tt> 后面没有括号；这表示这是一个函数的引用，并没有 真调用它（通用视图将会在渲染时调用它）。</p>


<h3  >显示对象的子集</h3>
<p>现在让我们来仔细看看这个 <tt >queryset</tt> 。大多数通用视图有一个 <tt >queryset</tt> 参数，这个参数告诉视图要显示对象的集合 （有关QuerySet的解释请看第五章的 “选择对象”章节，详细资料请参看附录C）。 大部分通用视图都带有一个参数，这是视图知道显示那一组对象的原因。</p>
<p>举一个简单的例子，我们打算对书籍列表按出版日期排序，最近的排在最前：</p>
<pre class="code">
book_info = {
    'queryset': Book.objects.order_by('-publication_date'),
}

urlpatterns = patterns('',
    (r'^publishers/$', list_detail.object_list, publisher_info),
    **(r'^books/$', list_detail.object_list, book_info),**
)
</pre>
<p>这是一个相当简单的例子，但是很说明问题。 当然，你通常还想做比重新排序更多的事。 如果你想要呈现某个特定出版商出版的所有书籍列表，你可以使用同样的技术：</p>
<pre class="code">
**apress_books = {**
    **'queryset': Book.objects.filter(publisher__name='Apress Publishing'),**
    **'template_name': 'books/apress_list.html'**
**}**

urlpatterns = patterns('',
    (r'^publishers/$', list_detail.object_list, publisher_info),
    **(r'^books/apress/$', list_detail.object_list, apress_books),**
)
</pre>
<p>注意 在使用一个过滤的 <tt >queryset</tt> 的同时，我们还使用一个自定义的模板名称。 如果我们不这么做，通用视图就会用以前的模板，这可能不是我们想要的结果。</p>
<p>同样要注意的是这并不是一个处理出版商相关书籍的最好方法。 如果我们想要添加另一个 出版商页面，我们就得在URL配置中写URL配置，如果有很多的出版商，这个方法就不能 接受了。
在接下来的章节我们将来解决这个问题。</p>


<h3  >用函数包装来处理复杂的数据过滤</h3>
<p>另一个常见的需求是按URL里的关键字来过滤数据对象。 在前面我们用在URL配置中 硬编码出版商名称的方法来做这个，但是我们想要用一个视图就能显示某个出版商 的所有书籍该怎么办呢？ 我们可以通过对 <tt >object_list</tt> 通用视图进行包装来避免 写一大堆的手工代码。 按惯例，我们先从写URL配置开始：</p>
<pre class="code">
urlpatterns = patterns('',
    (r'^publishers/$', list_detail.object_list, publisher_info),
    **(r'^books/(\w+)/$', books_by_publisher),**
)
</pre>
<p>接下来，我们写 <tt >books_by_publisher</tt> 这个视图：</p>
<pre class="code">
from django.shortcuts import get_object_or_404
from django.views.generic import list_detail
from mysite.books.models import Book, Publisher

def books_by_publisher(request, name):

    # Look up the publisher (and raise a 404 if it can't be found).
    publisher = get_object_or_404(Publisher, name__iexact=name)

    # Use the object_list view for the heavy lifting.
    return list_detail.object_list(
        request,
        queryset = Book.objects.filter(publisher=publisher),
        template_name = 'books/books_by_publisher.html',
        template_object_name = 'book',
        extra_context = {'publisher': publisher}
    )
</pre>
<p>这是因为通用视图就是Python函数。 和其他的视图函数一样，通用视图也是接受一些 参数并返回 <tt >HttpResponse</tt> 对象。 因此，通过包装通用视图函数可以做更多的事。</p>
<p>注释</p>
<p>注意到在前面这个例子中我们在 <tt >extra_context</tt> 传递了当前出版商这个参数。</p>


<h3  >处理额外工作</h3>
<p>我们再来看看最后一个常用模式：</p>
<p>想象一下我们在 <tt >Author</tt> 对象里有一个 <tt >last_accessed</tt> 字段，我们用这个字段来更正对author的最近访问时间。 当然通用视图 <tt >object_detail</tt> 并不能处理 这个问题，我们可以很容易的写一个自定义的视图来更新这个字段。</p>
<p>首先，我们需要在URL配置里设置指向到新的自定义视图：</p>
<pre class="code">
from mysite.books.views import author_detail

urlpatterns = patterns('',
    # ...
    **(r'^authors/(?P&lt;author_id&gt;\d+)/$', author_detail),**
    # ...
)
</pre>
<p>接下来写包装函数：</p>
<pre class="code">
import datetime
from django.shortcuts import get_object_or_404
from django.views.generic import list_detail
from mysite.books.models import Author

def author_detail(request, author_id):
    # Delegate to the generic view and get an HttpResponse.
    response = list_detail.object_detail(
        request,
        queryset = Author.objects.all(),
        object_id = author_id,
    )

    # Record the last accessed date. We do this *after* the call
    # to object_detail(), not before it, so that this won't be called
    # unless the Author actually exists. (If the author doesn't exist,
    # object_detail() will raise Http404, and we won't reach this point.)
    now = datetime.datetime.now()
    Author.objects.filter(id=author_id).update(last_accessed=now)

    return response
</pre>
<p>注释</p>
<p>除非你添加 <tt >last_accessed</tt> 字段到你的 <tt >Author</tt> 模型并创建 <tt >books/author_detail.html</tt> 模板，否则这段代码不能真正工作。</p>
<p>我们可以用同样的方法修改通用视图的返回值。
如果我们想要提供一个供下载用的 纯文本版本的author列表，我们可以用下面这个视图：</p>
<pre class="code">
def author_list_plaintext(request):
    response = list_detail.object_list(
        request,
        queryset = Author.objects.all(),
        mimetype = 'text/plain',
        template_name = 'books/author_list.txt'
    )
    response[&quot;Content-Disposition&quot;] = &quot;attachment; filename=authors.txt&quot;
    return response
</pre>
<p>这个方法之所以工作是因为通用视图返回的 <tt >HttpResponse</tt> 对象可以象一个字典 一样的设置HTTP的头部。 随便说一下，这个 <tt >Content-Disposition</tt> 的含义是 告诉浏览器下载并保存这个页面，而不是在浏览器中显示它。</p>



<h2  >下一章</h2>
<p>在这一章我们只讲了Django带的通用视图其中一部分，不过这些方法也适用于其他的 通用视图。 有关更详细的内容，请看附录D。</p>
<p>这本书的高级语法部分到此结束。 在<a href="chapter12.html">下一章 </a>, 我们涵盖了Django应用方面的部署。</p>



    
    
  



        
	<a href="chapter10.html">| 上一章</a> |
    	<a href="index.html">目  录</a> |
    	<a href="chapter12.html">下一章 </a> |










<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->