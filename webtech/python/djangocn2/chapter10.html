<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->




      
        
        
        
        	<a href="chapter09.html">| 上一章</a> |
        	<a href="index.html">目  录</a> |
        	<a href="chapter11.html">下一章 </a> |
        
     


  
    
    
    
<h1  >第10章： 数据模型高级进阶</h1>
<p>在第5章里，我们介绍了Django的数据层如何定义数据模型以及如何使用数据库API来创建、检索、更新以及删除记录 在这章里，我们将向你介绍Django在这方面的一些更高级功能</p>

<h2  >相关对象</h2>
<p>先让我们回忆一下在第五章里的关于书本(book)的数据模型</p>
<pre class="code">
from django.db import models

class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

    def __unicode__(self):
        return self.name

class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField()

    def __unicode__(self):
        return u'%s %s' % (self.first_name, self.last_name)

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()

    def __unicode__(self):
        return self.title
</pre>
<p>如我们在第5章的讲解,在数据库对象获取特定字段的值只需直接使用属性那么简单 例如,要确定ID为50的书本的标题,我们这样做:</p>
<pre class="code">
&gt;&gt;&gt; from mysite.books.models import Book
&gt;&gt;&gt; b = Book.objects.get(id=50)
&gt;&gt;&gt; b.title
u'The Django Book'
</pre>
<p>但是,在之前有一件我们没提及到的是表示为<tt >ForeignKey</tt> 或 <tt >ManyToManyField</tt>的相互关联对象字段,它们的作用稍有不同</p>

<h3  >访问外键(Foreign Key)值</h3>
<p>当你获取一个为<tt >ForeignKey</tt> 字段时,你会得到相关的数据模型对象. 例如:</p>
<pre class="code">
&gt;&gt;&gt; b = Book.objects.get(id=50)
&gt;&gt;&gt; b.publisher
&lt;Publisher: Apress Publishing&gt;
&gt;&gt;&gt; b.publisher.website
u'http://www.apress.com/'
</pre>
<p>对于用`` ForeignKey`` 来定义的关系来说，在关系的另一端也能反向的追溯回来，只不过由于不对称性的关系而稍有不同。 通过一个`` publisher`` 对象，直接获取 books ，用 publisher.book_set.all() ，如下：</p>
<pre class="code">
&gt;&gt;&gt; p = Publisher.objects.get(name='Apress Publishing')
&gt;&gt;&gt; p.book_set.all()
[&lt;Book: The Django Book&gt;, &lt;Book: Dive Into Python&gt;, ...]
</pre>
<p>实际上，<tt >book_set</tt> 只是一个 <tt >QuerySet</tt>（参考第5章的介绍），所以它可以像<tt >QuerySet</tt>一样,能实现数据过滤和分切，例如：</p>
<pre class="code">
&gt;&gt;&gt; p = Publisher.objects.get(name='Apress Publishing')
&gt;&gt;&gt; p.book_set.filter(name__icontains='django')
[&lt;Book: The Django Book&gt;, &lt;Book: Pro Django&gt;]
</pre>
<p>属性名称<tt >book_set</tt>是由模型名称的小写(如book)加<tt >_set</tt>组成的。</p>


<h3  >访问多对多值(Many-to-Many Values)</h3>
<p>Many-to-many values work like foreign-key values, except we deal with <tt >QuerySet</tt> values
instead of model instances. 例如,这里是如何查看书籍的作者</p>
<pre class="code">
&gt;&gt;&gt; b = Book.objects.get(id=50)
&gt;&gt;&gt; b.authors.all()
[&lt;Author: Adrian Holovaty&gt;, &lt;Author: Jacob Kaplan-Moss&gt;]
&gt;&gt;&gt; b.authors.filter(first_name='Adrian')
[&lt;Author: Adrian Holovaty&gt;]
&gt;&gt;&gt; b.authors.filter(first_name='Adam')
[]
</pre>
<p>反方向也可以 要查看一个作者的所有书籍,使用<tt >author.book_set</tt> ,就如这样:</p>
<pre class="code">
&gt;&gt;&gt; a = Author.objects.get(first_name='Adrian', last_name='Holovaty')
&gt;&gt;&gt; a.book_set.all()
[&lt;Book: The Django Book&gt;, &lt;Book: Adrian's Other Book&gt;]
</pre>
<p>这里,就像使用 <tt >ForeignKey</tt>字段,属性名<tt >book_set</tt>是在数据模型(model)名后追加<tt >_set</tt> 而产生的.</p>



<h2  >更改数据库模式(Database Schema)</h2>
<p>在我们在第5章介绍 <tt >syncdb</tt> 这个命令时, 我们注意到 <tt >syncdb</tt> 只仅仅创建数据库里还没有的数据表,它 <em>并不</em> 对你的数据模型修改进行同步,也不处理数据模型里的删除. 如果你新增或修改数据模型里的字段,或是删除了一个数据模型,你需要自己手动在数据库里进行相应的修改 这段将解析如何做</p>
<p>当处理模型修改的时候，将Django的数据库层的工作流程铭记于心是很重要的。</p>
<ul >
<li  ><p>如果模型包含一个未曾在数据库里建立的字段，Django会报出错信息。 当你第一次用Django的数据库API来请求不存在的表会导致错误的。（例如，它会在运行期出错，而不是编译期）</p>
</li>
</ul>
<ul >
<li  ><p>Django<em>不</em>关心数据库的表格中是否存在未在模型中定义的列。</p>
</li>
</ul>
<ul >
<li  ><p>Django<em>不</em>关心数据库中是否存在未被模型表示的表格。</p>
</li>
</ul>
<p>Making schema changes is a matter of changing the various pieces the Python code and the
database itself in the right order.</p>

<h3  >添加字段</h3>
<p>当要向一个产品设置表单(或者说是model)添加一个字段的时候,要使用的技巧是利用Django不关心表单里是否包含model里所没有的列 策略就是在数据库里加入要加的字段列,然后同步Django的模型添加新字段</p>
<p>然而 这里有一个鸡生蛋蛋生鸡的问题 ,由于要想了解新列能否在SQL里表达出来(expressed) ,你需要使用Django的
<tt >manage.py sqlall</tt>命令进行查看 ,而这又需要字段已经在模型里存在了 (注意:你并 <em>不是非得使用</em>与Django相同的SQL创建你的新列,但是这样做确实是一个好主意 ,它能让一切都保持同步)</p>
<p>这个鸡-蛋的问题的解决方法是在开发者环境里而不是发布环境里实现这个变化 (你<em>正</em>使用的是测试环境,对吧?)下面是具体的实施步骤</p>
<p>首先,进入开发者环境(也就是说 不是在发布环境里)</p>
<ol >
<li  ><p>在你的模型里添加字段</p>
</li>
</ol>
<ol  start="2">
<li  ><p>运行 <tt >manage.py sqlall [yourapp]</tt> 来测试模型新的 <tt >CREATE TABLE</tt> 语句 注意 为新字段定义的列</p>
</li>
</ol>
<ol  start="3">
<li  ><blockquote >
<p>开启你的数据库的交互命令界面(e.g., <tt >psql</tt> or <tt >mysql</tt> , or you can use</p>
</blockquote>

<p>System Message: WARNING/2 (<tt >&lt;string&gt;</tt>, line 240)</p>
<p>Block quote ends without a blank line; unexpected unindent.</p>

<p><tt >manage.py dbshell</tt> ). 执行一个 <tt >ALTER TABLE</tt> 语句来添加新列</p>
</li>
</ol>
<ol  start="4">
<li  ><p>使用Python的<tt >manage.py shell</tt>通过导入模型和选中表单(e.g.,
<tt >MyModel.objects.all()[:5]</tt> ).来核实新的字段是否被正确的添加 ,如果一切顺利,所有的语句都不会报错.</p>
</li>
</ol>
<p>然后 在你的产品服务器上再实施一遍这些步骤</p>
<ol >
<li  ><p>启动数据库的交互界面。</p>
</li>
</ol>
<ol  start="2">
<li  ><p>执行在开发环境步骤中，第三步的<tt >ALTER TABLE</tt>语句</p>
</li>
</ol>
<ol  start="3">
<li  ><p>将新的字段加入到模型中 如果你使用了某种版本控制工具，并且在第一步中，已经提交了你在开发环境上的修改，现在，可以在生产环境中更新你的代码了（例如，如果你使用Subversion，执行<tt >svn update</tt></p>
</li>
</ol>
<ol  start="4">
<li  ><p>重新启动Web server，使修改生效。</p>
</li>
</ol>
<p>比如让我们看看如何添加一个num_pages域到第五章中Book模型。首先，我们会把开发环境中的模型改成如下形式：</p>
<pre class="code">
class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()
    **num_pages = models.IntegerField(blank=True, null=True)**

    def __unicode__(self):
        return self.title
</pre>
<p>(注意 Read the section Making Fields Optional in Chapter 6, plus the sidebar Adding NOT
NULL Columns below for important details on why we included <tt >blank=True</tt> and <tt >null=True</tt>
.)</p>
<p>然后，我们运行命令manage.py sqlall books 来查看create table语句
语句的具体内容取决与你所使用的数据库， 大概是这个样子</p>
<pre class="code">
CREATE TABLE &quot;books_book&quot; (
    &quot;id&quot; serial NOT NULL PRIMARY KEY,
    &quot;title&quot; varchar(100) NOT NULL,
    &quot;publisher_id&quot; integer NOT NULL REFERENCES &quot;books_publisher&quot; (&quot;id&quot;),
    &quot;publication_date&quot; date NOT NULL,
    &quot;num_pages&quot; integer NULL
);
</pre>
<p>新加的字段被这样表示：</p>
<pre class="code">
&quot;num_pages&quot; integer NULL
</pre>
<p>接下来，我们要在开发环境上运行数据库客户端，如果是PostgreSQL，运行 psql, 然后，我执行如下语句</p>
<pre class="code">
ALTER TABLE books_book ADD COLUMN num_pages integer;
</pre>
<p>添加 非NULL 字段</p>
<p>这里有个微妙之处值得一提 在我们添加字段 num_pages 的时候, 我们使用了 blank=True 和 null=True 选项 这是因为在我们第一次创建它的时候，这个数据库字段会含有空值。</p>
<p>然而，想要添加不能含有空值的字段也是可以的            要想实现这样的效果，你必须先创建 NULL 型的字段，然后将该字段的值填充为某个默认值，然后再将该字段改为 NOT NULL 型。 例如</p>
<pre class="code">
BEGIN;
ALTER TABLE books_book ADD COLUMN num_pages integer;
UPDATE books_book SET num_pages=0;
ALTER TABLE books_book ALTER COLUMN num_pages SET NOT NULL;
COMMIT;
</pre>
<p>如果你这样做，记得你不要在模型中添加 blank=True 和 null=True 选项</p>
<p>执行ALTER TABLE之后，我们要验证一下修改结果是否正确。启动python并执行下面的代码</p>
<pre class="code">
&gt;&gt;&gt; from mysite.books.models import Book
&gt;&gt;&gt; Book.objects.all()[:5]
</pre>
<p>如果没有异常发生,我们将切换到生产服务器,然后在生产环境的数据库中执行命令<tt >ALTER TABLE</tt> 然后我们更新生产环境中的模型,最后重启web服务器</p>


<h3  >删除字段</h3>
<p>从Model中删除一个字段要比添加容易得多 删除字段，仅仅只要以下几个步骤</p>
<blockquote>
<p>删除字段，然后重新启动你的web服务器</p>
<p>用以下命令从数据库中删除字段</p>
</blockquote>
<pre class="code">
ALTER TABLE books_book DROP COLUMN num_pages;
</pre>
<p>请保证操作的顺序正确 如果你从数据库中删除字段，Django 将会立即抛出异常</p>


<h3  >删除关联字段</h3>
<p>由于关联字段不同于普通字段，所以删除操作是不同的</p>
<blockquote>
<p>从你的模型中删除，然后重启web服务器<tt >ManyToManyField</tt></p>
<p>用下面的命令从数据库删除关联表</p>
</blockquote>
<pre class="code">
DROP TABLE books_book_authors;
</pre>
<p>像上面一样，注意操作的顺序</p>


<h3  >删除模型</h3>
<p>删除整个模型要比删除一个字段容易 删除一个模型只要以下几个步骤</p>
<blockquote>
<p>从文件中删除你想要删除的模型，然后重启web 服务器<tt >models.py</tt></p>
<p>然后用以下命令从数据库中删除表</p>
</blockquote>
<pre class="code">
DROP TABLE books_book;
</pre>
<blockquote>
<p>当你需要从数据库中删除第一个任何依赖的表时要注意，例如有任何表外键的表 books_book。</p>
</blockquote>
<p>正如在前面部分，一定要按这样的顺序做。</p>



<h2  >Managers</h2>
<p>在声明中 Book.objects.all() , objects是一个特殊的属性，需要通过它查询数据库。 在第5章，我们简要地确定模块manager 。现在是时候更深入的使用managers它们。</p>
<p>总之，模块manager是一个对象，通过它Django的模块进行数据库查询。 每个Django模块至少有一个manager，你可以创建自定义管理中以自定义数据库访问。</p>
<p>下面是你manager创建自定义创建的两个原因 增加额外的manager方法，和/或修改最初QuerySet的manager返回值。</p>

<h3  >Manager增加额外的方法</h3>
<p>增加额外manager的方法是首选的办法来添加表级功能的你的模块。 (For row-level functionality i.e., functions that act on a single instance of a
model object use model methods, which are explained later in this chapter.)</p>
<p>例如,我们为Book模型定义了一个title_count()方法,它需要一个关键字,返回包含这个关键字的书的数量. （这个例子稍微做作，但它演示了如何管理工作。）</p>
<pre class="code">
# models.py

from django.db import models

# ... Author and Publisher models here ...

**class BookManager(models.Manager):**
    **def title_count(self, keyword):**
        **return self.filter(title__icontains=keyword).count()**

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()
    num_pages = models.IntegerField(blank=True, null=True)
    **objects = BookManager()**

    def __unicode__(self):
        return self.title
</pre>
<p>有了这个manager地方，我们现在可以这样做：</p>
<pre class="code">
&gt;&gt;&gt; Book.objects.title_count('django')
4
&gt;&gt;&gt; Book.objects.title_count('python')
18
</pre>
<p>下面是编码该注意的一些地方：</p>
<ul >
<li  ><p>我们建立了一个BookManager类,它继承了django.db.models.Manager.只拥有一个title_count()方法用来做统计. 注意,这个方法使用了self.filter(),此处self指manager本身</p>
</li>
</ul>
<ul >
<li  ><p>我们把BookManager()赋值给模型的objects属性. 它将取代模型的默认manager,如果我们没有特别自定义一个manager叫objects,它将会被自动建. 我们命名他为objects而不是其它的,是为了与自动创建的manager保持一致.</p>
</li>
</ul>
<p>为什么我们要添加一个title_count()方法呢?是为了将经常使用的查询进行封装,这样我们就不必重复的编码了.</p>


<h3  >修改初始Manager QuerySets</h3>
<p>一个manager的基本QuerySet返回系统中的所有objects. 例如,Book.objects.all返回数据库book中的所有书本.</p>
<p>我们可以通过覆盖Manager.get_query_set()方法来覆盖manager的基本QuerySet. get_query_set()按照你的要求返回一个QuerySet.</p>
<p>例如,下面的模型有两个manager.一个返回所有对像,另一个只返回作者是Roald Dahl的书.</p>
<pre class="code">
from django.db import models

**# First, define the Manager subclass.**
**class DahlBookManager(models.Manager):**
    **def get_query_set(self):**
        **return super(DahlBookManager, self).get_query_set().filter(author='Roald Dahl')**

**# Then hook it into the Book model explicitly.**
class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=50)
    # ...

    **objects = models.Manager() # The default manager.**
    **dahl_objects = DahlBookManager() # The Dahl-specific manager.**
</pre>
<p>在这个示例模型中,Book.objects.all()返回了数据库中的所有书本,而Book.dahl_objects.all()只返回了一本. 注意我们明确的将objects设置成manager的实例,是因为如果我们不这么做,那么唯一可用的manager就将是dah1_objects.</p>
<p>当然,由于get_query_set()返回的是一个QuerySet对像,所以我们可以使用filter(),exclude()和其他一切QuerySet的方法. 像这些语法都是正确的.</p>
<pre class="code">
Book.dahl_objects.all()
Book.dahl_objects.filter(title='Matilda')
Book.dahl_objects.count()
</pre>
<p>这个例子也指出了其他有趣的技术: 在同一个模型中使用多个manager. 只要你愿意,你可以为你的模型添加多个manager()实例. 这是一个为模型添加通过滤器的简单方法.</p>
<p>例如:</p>
<pre class="code">
class MaleManager(models.Manager):
    def get_query_set(self):
        return super(MaleManager, self).get_query_set().filter(sex='M')

class FemaleManager(models.Manager):
    def get_query_set(self):
        return super(FemaleManager, self).get_query_set().filter(sex='F')

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    sex = models.CharField(max_length=1, choices=(('M', 'Male'), ('F', 'Female')))
    people = models.Manager()
    men = MaleManager()
    women = FemaleManager()
</pre>
<p>这个例子允许你执行Person.men.all(),Person.women.all(),Person.people.all()查询,生成你想要的结果.</p>
<p>如果你自定义了Manager对像.请注意,第一个Manager(它在模型中被定义的位置)会有一个特殊状态. Django将会把第一个manager定义为默认manager,Django的许多部分(但是不包括admin应用)将会明确的为模型使用这个manager. 结论是,你通常要小心的选择你的默认manager.由于覆盖get_query_set(),你可能接受到一个无用的返回对像,你必须避免这种情况.</p>



<h2  >模型方法</h2>
<p>为了给你的对像添加一个行级功能,那就定义一个自定义方法.
有鉴于manager经常被用来用一些table-wide的事情,模型方法应该只对特殊模型实例起作用.</p>
<p>在模型的同一处保持事务逻辑是一项有价值的技术.</p>
<p>一个例子是阐述它的最简单途径. 这个模型有一些自定义方法.</p>
<pre class="code">
from django.contrib.localflavor.us.models import USStateField
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()
    address = models.CharField(max_length=100)
    city = models.CharField(max_length=50)
    state = USStateField() # Yes, this is U.S.-centric...

    def baby_boomer_status(self):
        &quot;Returns the person's baby-boomer status.&quot;
        import datetime
        if datetime.date(1945, 8, 1) &lt;= self.birth_date &lt;= datetime.date(1964, 12, 31):
            return &quot;Baby boomer&quot;
        if self.birth_date &lt; datetime.date(1945, 8, 1):
            return &quot;Pre-boomer&quot;
        return &quot;Post-boomer&quot;

    def is_midwestern(self):
        &quot;Returns True if this person is from the Midwest.&quot;
        return self.state in ('IL', 'WI', 'MI', 'IN', 'OH', 'IA', 'MO')

    def _get_full_name(self):
        &quot;Returns the person's full name.&quot;
        return u'%s %s' % (self.first_name, self.last_name)
    full_name = property(_get_full_name)
</pre>
<p>例子中的最后一个方法是一个property. 想了解更多property请到http://www.python.org/download/releases/2.2/descrintro/#property</p>
<p>在这演示例子的用法.</p>
<pre class="code">
&gt;&gt;&gt; p = Person.objects.get(first_name='Barack', last_name='Obama')
&gt;&gt;&gt; p.birth_date
datetime.date(1961, 8, 4)
&gt;&gt;&gt; p.baby_boomer_status()
'Baby boomer'
&gt;&gt;&gt; p.is_midwestern()
True
&gt;&gt;&gt; p.full_name  # Note this isn't a method -- it's treated as an attribute
u'Barack Obama'
</pre>


<h2  >执行,行SQL查询.</h2>
<p>有时候你会发现django数据库api带给你的也只有这么多,那你可以为你的数据库写一些自定义SQL查询. 你可以通过导入django.db.connection对像来轻松实现,它代表当前数据库连接. 使用它,通过connection.cursor()可以得到一个游标对像. 然后,使用cursor.execute(sql, [params])来执行SQL语句和cursor.fetchone()或者cursor.fetchall(),返回记录集. 例如:</p>
<pre class="code">
&gt;&gt;&gt; from django.db import connection
&gt;&gt;&gt; cursor = connection.cursor()
&gt;&gt;&gt; cursor.execute(&quot;&quot;&quot;
...    SELECT DISTINCT first_name
...    FROM people_person
...    WHERE last_name = %s&quot;&quot;&quot;, ['Lennon'])
&gt;&gt;&gt; row = cursor.fetchone()
&gt;&gt;&gt; print row
['John']
</pre>
<p>connection和curso可以最大程度的实现标准Python DB-API,你可以在http://www.python.org/peps/pep-0249.html了解它. 如果你对Python DB-API不熟悉,请注意在SQL语句cursor.execute()使用&#8221;%s&#8221;,而不要在SQL内试图立刻添加一个参数. 如果你使用了这个技术,数据库后的基础库将会自动添加引用同时尽可能的转意你的参数.</p>
<p>更不要把你的视图代码和django.db.connection语句混杂在一起,把它们放在自定义模型或者自定义manager方法中是个不错的主意. 比如,上面的例子可以被整合成一个自定义manager方法就像这样:</p>
<pre class="code">
from django.db import connection, models

class PersonManager(models.Manager):
    def first_names(self, last_name):
        cursor = connection.cursor()
        cursor.execute(&quot;&quot;&quot;
            SELECT DISTINCT first_name
            FROM people_person
            WHERE last_name = %s&quot;&quot;&quot;, [last_name])
        return [row[0] for row in cursor.fetchone()]

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    objects = PersonManager()
</pre>
<p>然后这样使用:</p>
<pre class="code">
&gt;&gt;&gt; Person.objects.first_names('Lennon')
['John', 'Cynthia']
</pre>


<h2  >下一章</h2>
<p>In the <a  href="chapter11.html">next chapter</a>, we&#8217;ll show you Django&#8217;s generic views framework, which lets you save
time in building Web sites that follow common patterns.</p>



    
    
  



        
	<a href="chapter09.html">| 上一章</a> |
    	<a href="index.html">目  录</a> |
    	<a href="chapter11.html">下一章 </a> |










<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->