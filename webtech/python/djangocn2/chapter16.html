<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->




      
        
        
        
        	<a href="chapter15.html">| 上一章</a> |
        	<a href="index.html">目  录</a> |
        	<a href="chapter17.html">下一章 </a> |
        
     


  
    
    
    
<h1  >第十六章：集成的子框架 django.contrib</h1>
<p>Python有众多优点，其中之一就是“开机即用”原则： 安装Python的同时安装好大量的标准软件包，这样 你可以立即使用而不用自己去下载。 Django也遵循这个原则，它同样包含了自己的标准库。
这一章就来讲 这些集成的子框架。</p>

<h2  >Django标准库</h2>
<p>Django的标准库存放在 <tt >django.contrib</tt> 包中。 每个子包都是一个独立的附加功能包。</p>
<p>在 <tt >django.contrib</tt> 中对函数的类型并没有强制要求 。其中一些包中带有模型（因此需要你在数据库中安装对应的数据表），但其它一些由独立的中间件及模板标签组成。</p>
<p><tt >django.contrib</tt> 开发包共有的特性是:就算你将整个 <tt >django.contrib</tt> 开发包删除，你依然可以使用 Django 的基础功能而不会遇到任何问题。 当 Django 开发者向框架增加新功能的时，他们会严格根据这一教条来决定是否把新功能放入 <tt >django.contrib</tt> 中。 When the Django developers add new functionality to the framework,
they use this rule of thumb in deciding whether the new functionality should live in
<tt >django.contrib</tt> or elsewhere.</p>
<p><tt >django.contrib</tt> 由以下开发包组成：</p>
<ul >
<li  ><p><tt >admin</tt> : 自动化的站点管理工具。 请查看第12章</p>
</li>
</ul>
<ul >
<li  ><p><tt >admindocs</tt> : Auto-documentation for the Django admin site. This book doesn&#8217;t cover this
feature; check the official Django documentation.</p>
</li>
</ul>
<ul >
<li  ><p><tt >auth</tt> : Django的用户验证框架。 See Chapter 14.</p>
</li>
</ul>
<ul >
<li  ><p><tt >comments</tt> : 一个评论应用，目前，这个应用正在紧张的开发中，因此在本书出版的时候还不能给出一个完整的说明，关于这个应用的更多信息请参见Django的官方网站. This book doesn&#8217;t cover this feature; check the
official Django documentation.</p>
</li>
</ul>
<ul >
<li  ><p><tt >contenttypes</tt> : 这是一个用于文档类型钩子的框架，每个安装的Django模块作为一种独立的文档类型。 这个框架主要在Django内部被其他应用使用，它主要面向Django的高级开发者。 可以通过阅读源码来了解关于这个框架的更多信息，源码的位置在 <tt >django/contrib/contenttypes/</tt> .</p>
</li>
</ul>
<ul >
<li  ><p><tt >csrf</tt> : 这个模块用来防御跨站请求伪造(CSRF).参见后面标题为&#8221;CSRF 防御&#8221;的小节。 参见后面标题为《重定向》的小节。</p>
</li>
</ul>
<ul >
<li  ><p><tt >databrowse</tt> : A Django application that lets you browse your data. This book doesn&#8217;t
cover this feature; check the official Django documentation.</p>
</li>
</ul>
<ul >
<li  ><p><tt >flatpages</tt> : 一个在数据库中管理单一HTML内容的模块，参见后面标题为“Flatpages”的小节。 See the
later section titled Flatpages.</p>
</li>
</ul>
<ul >
<li  ><p><tt >formtools</tt> : A number of useful higher-level libraries for dealing with common patterns
in forms. This book doesn&#8217;t cover this feature; check the official Django documentation.</p>
</li>
</ul>
<ul >
<li  ><p><tt >gis</tt> : Extensions to Django that provide for GIS (Geographic Information Systems)
support. These, for example, allow your Django models to store geographic data and perform
geographic queries. This is a large, complex library and isn&#8217;t covered in this book. See
<a  href="http://geodjango.org/">http://geodjango.org/</a> for documentation.</p>
</li>
</ul>
<ul >
<li  ><p><tt >humanize</tt> : 一系列 Django 模块过滤器，用于增加数据的人性化。
参阅稍后的章节《人性化数据》。</p>
</li>
</ul>
<ul >
<li  ><p><tt >localflavor</tt> : Assorted pieces of code that are useful for particular countries or
cultures. For example, this includes ways to validate U.S. ZIP codes or Icelandic
identification numbers.</p>
</li>
</ul>
<ul >
<li  ><p><tt >markup</tt> : 一系列的 Django 模板过滤器，用于实现一些常用标记语言。 参阅后续章节《标记过滤器》。</p>
</li>
</ul>
<ul >
<li  ><p><tt >redirects</tt> : 用来管理重定向的框架。 See the later section titled Redirects.</p>
</li>
</ul>
<ul >
<li  ><p><tt >sessions</tt> : Django 的会话框架，参见12章。 See Chapter 14.</p>
</li>
</ul>
<ul >
<li  ><p><tt >sitemaps</tt> : 用来生成网站地图的 XML 文件的框架。 See Chapter 13.</p>
</li>
</ul>
<ul >
<li  ><p><tt >sites</tt> : 一个让你可以在同一个数据库与 Django 安装中管理多个网站的框架。 参见下一节：</p>
</li>
</ul>
<ul >
<li  ><p><tt >syndication</tt> : 一个用 RSS 和 Atom 来生成聚合订阅源的的框架。 See Chapter
13.</p>
</li>
</ul>
<ul >
<li  ><p><tt >webdesign</tt> : Django add-ons that are particularly useful to Web <em>designers</em> (as opposed
to developers). As of this writing, this included only a single template tag, <tt >{% lorem
%}</tt> . Check the Django documentation for information.</p>
</li>
</ul>
<p>本章接下来将详细描述前面没有介绍过的 <tt >django.contrib</tt> 开发包内容。</p>


<h2  >多个站点</h2>
<p>Django 的多站点系统是一种通用框架，它让你可以在同一个数据库和同一个Django项目下操作多个网站。 这是一个抽象概念，理解起来可能有点困难，因此我们从几个让它能派上用场的实际情景入手。</p>

<h3  >情景1：</h3>
<p>正如我们在第一章里所讲，Django 构建的网站 LJWorld.com 和 Lawrance.com 是用由同一个新闻组织控制的： 肯萨斯州劳伦斯市的 <em>劳伦斯日报世界</em> 报纸。 LJWorld.com 主要做新闻，而 Lawrence.com 关注本地娱乐。 然而有时，编辑可能需要把一篇文章发布到 <em>两个</em> 网站上。</p>
<p>解决此问题的死脑筋方法可能是使用每个站点分别使用不同的数据库，然后要求站点维护者把同一篇文章发布两次： 一次为 LJWorld.com，另一次为Lawrence.com。 但这对站点管理员来说是低效率的，而且为同一篇文章在数据库里保留多个副本也显得多余。</p>
<p>更好的解决方案？ 两个网站用的是同一个文章数据库，并将每一篇文章与一个或多个站点用多对多关系关联起来。 Django 站点框架提供数据库记载哪些文章可以被关联。 它是一个把数据与一个或多个站点关联起来的钩子。</p>


<h3  >情景2：</h3>
<p>LJWorld.com 和 Lawrence.com 都有邮件提醒功能，使读者注册后可以在新闻发生后立即收到通知。 这是一种完美的的机制： 某读者提交了注册表单，然后马上就受到一封内容是“感谢您的注册”的邮件。</p>
<p>把这个注册过程的代码实现两遍显然是低效、多余的，因此两个站点在后台使用相同的代码。 但感谢注册的通知在两个网站中需要不同。 通过使用 <tt >Site</tt> 对象，我们通过使用当前站点的 <tt >name</tt> (例如 <tt >'LJWorld.com'</tt> )和 <tt >domain</tt> (例如 <tt >'www.ljworld.com'</tt> )可以把感谢通知抽提出来。</p>
<p>Django 的多站点框架为你提供了一个位置来存储 Django 项目中每个站点的 <tt >name</tt> 和 <tt >domain</tt> ，这意味着你可以用同样的方法来重用这些值。</p>


<h3  >如何使用多站点框架</h3>
<p>多站点框架与其说是一个框架，不如说是一系列约定。 所有的一切都基于两个简单的概念：</p>
<ul >
<li  ><p>位于 <tt >django.contrib.sites</tt> 的 <tt >Site</tt> 模型有 <tt >domain</tt> 和 <tt >name</tt> 两个字段。</p>
</li>
</ul>
<ul >
<li  ><p><tt >SITE_ID</tt> 设置指定了与特定配置文件相关联的 <tt >Site</tt> 对象之数据库 ID。</p>
</li>
</ul>
<p>如何运用这两个概念由你决定，但 Django 是通过几个简单的约定自动使用的。</p>
<p>安装多站点应用要执行以下几个步骤：</p>
<ol >
<li  ><p>将 <tt >'django.contrib.sites'</tt> 加入到 <tt >INSTALLED_APPS</tt> 中。</p>
</li>
</ol>
<ol  start="2">
<li  ><p>运行 <cite>manage.py syncdb</cite> 命令将 <cite>django_site</cite> 表安装到数据库中。 这样也会建立默认的站点对象，域名为 example.com。</p>
</li>
</ol>
<ol  start="3">
<li  ><p>Change the <tt >example.com</tt> site to your own domain, and add any other <tt >Site</tt> objects,
either through the Django admin site or via the Python API. 为该 Django 项目支撑的每个站（或域）创建一个 <tt >Site</tt> 对象。</p>
</li>
</ol>
<ol  start="4">
<li  ><p>在每个设置文件中定义一个 <tt >SITE_ID</tt> 变量。 该变量值应当是该设置文件所支撑的站点之 <tt >Site</tt> 对象的数据库 ID 。</p>
</li>
</ol>


<h3  >多站点框架的功能</h3>
<p>下面几节讲述的是用多站点框架能够完成的几项工作。</p>

<h4  >多个站点的数据重用</h4>
<p>正如在情景一中所解释的，要在多个站点间重用数据,仅需在模型中为 <tt >Site</tt> 添加一个 <tt >多对多字段</tt> 即可，例如：</p>
<pre class="code">
from django.db import models
from django.contrib.sites.models import Site

class Article(models.Model):
    headline = models.CharField(max_length=200)
    # ...
    sites = models.ManyToManyField(Site)
</pre>
<p>这是在数据库中为多个站点进行文章关联操作的基础步骤。
在适当的位置使用该技术，你可以在多个站点中重复使用同一段 Django 视图代码。 继续 <tt >Article</tt> 模型范例，下面是一个可能的 <tt >article_detail</tt> 视图：</p>
<pre class="code">
from django.conf import settings
from django.shortcuts import get_object_or_404
from mysite.articles.models import Article

def article_detail(request, article_id):
    a = get_object_or_404(Article, id=article_id, sites__id=settings.SITE_ID)
    # ...
</pre>
<p>该视图方法是可重用的，因为它根据 <tt >SITE_ID</tt> 设置的值动态检查 articles 站点。</p>
<p>例如， LJWorld.coms 设置文件中有有个 <tt >SITE_ID</tt> 设置为 <tt >1</tt> ，而 Lawrence.coms 设置文件中有个 <tt >SITE_ID</tt> 设置为 <tt >2</tt> 。如果该视图在 LJWorld.coms 处于激活状态时被调用，那么它将把查找范围局限于站点列表包括 LJWorld.com 在内的文章。</p>


<h4  >将内容与单一站点相关联</h4>
<p>同样，你也可以使用 <tt >外键</tt> 在多对一关系中将一个模型关联到 <tt >Site</tt> 模型。</p>
<p>举例来说，如果某篇文章仅仅能够出现在一个站点上，你可以使用下面这样的模型：</p>
<pre class="code">
from django.db import models
from django.contrib.sites.models import Site

class Article(models.Model):
    headline = models.CharField(max_length=200)
    # ...
    site = models.ForeignKey(Site)
</pre>
<p>这与前一节中介绍的一样有益。</p>


<h4  >从视图钩挂当前站点</h4>
<p>在底层，通过在 Django 视图中使用多站点框架，你可以让视图根据调用站点不同而完成不同的工作，例如：</p>
<pre class="code">
from django.conf import settings

def my_view(request):
    if settings.SITE_ID == 3:
        # Do something.
    else:
        # Do something else.
</pre>
<p>当然，像那样对站点 ID 进行硬编码是比较难看的。 略为简洁的完成方式是查看当前的站点域：</p>
<pre class="code">
from django.conf import settings
from django.contrib.sites.models import Site

def my_view(request):
    current_site = Site.objects.get(id=settings.SITE_ID)
    if current_site.domain == 'foo.com':
        # Do something
    else:
        # Do something else.
</pre>
<p>从 <tt >Site</tt> 对象中获取 <tt >settings.SITE_ID</tt> 值的做法比较常见，因此 <tt >Site</tt> 模型管理器 (<tt >Site.objects</tt> ) 具备一个 <tt >get_current()</tt> 方法。
下面的例子与前一个是等效的：</p>
<pre class="code">
from django.contrib.sites.models import Site

def my_view(request):
    current_site = Site.objects.get_current()
    if current_site.domain == 'foo.com':
        # Do something
    else:
        # Do something else.
</pre>
<p>注意</p>
<p>在这个最后的例子里，你不用导入 <tt >django.conf.settings</tt> 。</p>


<h4  >获取当前域用于呈现</h4>
<p>正如情景二中所解释的那样，对于储存站名和域名的 DRY (Dont Repeat Yourself) 方法（在一个位置储存站名和域名）来说，只需引用当前 <tt >Site</tt> 对象的 <tt >name</tt> 和 <tt >domain</tt> 。例如： 例如：</p>
<pre class="code">
from django.contrib.sites.models import Site
from django.core.mail import send_mail

def register_for_newsletter(request):
    # Check form values, etc., and subscribe the user.
    # ...
    current_site = Site.objects.get_current()
    send_mail('Thanks for subscribing to %s alerts' % current_site.name,
        'Thanks for your subscription. We appreciate it.\n\n-The %s team.' % current_site.name,
        'editor&#64;%s' % current_site.domain,
        [user_email])
    # ...
</pre>
<p>继续我们正在讨论的 LJWorld.com 和 Lawrence.com 例子，在Lawrence.com 该邮件的标题行是“感谢注册 Lawrence.com 提醒信件”。 在 LJWorld.com ，该邮件标题行是“感谢注册 LJWorld.com 提醒信件”。 这种站点关联行为方式对邮件信息主体也同样适用。</p>
<p>完成这项工作的一种更加灵活（但重量级也更大）的方法是使用 Django 的模板系统。 假定 Lawrence.com 和 LJWorld.com 各自拥有不同的模板目录（ <tt >TEMPLATE_DIRS</tt> ），你可将工作轻松地转交给模板系统，如下所示：</p>
<pre class="code">
from django.core.mail import send_mail
from django.template import loader, Context

def register_for_newsletter(request):
    # Check form values, etc., and subscribe the user.
    # ...
    subject = loader.get_template('alerts/subject.txt').render(Context({}))
    message = loader.get_template('alerts/message.txt').render(Context({}))
    send_mail(subject, message, 'do-not-reply&#64;example.com', [user_email])
    # ...
</pre>
<p>本例中，你不得不在 LJWorld.com 和 Lawrence.com 的模板目录中都创建一份 <tt >subject.txt</tt> 和 <tt >message.txt</tt> 模板。 正如之前所说，该方法带来了更大的灵活性，但也带来了更多复杂性。</p>
<p>尽可能多的利用 <tt >Site</tt> 对象是减少不必要的复杂、冗余工作的好办法。</p>



<h3  >当前站点管理器</h3>
<p>如果 <tt >站点</tt> 在你的应用中扮演很重要的角色，请考虑在你的模型中使用方便的 <tt >CurrentSiteManager</tt> 。这是一个模型管理器（见附录B），它会自动过滤使其只包含与当前 <tt >站点</tt> 相关联的对象。 It&#8217;s a model manager (see Chapter 10) that
automatically filters its queries to include only objects associated with the current <tt >Site</tt>
.</p>
<p>通过显示地将 <tt >CurrentSiteManager</tt> 加入模型中以使用它。 For example:</p>
<pre class="code">
from django.db import models
from django.contrib.sites.models import Site
from django.contrib.sites.managers import CurrentSiteManager

class Photo(models.Model):
    photo = models.FileField(upload_to='/home/photos')
    photographer_name = models.CharField(max_length=100)
    pub_date = models.DateField()
    site = models.ForeignKey(Site)
    objects = models.Manager()
    on_site = CurrentSiteManager()
</pre>
<p>通过该模型， <tt >Photo.objects.all()</tt> 将返回数据库中所有的 <tt >Photo</tt> 对象，而 <tt >Photo.on_site.all()</tt> 仅根据 <tt >SITE_ID</tt> 设置返回与当前站点相关联的 <tt >Photo</tt> 对象。</p>
<p>换言之，以下两条语句是等效的：</p>
<pre class="code">
Photo.objects.filter(site=settings.SITE_ID)
Photo.on_site.all()
</pre>
<p><tt >CurrentSiteManager</tt> 是如何知道 <tt >Photo</tt> 的哪个字段是 <tt >Site</tt> 呢？缺省情况下，它会查找一个叫做 <tt >site</tt> 的字段。</p>
<pre class="code">
from django.db import models
from django.contrib.sites.models import Site
from django.contrib.sites.managers import CurrentSiteManager

class Photo(models.Model):
    photo = models.FileField(upload_to='/home/photos')
    photographer_name = models.CharField(max_length=100)
    pub_date = models.DateField()
    publish_on = models.ForeignKey(Site)
    objects = models.Manager()
    on_site = CurrentSiteManager('publish_on')
</pre>
<p>如果试图使用 <tt >CurrentSiteManager</tt> 并传入一个不存在的字段名， Django 将引发一个 <tt >ValueError</tt> 异常。</p>
<p>Note</p>
<p>即便是已经使用了 <tt >CurrentSiteManager</tt> ，你也许还想在模型中拥有一个正常的（非站点相关）的 <tt >管理器</tt> 。正如在附录 B 中所解释的，如果你手动定义了一个管理器，那么 Django 不会为你创建全自动的 <tt >objects = models.Manager()</tt> 管理器。</p>
<p>同样，Django 的特定部分——即 Django 超级管理站点和通用视图——使用的管理器 <em>首先</em> 在模型中定义，因此如果希望超级管理站点能够访问所有对象（而不是仅仅站点特有对象），请于定义 <tt >CurrentSiteManager</tt> 之前在模型中放入 <tt >objects = models.Manager()</tt> 。</p>


<h3  >Django如何使用多站点框架</h3>
<p>尽管并不是必须的，我们还是强烈建议使用多站点框架，因为 Django 在几个地方利用了它。 即使只用 Django 来支持单个网站，你也应该花一点时间用 <tt >domain</tt> 和 <tt >name</tt> 来创建站点对象，并将 <tt >SITE_ID</tt> 设置指向它的 ID 。</p>
<p>以下讲述的是 Django 如何使用多站点框架：</p>
<ul >
<li  ><p>在重定向框架中（见后面的重定向一节），每一个重定向对象都与一个特定站点关联。 当 Django 搜索重定向的时候，它会考虑当前的 <tt >SITE_ID</tt> 。</p>
</li>
</ul>
<ul >
<li  ><p>在注册框架中，每个注释都与特定站点相关。 每个注释被张贴时，其 <tt >site</tt> 被设置为当前的 <tt >SITE_ID</tt> ，而当通过适当的模板标签列出注释时，只有当前站点的注释将会显示。</p>
</li>
</ul>
<ul >
<li  ><p>在 flatpages 框架中 (参见后面的 Flatpages 一节），每个 flatpage 都与特定的站点相关联。 创建 flatpage 时，你都将指定它的 <tt >site</tt> ，而 flatpage 中间件在获取 flatpage 以显示它的过程中，将查看当前的 <tt >SITE_ID</tt> 。</p>
</li>
</ul>
<ul >
<li  ><p>在 syndication 框架中（参阅第 11 章）， <tt >title</tt> 和 <tt >description</tt> 的模板自动访问变量 <tt >{{ site }}</tt> ，它就是代表当前着桨的 <tt >Site</tt> 对象。 而且，如果你不指出一个完全合格的domain的话，提供目录URLS的钩子将会使用当前“Site”对象的domain。</p>
</li>
</ul>
<ul >
<li  ><p>In the authentication framework (see Chapter 14), the <tt >django.contrib.auth.views.login</tt>
view passes the current <tt >Site</tt> name to the template as <tt >{{ site_name }}</tt> and the
current <tt >Site</tt> object as <tt >{{ site }}</tt> .</p>
</li>
</ul>



<h2  >Flatpages - 简单页面</h2>
<p>尽管通常情况下总是建造和运行数据库驱动的 Web 应用，你还是会需要添加一两张一次性的静态页面，例如“关于”页面，或者“隐私策略”页面等等。 可以用像 Apache 这样的标准Web服务器来处理这些静态页面，但却会给应用带来一些额外的复杂性，因为你必须操心怎么配置 Apache，还要设置权限让整个团队可以修改编辑这些文件，而且你还不能使用 Django 模板系统来统一这些页面的风格。</p>
<p>这个问题的解决方案是使用位于 <tt >django.contrib.flatpages</tt> 开发包中的 Django 简单页面（flatpages）应用程序。 该应用让你能够通过 Django 超级管理站点来管理这些一次性的页面，还可以让你使用 Django 模板系统指定它们使用哪个模板。</p>
<p>简单页面以它们的 URL 和站点为键值。 当创建简单页面时，你指定它与哪个URL以及和哪个站点相关联 。（有关站点的更多信息，请查阅《站点》一节） (For more on sites, see the Sites
section.)</p>

<h3  >使用简单页面</h3>
<p>安装简单页面应用程序必须按照下面的步骤：</p>
<ol >
<li  ><p>添加 <tt >'django.contrib.flatpages'</tt> 到 <tt >INSTALLED_APPS</tt> 设置。</p>
</li>
</ol>
<ol  start="2">
<li  ><p>将 <tt >'django.contrib.flatpages.middleware.FlatpageFallbackMiddleware'</tt> 添加到 <tt >MIDDLEWARE_CLASSES</tt> 设置中。</p>
</li>
</ol>
<ol  start="3">
<li  ><p>运行 <tt >manage.py syncdb</tt> 命令在数据库中创建必需的两个表。</p>
</li>
</ol>
<p>简单页面应用程序在数据库中创建两个表： <tt >django_flatpage</tt> 和 <tt >django_flatpage_sites</tt> 。 <tt >django_flatpage</tt> 只是将 URL 映射到标题和一段文本内容。 <tt >django_flatpage_sites</tt> 是一个多对多表，用于关联某个简单页面以及一个或多个站点。</p>
<p>该应用所带来的 <tt >FlatPage</tt> 模型在 <tt >django/contrib/flatpages/models.py</tt> 进行定义，如下所示：</p>
<pre class="code">
from django.db import models
from django.contrib.sites.models import Site

class FlatPage(models.Model):
    url = models.CharField(max_length=100, db_index=True)
    title = models.CharField(max_length=200)
    content = models.TextField(blank=True)
    enable_comments = models.BooleanField()
    template_name = models.CharField(max_length=70, blank=True)
    registration_required = models.BooleanField()
    sites = models.ManyToManyField(Site)
</pre>
<p>让我们逐项看看这些字段的含义：</p>
<ul >
<li  ><p><tt >url</tt> : 该简单页面所处的 URL，不包括域名，但是包含前导斜杠 (例如 <tt >/about/contact/</tt> )。</p>
</li>
</ul>
<ul >
<li  ><p><tt >title</tt> : 简单页面的标题。 框架不对它作任何特殊处理。
由你通过模板来显示它。</p>
</li>
</ul>
<ul >
<li  ><p><tt >content</tt> : 简单页面的内容 (即 HTML 页面)。 The framework
doesn&#8217;t do anything special with this. 由你负责使用模板来显示。</p>
</li>
</ul>
<ul >
<li  ><p><tt >enable_comments</tt> : 是否允许该简单页面使用评论。 The framework doesn&#8217;t do
anything special with this. 你可在模板中检查该值并根据需要显示评论窗体。</p>
</li>
</ul>
<ul >
<li  ><p><tt >template_name</tt> : 用来解析该简单页面的模板名称。 这是一个可选项；如果未指定模板或该模板不存在，系统会退而使用默认模板 <tt >flatpages/default.html</tt> 。</p>
</li>
</ul>
<ul >
<li  ><p><tt >registration_required</tt> : 是否注册用户才能查看此简单页面。
该设置项集成了 Djangos 验证/用户框架，该框架于第十二章详述。</p>
</li>
</ul>
<ul >
<li  ><p><tt >sites</tt> : 该简单页面放置的站点。 该项设置集成了 Django 多站点框架，该框架在本章的《多站点》一节中有所阐述。</p>
</li>
</ul>
<p>你可以通过 Django 超级管理界面或者 Django 数据库 API 来创建简单页面。
要了解更多内容，请查阅《添加、修改和删除简单页面》一节。</p>
<p>一旦简单页面创建完成， <tt >FlatpageFallbackMiddleware</tt> 将完成（剩下）所有的工作。 每当 Django 引发 404 错误，作为终极手段，该中间件将根据所请求的 URL 检查平页面数据库。 确切地说，它将使用所指定的 URL以及 <tt >SITE_ID</tt> 设置对应的站点 ID 查找一个简单页面。</p>
<p>如果找到一个匹配项，它将载入该简单页面的模板（如果没有指定的话，将使用默认模板 <tt >flatpages/default.html</tt> ）。同时，它把一个简单的上下文变量—— <tt >flatpage</tt> （一个简单页面对象）传递给模板。 在模板解析过程中，它实际用的是 <tt >RequestContext</tt> 。 It uses <tt >RequestContext</tt> in
rendering the template.</p>
<p>如果 <tt >FlatpageFallbackMiddleware</tt> 没有找到匹配项，该请求继续如常处理。</p>
<p>Note</p>
<p>该中间件仅在发生 404 （页面未找到）错误时被激活，而不会在 500 （服务器错误）或其他错误响应时被激活。 还要注意的是必须考虑 <tt >MIDDLEWARE_CLASSES</tt> 的顺序问题。
通常，你可以把 <tt >FlatpageFallbackMiddleware</tt> 放在列表最后，因为它是一种终极手段。</p>


<h3  >添加、修改和删除简单页面</h3>
<p>可以用两种方式增加、变更或删除简单页面：</p>

<h4  >通过超级管理界面</h4>
<p>如果已经激活了自动的 Django 超级管理界面，你将会在超级管理页面的首页看到有个 Flatpages 区域。 你可以像编辑系统中其它对象那样编辑简单页面。</p>


<h4  >通过 Python API</h4>
<p>前面已经提到，简单页面表现为 <tt >django/contrib/flatpages/models.py</tt> 中的标准 Django 模型。</p>
<pre class="code">
&gt;&gt;&gt; from django.contrib.flatpages.models import FlatPage
&gt;&gt;&gt; from django.contrib.sites.models import Site
&gt;&gt;&gt; fp = FlatPage.objects.create(
...     url='/about/',
...     title='About',
...     content='&lt;p&gt;About this site...&lt;/p&gt;',
...     enable_comments=False,
...     template_name='',
...     registration_required=False,
... )
&gt;&gt;&gt; fp.sites.add(Site.objects.get(id=1))
&gt;&gt;&gt; FlatPage.objects.get(url='/about/')
&lt;FlatPage: /about/ -- About&gt;
</pre>



<h3  >使用简单页面模板</h3>
<p>缺省情况下，系统使用模板 <tt >flatpages/default.html</tt> 来解析简单页面，但你也可以通过设定 <tt >FlatPage</tt> 对象的 <tt >template_name</tt> 字段来覆盖特定简单页面的模板。</p>
<p>你必须自己创建 <tt >flatpages/default.html</tt> 模板。 只需要在模板目录创建一个 <tt >flatpages</tt> 目录，并把 <tt >default.html</tt> 文件置于其中。</p>
<p>简单页面模板只接受有一个上下文变量—— <tt >flatpage</tt> ，也就是该简单页面对象。</p>
<p>以下是一个 <tt >flatpages/default.html</tt> 模板范例:</p>
<pre class="code">
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;
    &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;{{ flatpage.title }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{ flatpage.content|safe }}
&lt;/body&gt;
&lt;/html&gt;
</pre>
<p>Note that we&#8217;ve used the <tt >safe</tt> template filter to allow <tt >flatpage.content</tt> to include raw
HTML and bypass auto-escaping.</p>



<h2  >重定向</h2>
<p>通过将重定向存储在数据库中并将其视为 Django 模型对象，Django 重定向框架让你能够轻松地管理它们。 比如说，你可以通过重定向框架告诉Django，把任何指向 <tt >/music/</tt> 的请求重定向到 <tt >/sections/arts/music/</tt> 。当你需要在站点中移动一些东西时，这项功能就派上用场了——网站开发者应该穷尽一切办法避免出现坏链接。</p>

<h3  >使用重定向框架</h3>
<p>安装重定向应用程序必须遵循以下步骤：</p>
<ol >
<li  ><p>将 <tt >'django.contrib.redirects'</tt> 添加到 <tt >INSTALLED_APPS</tt> 设置中。</p>
</li>
</ol>
<ol  start="2">
<li  ><p>将 <tt >'django.contrib.redirects.middleware.RedirectFallbackMiddleware'</tt> 添加到 <tt >MIDDLEWARE_CLASSES</tt> 设置中。</p>
</li>
</ol>
<ol  start="3">
<li  ><p>运行 <tt >manage.py syncdb</tt> 命令将所需的表安装到数据库中。</p>
</li>
</ol>
<p><tt >manage.py syncdb</tt> 在数据库中创建了一个 <tt >django_redirect</tt> 表。这是一个简单的查询表，只有 <tt >site_id</tt> 、 <tt >old_path</tt> 和 <tt >new_path</tt> 三个字段。 This is a simple
lookup table with <tt >site_id</tt> , <tt >old_path</tt> , and <tt >new_path</tt> fields.</p>
<p>你可以通过 Django 超级管理界面或者 Django 数据库 API 来创建重定向。
要了解更多信息，请参阅《增加、变更和删除重定向》一节。</p>
<p>一旦创建了重定向， <tt >RedirectFallbackMiddleware</tt> 类将完成所有的工作。
每当 Django 应用引发一个 404 错误，作为终极手段，该中间件将为所请求的 URL 在重定向数据库中进行查找。 确切地说，它将使用给定的 <tt >old_path</tt> 以及 <tt >SITE_ID</tt> 设置对应的站点 ID 查找重定向设置。 （查阅前面的《多站点》一节可了解关于 <tt >SITE_ID</tt> 和多站点框架的更多细节） 然后，它将执行以下两个步骤：</p>
<ul >
<li  ><p>如果找到了匹配项，并且 <tt >new_path</tt> 非空，它将重定向到 <tt >new_path</tt> 。</p>
</li>
</ul>
<ul >
<li  ><p>如果找到了匹配项，但 <tt >new_path</tt> 为空，它将发送一个 410 (Gone) HTTP 头信息以及一个空（无内容）响应。</p>
</li>
</ul>
<ul >
<li  ><p>如果未找到匹配项，该请求将如常处理。</p>
</li>
</ul>
<p>该中间件仅为 404 错误激活，而不会为 500 错误或其他任何状态码的响应所激活。</p>
<p>注意必须考虑 <tt >MIDDLEWARE_CLASSES</tt> 的顺序。 通常，你可以将 <tt >RedirectFallbackMiddleware</tt> 放置在列表的最后，因为它是一种终极手段。</p>
<p>Note</p>
<p>如果同时使用重定向和简单页面回退中间件， 必须考虑先检查其中的哪一个（重定向或简单页面）。 我们建议将简单页面放在重定向之前（因此将简单页面中间件放置在重定向中间件之前），但你可能有不同想法。</p>


<h3  >增加、变更和删除重定向</h3>
<p>你可以两种方式增加、变更和删除重定向：</p>

<h4  >Via the Admin Interface</h4>
<p>如果已经激活了全自动的 Django 超级管理界面，你应该能够在超级管理首页看到重定向区域。 可以像编辑系统中其它对象一样编辑重定向。</p>


<h4  >Via the Python API</h4>
<p><tt >django/contrib/redirects/models.py</tt> 中的一个标准 Django 模型代表了重定向。</p>
<pre class="code">
&gt;&gt;&gt; from django.contrib.redirects.models import Redirect
&gt;&gt;&gt; from django.contrib.sites.models import Site
&gt;&gt;&gt; red = Redirect.objects.create(
...     site=Site.objects.get(id=1),
...     old_path='/music/',
...     new_path='/sections/arts/music/',
... )
&gt;&gt;&gt; Redirect.objects.get(old_path='/music/')
&lt;Redirect: /music/ ---&gt; /sections/arts/music/&gt;
</pre>




<h2  >CSRF 防护</h2>
<p><tt >django.contrib.csrf</tt> 开发包能够防止遭受跨站请求伪造攻击 (CSRF).</p>
<p>CSRF, 又叫进程跳转，是一种网站安全攻击技术。 当某个恶意网站在用户未察觉的情况下将其从一个已经通过身份验证的站点诱骗至一个新的 URL 时，这种攻击就发生了，因此它可以利用用户已经通过身份验证的状态。 开始的时候，要理解这种攻击技术比较困难，因此我们在本节将使用两个例子来说明。</p>

<h3  >一个简单的 CSRF 例子</h3>
<p>假定你已经登录到 <tt >example.com</tt> 的网页邮件账号。</p>
<p>通过在（恶意）网页上用隐藏一个指向 URL <tt >example.com/logout</tt> 的 <tt >&lt;iframe&gt;</tt> ,恶意网站可以强迫你访问该 URL 。因此，如果你登录 <tt >example.com</tt> 的网页邮件账号之后，访问了带有指向 <tt >example.com/logout</tt> 之 <tt >&lt;iframe&gt;</tt> 的恶意站点，访问该恶意页面的动作将使你登出 <tt >example.com</tt> 。 Thus, if you&#8217;re logged in to the
<tt >example.com</tt> webmail account and visit the malicious page that has an <tt >&lt;iframe&gt;</tt> to
<tt >example.com/logout</tt> , the act of visiting the malicious page will log you out from
<tt >example.com</tt> .</p>
<p>Clearly, being logged out of a webmail site against your will is not a terrifying breach of
security, but this same type of exploit can happen to <em>any</em> site that trusts users, such as an
online banking site or an e-commerce site, where the exploit could be used to initiate an order
or payment without the user&#8217;s knowledge.</p>


<h3  >稍微复杂一点的CSRF例子</h3>
<p>在上一个例子中， <tt >example.com</tt> 应该负部分责任，因为它允许通过 HTTP <tt >GET</tt> 方法进行状态变更（即登入和登出）。 如果对服务器的状态变更要求使用 HTTP <tt >POST</tt> 方法，情况就好得多了。
但是，即便是强制要求使用 <tt >POST</tt> 方法进行状态变更操作也易受到 CSRF 攻击。</p>
<p>假设 <tt >example.com</tt> 对登出功能进行了升级，登出 <tt >&lt;form&gt;</tt> 按钮是通过一个指向 URL <tt >example.com/logout</tt> 的 <tt >POST</tt> 动作完成，同时在 <tt >&lt;form&gt;</tt> 中加入了以下隐藏的字段：</p>
<pre class="code">
&lt;input type=&quot;hidden&quot; name=&quot;confirm&quot; value=&quot;true&quot;&gt;
</pre>
<p>这就确保了用简单的 <tt >POST</tt> 到 <tt >example.com/logout</tt> 不会让用户登出；要让用户登出，用户必须通过 <tt >POST</tt> 向 <tt >example.com/logout</tt> 发送请求 <em>并且</em> 发送一个值为 <tt >'true'</tt> 的 <tt >POST</tt> 变量。 <em>and</em>
send the <tt >confirm</tt> <tt >POST</tt> variable with a value of <tt >'true'</tt> .</p>
<p>尽管增加了额外的安全机制，这种设计仍然会遭到 CSRF 的攻击——恶意页面仅需一点点改进而已。 攻击者可以针对你的站点设计整个表单，并将其藏身于一个不可见的 <tt >&lt;iframe&gt;</tt> 中，然后使用 Javascript 自动提交该表单。</p>


<h3  >防止 CSRF</h3>
<p>那么，是否可以让站点免受这种攻击呢？ 第一步，首先确保所有 <tt >GET</tt> 方法没有副作用。 这样以来，如果某个恶意站点将你的页面包含为 <tt >&lt;iframe&gt;</tt> ，它将不会产生负面效果。</p>
<p>该技术没有考虑 <tt >POST</tt> 请求。 第二步就是给所有 <tt >POST</tt> 的 <tt >&lt;form&gt;</tt> 一个 隐藏字段，它的值是保密的并根据用户进程的 ID 生成。 这样，从服务器端访问表单时，可以检查该保密的字段，不吻合时可以引发一个错误。 Then, when processing
the form on the server side, check for that secret field and raise an error if it doesn&#8217;t
validate.</p>
<p>这正是 Django CSRF 防护层完成的工作，正如下面的小节所介绍的。</p>

<h4  >使用CSRF中间件</h4>
<p><tt >django.contrib.csrf</tt> 开发包只有一个模块： <tt >middleware.py</tt> 。该模块包含了一个 Django 中间件类—— <tt >CsrfMiddleware</tt> ，该类实现了 CSRF 防护功能。</p>
<p>在设置文件中将 <tt >'django.contrib.csrf.middleware.CsrfMiddleware'</tt> 添加到 <tt >MIDDLEWARE_CLASSES</tt> 设置中可激活 CSRF 防护。 该中间件必须在 <tt >SessionMiddleware</tt> <em>之后</em> 执行，因此在列表中 <tt >CsrfMiddleware</tt> 必须出现在 <tt >SessionMiddleware</tt>
<em>之前</em> （因为响应中间件是自后向前执行的）。
同时，它也必须在响应被压缩或解压之前对响应结果进行处理，因此 <tt >CsrfMiddleware</tt> 必须在 <tt >GZipMiddleware</tt> 之后执行。 一旦将它添加到 <tt >MIDDLEWARE_CLASSES</tt> 设置中，你就完成了工作。</p>
<p>如果感兴趣的话，下面是 <tt >CsrfMiddleware</tt> 的工作模式。 它完成以下两项工作：</p>
<ol >
<li  ><p>它修改当前处理的请求，向所有的 <tt >POST</tt> 表单增添一个隐藏的表单字段，使用名称是 <tt >csrfmiddlewaretoken</tt> ，值为当前会话 ID 加上一个密钥的散列值。 如果未设置会话 ID ，该中间件将 <em>不会</em> 修改响应结果，因此对于未使用会话的请求来说性能损失是可以忽略的。</p>
</li>
</ol>
<ol  start="2">
<li  ><p>对于所有含会话 cookie 集合的传入 <tt >POST</tt> 请求，它将检查是否存在 <tt >csrfmiddlewaretoken</tt> 及其是否正确。 如果不是的话，用户将会收到一个 403 <tt >HTTP</tt> 错误。 403 错误页面的内容是消息： 检测到跨站伪装请求。</p>
</li>
</ol>
<p>该步骤确保只有源自你的站点的表单才能将数据 POST 回来。</p>
<p>该中间件特意只针对 HTTP <tt >POST</tt> 请求（以及对应的 POST 表单）。 如我们所解释的，永远不应该因为使用了 <tt >GET</tt> 请求而产生负面效应，你必须自己来确保这一点。</p>
<p>未使用会话 cookie 的 <tt >POST</tt> 请求无法受到保护，但它们也不 <em>需要</em> 受到保护，因为恶意网站可用任意方法来制造这种请求。</p>
<p>为了避免转换非 HTML 请求，中间件在编辑响应结果之前对它的 <tt >Content-Type</tt> 头标进行检查。 只有标记为 <tt >text/html</tt> 或 <tt >application/xml+xhtml</tt> 的页面才会被修改。</p>


<h4  >CSRF中间件的局限性</h4>
<p><tt >CsrfMiddleware</tt> 的运行需要 Django 的会话框架。 （参阅第 12 章了解更多关于会话的内容）如果你使用了自定义会话或者身份验证框架手动管理会话 cookies，该中间件将帮不上你的忙。</p>
<p>如果你的应用程序以某种非常规的方法创建 HTML 页面（例如： 在 Javascript 的 <tt >document.write</tt> 语句中发送 HTML 片段），你可能会绕开了向表单添加隐藏字段的过滤器。
在此情况下，表单提交永远无法成功。</p>
<p>想了解更多关于 CSRF 的信息和例子的话，可以访问 <a  href="http://en.wikipedia.org/wiki/CSRF">http://en.wikipedia.org/wiki/CSRF</a> 。</p>




<h2  >人性化数据</h2>
<p>The package <tt >django.contrib.humanize</tt> holds a set of Django template filters useful for
adding a human touch to data. To activate these filters, add <tt >'django.contrib.humanize'</tt> to
your <tt >INSTALLED_APPS</tt> . Once you&#8217;ve done that, use <tt >{% load humanize %}</tt> in a template, and
you&#8217;ll have access to the filters described in the following sections.</p>

<h3  >apnumber</h3>
<p>对于 1 到 9 的数字，该过滤器返回了数字的拼写形式。 否则，它将返回数字。 这遵循的是美联社风格。</p>
<p>举例：</p>
<ul >
<li  ><p>1 变成 one 。</p>
</li>
</ul>
<ul >
<li  ><p>2 变成 two 。</p>
</li>
</ul>
<ul >
<li  ><p>10 变成 10 。</p>
</li>
</ul>
<p>你可以传入一个整数或者表示整数的字符串。</p>


<h3  >intcomma</h3>
<p>该过滤器将整数转换为每三个数字用一个逗号分隔的字符串。</p>
<p>Examples:</p>
<ul >
<li  ><p>4500 变成 4,500 。</p>
</li>
</ul>
<ul >
<li  ><p>45000 变成 45,000 。</p>
</li>
</ul>
<ul >
<li  ><p>450000 变成 450,000 。</p>
</li>
</ul>
<ul >
<li  ><p>4500000 变成 4,500,000 。</p>
</li>
</ul>
<p>You can pass in either an integer or a string representation of an integer.</p>


<h3  >intword</h3>
<p>该过滤器将一个很大的整数转换成友好的文本表示方式。 它对于超过一百万的数字最好用。</p>
<p>Examples:</p>
<ul >
<li  ><p>1000000 变成 1.0 million 。</p>
</li>
</ul>
<ul >
<li  ><p>1200000 变成 1.2 million 。</p>
</li>
</ul>
<ul >
<li  ><p>1200000000 变成 1.2 billion 。</p>
</li>
</ul>
<p>最大支持不超过一千的五次方（1,000,000,000,000,000）。</p>
<p>You can pass in either an integer or a string representation of an integer.</p>


<h3  >ordinal</h3>
<p>该过滤器将整数转换为序数词的字符串形式。</p>
<p>Examples:</p>
<ul >
<li  ><p>1 变成 1st 。</p>
</li>
</ul>
<ul >
<li  ><p>2 变成 2nd 。</p>
</li>
</ul>
<ul >
<li  ><p>3 变成 3rd 。</p>
</li>
</ul>
<ul >
<li  ><p>254 becomes 254th.</p>
</li>
</ul>
<p>You can pass in either an integer or a string representation of an integer.</p>



<h2  >标记过滤器</h2>
<p>The package <tt >django.contrib.markup</tt> includes a handful of Django template filters, each of
which implements a common markup languages:</p>
<ul >
<li  ><p><tt >textile</tt> : 实现了 Textile (<a  href="http://en.wikipedia.org/wiki/Textile_%28markup_language%29">http://en.wikipedia.org/wiki/Textile_%28markup_language%29</a>)</p>
</li>
</ul>
<ul >
<li  ><p><tt >markdown</tt> : 实现了 Markdown (<a  href="http://en.wikipedia.org/wiki/Markdown">http://en.wikipedia.org/wiki/Markdown</a>)</p>
</li>
</ul>
<ul >
<li  ><p><tt >restructuredtext</tt> : 实现了 ReStructured Text (<a  href="http://en.wikipedia.org/wiki/ReStructuredText">http://en.wikipedia.org/wiki/ReStructuredText</a>)</p>
</li>
</ul>
<p>每种情形下，过滤器都期望字符串形式的格式化标记，并返回表示标记文本的字符串。 例如：</p>
<pre class="code">
{% load markup %}
{{ object.content|textile }}
</pre>
<p>要激活这些过滤器，仅需将 <tt >'django.contrib.markup'</tt> 添加到 <tt >INSTALLED_APPS</tt> 设置中。
一旦完成了该项工作，在模板中使用 <tt >{% load markup %}</tt> 就能使用这些过滤器。 要想掌握更多信息的话，可阅读 <tt >django/contrib/markup/templatetags/markup.py.</tt> 内的源代码。</p>


<h2  >下一章</h2>
<p>这些继承框架（CSRF、身份验证系统等等）通过提供 <em>中间件</em> 来实现其奇妙的功能。 在<a href="chapter17.html">下一章 </a>，我们将介绍Django的中间件并解释怎样写出自己的中间件</p>
<p>under the <a  href="/license/">GNU Free Document License</a>. Hosting graciously provided by</p>



    
    
  



        
	<a href="chapter15.html">| 上一章</a> |
    	<a href="index.html">目  录</a> |
    	<a href="chapter17.html">下一章 </a> |










<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->