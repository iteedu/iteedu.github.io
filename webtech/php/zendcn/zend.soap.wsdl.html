<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->



<div class="sect1" title="49.3. WSDL Accessor">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.soap.wsdl"></a>49.3. WSDL Accessor</h2></div></div></div>
<div class="note" title="注意"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top">
<p>
            <code class="classname">Zend_Soap_Wsdl</code> class is used by Zend_Soap_Server component internally to operate with WSDL
            documents. Nevertheless, you could also use functionality provided by this class for your own needs.
            The Zend_Soap_Wsdl package contains both a parser and a builder of WSDL documents.
        </p>
<p>
            If you don't plan to do this, you can skip this documentation section.
        </p>
</td></tr>
</table></div>
<div class="sect2" title="49.3.1. Zend_Soap_Wsdl constructor">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.constructor"></a>49.3.1. Zend_Soap_Wsdl constructor</h3></div></div></div>
<p>
            <code class="classname">Zend_Soap_Wsdl</code> constructor takes three parameters:
            </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
<code>$name</code> - name of the Web Service being described.</li>
<li class="listitem">
                        <code>$uri</code> - URI where the WSDL will be available
                        (could also be a reference to the file in the filesystem.)
                    </li>
<li class="listitem">
                        <code>$strategy</code> - optional flag used to identify the strategy for complex types (objects)
                        detection. This was a boolean <code>$extractComplexTypes</code> before version 1.7 and can
                        still be set as a boolean for backwards compatibility. By default the 1.6 detection behaviour
                        is set. To read more on complex type detection strategies go to the section:
                        <a class="xref" href="zend.soap.wsdl.html#zend.soap.wsdl.types.add_complex" title="49.3.10.2. Adding complex type information">第 49.3.10.2 节 “Adding complex type information”</a>.
                    </li>
</ol></div>
<p>
        </p>
</div>
<div class="sect2" title="49.3.2. addMessage() method">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.addmessage"></a>49.3.2. addMessage() method</h3></div></div></div>
<p>
            <code>addMessage($name, $parts)</code> method adds new message description to the WSDL document
            (/definitions/message element).
        </p>
<p>
            Each message correspond to methods in terms of <code class="classname">Zend_Soap_Server</code> and
            <code class="classname">Zend_Soap_Client</code> functionality.
        </p>
<p>
           <code>$name</code> parameter represents message name.
        </p>
<p>
           <code>$parts</code> parameter is an array of message parts which describe SOAP call parameters.
           It's an associative array: 'part name' (SOAP call parameter name) =&gt; 'part type'.
        </p>
<p>
            Type mapping management is performed using <code>addTypes()</code>, <code>addTypes()</code> and
            <code>addComplexType()</code> methods (see below).
        </p>
<div class="note" title="注意"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top">
<p>
                Messages parts can use either 'element' or 'type' attribute for typing
                (see http://www.w3.org/TR/wsdl#_messages).
            </p>
<p>
                'element' attribute must refer to a corresponding element of data type definition. 'type' attribute refers
                to a corresponding complexType entry.
            </p>
<p>
                All standard XSD types have both 'element' and 'complexType' definitions
                (see http://schemas.xmlsoap.org/soap/encoding/).
            </p>
<p>
                All non-standard types, which may be added using <code class="classname">Zend_Soap_Wsdl::addComplexType()</code> method, are
                described using 'complexType' node of '/definitions/types/schema/' section of WSDL document.
            </p>
<p>
                So <code>addMessage()</code> method always uses 'type' attribute to describe types.
            </p>
</td></tr>
</table></div>
</div>
<div class="sect2" title="49.3.3. addPortType() method">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.add_port_type"></a>49.3.3. addPortType() method</h3></div></div></div>
<p>
            <code>addPortType($name)</code> method adds new port type to the WSDL document
            (/definitions/portType) with the specified port type name.
        </p>
<p>
            It joins a set of Web Service methods defined in terms of Zend_Soap_Server implementation.
        </p>
<p>
            See http://www.w3.org/TR/wsdl#_porttypes for the details.
        </p>
</div>
<div class="sect2" title="49.3.4. addPortOperation() method">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.add_port_operation"></a>49.3.4. addPortOperation() method</h3></div></div></div>
<p>
            <code>addPortOperation($portType, $name, $input = false, $output = false, $fault = false)</code> method
            adds new port operation to the specified port type of the WSDL document
            (/definitions/portType/operation).
        </p>
<p>
            Each port operation corresponds to a class method (if Web Service is based on a class) or function
            (if Web Service is based on a set of methods) in terms of Zend_Soap_Server implementation.
        </p>
<p>
            It also adds corresponding port operation messages depending on specified
            <code>$input</code>, <code>$output</code> and <code>$fault</code> parameters.

            </p>
<div class="note" title="注意"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top">
<p>
                    Zend_Soap_Server component generates two messages for each port operation while describing service based on
                    <code class="classname">Zend_Soap_Server</code> class:
                    </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                                input message with name <code>$methodName . 'Request'</code>.
                            </p></li>
<li class="listitem"><p>
                                output message with name <code>$methodName . 'Response'</code>.
                            </p></li>
</ul></div>
<p>
                </p>
</td></tr>
</table></div>
<p>
        </p>
<p>
            See http://www.w3.org/TR/wsdl#_request-response for the details.
        </p>
</div>
<div class="sect2" title="49.3.5. addBinding() method">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.add_binding"></a>49.3.5. addBinding() method</h3></div></div></div>
<p>
            <code>addBinding($name, $portType)</code> method adds new binding to the WSDL document (/definitions/binding).
        </p>
<p>
            'binding' WSDL document node defines message format and protocol details for operations and messages
            defined by a particular portType (see http://www.w3.org/TR/wsdl#_bindings).
        </p>
<p>
            The method creates binding node and returns it. Then it may be used to fill with actual data.
        </p>
<p>
            Zend_Soap_Server implementation uses <code>$serviceName . 'Binding'</code> name for 'binding' element of WSDL document.
        </p>
</div>
<div class="sect2" title="49.3.6. addBindingOperation() method">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.add_binding_operation"></a>49.3.6. addBindingOperation() method</h3></div></div></div>
<p>
            <code>addBindingOperation($binding, $name, $input = false, $output = false, $fault = false)</code> method adds
            an operation to a binding element (/definitions/binding/operation) with the specified name.
        </p>
<p>
            It takes <code>XML_Tree_Node</code> object returned by <code>addBinding()</code> as an input
            (<code>$binding</code> parameter) to add 'operation' element with input/output/false entries depending on
            specified parameters
        </p>
<p>
            Zend_Soap_Server implementation adds corresponding binding entry for each Web Service method with input and output
            entries defining 'soap:body' element as
            '&lt;soap:body use="encoded" encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"/&gt;
        </p>
<p>
            See http://www.w3.org/TR/wsdl#_bindings for the details.
        </p>
</div>
<div class="sect2" title="49.3.7. addSoapBinding() method">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.add_soap_binding"></a>49.3.7. addSoapBinding() method</h3></div></div></div>
<p>
            <code>addSoapBinding($binding, $style = 'document', $transport = 'http://schemas.xmlsoap.org/soap/http')</code>
            method adds SOAP binding ('soap:binding') entry to the binding element (which is already linked to some port type)
            with the specified style and transport (Zend_Soap_Server implementation uses RPC style over HTTP).
        </p>
<p>
            '/definitions/binding/soap:binding' element is used to signify that the binding is bound to the SOAP protocol format.
        </p>
<p>
            See http://www.w3.org/TR/wsdl#_bindings for the details.
        </p>
</div>
<div class="sect2" title="49.3.8. addSoapOperation() method">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.add_soap_operation"></a>49.3.8. addSoapOperation() method</h3></div></div></div>
<p>
            <code>addSoapOperation($binding, $soap_action)</code>
            method adds SOAP operation ('soap:operation') entry to the binding element with the specified action.
            'style' attribute of the 'soap:operation' element is not used since programming model (RPC-oriented or document-oriented)
            may be using <code>addSoapBinding()</code> method
        </p>
<p>
            'soapAction' attribute of '/definitions/binding/soap:operation' element specifies the value of the SOAPAction header
            for this operation. This attribute is required for SOAP over HTTP and <span class="emphasis"><em>must not</em></span> be
            specified for other transports.
        </p>
<p>
            Zend_Soap_Server implementation uses <code>$serviceUri . '#' . $methodName</code> for SOAP operation action name.
        </p>
<p>
            See http://www.w3.org/TR/wsdl#_soap:operation for the details.
        </p>
</div>
<div class="sect2" title="49.3.9. addService() method">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.add_service"></a>49.3.9. addService() method</h3></div></div></div>
<p>
            <code>addService($name, $port_name, $binding, $location)</code> method adds '/definitions/service' element to
            the WSDL document with the specified Wed Service name, port name, binding, and location.
        </p>
<p>
            WSDL 1.1 allows to have several port types (sets of operations) per service. This ability is not used by
            Zend_Soap_Server implementation and not supported by <code class="classname">Zend_Soap_Wsdl</code> class.
        </p>
<p>
            Zend_Soap_Server implementation uses:
            </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                        <code>$name . 'Service'</code> as a Web Service name,
                    </p></li>
<li class="listitem"><p>
                        <code>$name . 'Port'</code> as a port type name,
                    </p></li>
<li class="listitem"><p>
                        <code>'tns:' . $name . 'Binding'</code>
                            <sup>[<a name="id4982369" href="#ftn.id4982369" class="footnote">19</a>]</sup>
                            as binding name,
                    </p></li>
<li class="listitem"><p>
                        script URI<sup>[<a name="id4982393" href="#ftn.id4982393" class="footnote">20</a>]</sup>
                        as a service URI for Web Service definition using classes.
                    </p></li>
</ul></div>
<p>
            where <code>$name</code> is a class name for the Web Service definition mode using class and
            script name for  the Web Service definition mode using set of functions.
        </p>
<p>
            See http://www.w3.org/TR/wsdl#_services for the details.
        </p>
</div>
<div class="sect2" title="49.3.10. Type mapping">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.types"></a>49.3.10. Type mapping</h3></div></div></div>
<p>
            Zend_Soap WSDL accessor implementation uses the following type mapping between PHP and SOAP types:

            </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>PHP strings &lt;-&gt; <code>xsd:string</code>.</p></li>
<li class="listitem"><p>PHP integers &lt;-&gt; <code>xsd:int</code>.</p></li>
<li class="listitem"><p>PHP floats and doubles &lt;-&gt; <code>xsd:float</code>.</p></li>
<li class="listitem"><p>PHP booleans &lt;-&gt; <code>xsd:boolean</code>.</p></li>
<li class="listitem"><p>PHP arrays &lt;-&gt; <code>soap-enc:Array</code>.</p></li>
<li class="listitem"><p>PHP object &lt;-&gt; <code>xsd:struct</code>.</p></li>
<li class="listitem"><p>
                        PHP class &lt;-&gt; based on complex type strategy (See: <a class="xref" href="zend.soap.wsdl.html#zend.soap.wsdl.types.add_complex" title="49.3.10.2. Adding complex type information">第 49.3.10.2 节 “Adding complex type information”</a>)
                        <sup>[<a name="id4982518" href="#ftn.id4982518" class="footnote">21</a>]</sup>.
                    </p></li>
<li class="listitem"><p>PHP void &lt;-&gt; empty type.</p></li>
<li class="listitem"><p>If type is not matched to any of these types by some reason, then <code>xsd:anyType</code> is used.</p></li>
</ul></div>
<p>

            Where <code>xsd:</code> is "http://www.w3.org/2001/XMLSchema" namespace,
            <code>soap-enc:</code> is a "http://schemas.xmlsoap.org/soap/encoding/" namespace,
            <code>tns:</code> is a "target namespace" for a service.
        </p>
<div class="sect3" title="49.3.10.1. Retrieving type information">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.soap.wsdl.types.retrieve"></a>49.3.10.1. Retrieving type information</h4></div></div></div>
<p>
                <code>getType($type)</code> method may be used to get mapping for a specified PHP type:

            </p>
<pre class="code">
...
$wsdl = new Zend_Soap_Wsdl('My_Web_Service', $myWebServiceUri);

...
$soapIntType = $wsdl-&gt;getType('int');

...
class MyClass {
    ...
}
...
$soapMyClassType = $wsdl-&gt;getType('MyClass');
</pre>
<p>
            </p>
</div>
<div class="sect3" title="49.3.10.2. Adding complex type information">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.soap.wsdl.types.add_complex"></a>49.3.10.2. Adding complex type information</h4></div></div></div>
<p>
                <code>addComplexType($type)</code> method is used to add complex types (PHP classes) to a WSDL document.
            </p>
<p>
                It's automatically used by <code>getType()</code> method to add corresponding complex types
                of method parameters or return types.
            </p>
<p>
                Its detection and building algorithm is based on the currently
                active detection strategy for complex types. You can set the detection strategy either by
                specifying the class name as string or instance of a <code class="classname">Zend_Soap_Wsdl_Strategy_Interface</code>
                implementation as the third parameter of the constructor or using the <code>setComplexTypeStrategy($strategy)</code>
                function of Zend_Soap_Wsdl. The following detection strategies currently exist:
            </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>Class <code class="classname">Zend_Soap_Wsdl_Strategy_DefaultComplexType</code>: Enabled by default (when no
                    third constructor parameter is set). Iterates over the public attributes of a class type and
                    registers them as subtypes of the complex object type.</p></li>
<li class="listitem"><p>Class <code class="classname">Zend_Soap_Wsdl_Strategy_AnyType</code>: Casts all complex types into the
                    simple XSD type xsd:anyType. Be careful this shortcut for complex type detection can probably only
                    be handled successfully by weakly typed languages such as PHP.
                    </p></li>
<li class="listitem"><p>Class <code class="classname">Zend_Soap_Wsdl_Strategy_ArrayOfTypeSequence</code>: This strategy allows
                    to specify return parameters of the type: <code>int[]</code> or <code>string[]</code>. It can only
                    handle simple PHP types such as int, string, boolean, float and so on, but allows to specify
                    nested arrays of arrays of type.</p></li>
<li class="listitem"><p>Class <code class="classname">Zend_Soap_Wsdl_Strategy_ArrayOfTypeComplex</code>: This strategy allows
                    to detect very complex arrays of objects. Objects types are detected based on the
                    <code class="classname">Zend_Soap_Wsdl_Strategy_DefaultComplexType</code> and an array is wrapped
                    around that definition.</p></li>
<li class="listitem"><p>Class <code class="classname">Zend_Soap_Wsdl_Strategy_Composite</code>: This strategy can
                    combine all strategies by connecting PHP Complex types (Classnames) to the desired strategy
                    via the <code>connectTypeToStrategy($type, $strategy)</code> method. A complete typemap can be
                    given to the constructor as an array with <code>$type</code> -&gt; <code>$strategy</code> pairs.
                    The second parameter specifies the default strategy that will be used if an unknown type is
                    requested for adding. This parameter defaults to the <code class="classname">Zend_Soap_Wsdl_Strategy_DefaultComplexType</code>
                    strategy.</p></li>
</ul></div>
<p>
                <code>addComplexType()</code> method creates '/definitions/types/xsd:schema/xsd:complexType' element for
                each described complex type with name of the specified PHP class.
            </p>
<p>
                Class property <span class="emphasis"><em>MUST</em></span> have docblock section with the described PHP type to have property
                included into WSDL description.
            </p>
<p>
                <code>addComplexType()</code> checks if type is already described within types section of the WSDL document.
            </p>
<p>
                It prevents duplications if this method is called two or more times and recursion in the types definition
                section.
            </p>
<p>
                See http://www.w3.org/TR/wsdl#_types for the details.
            </p>
</div>
</div>
<div class="sect2" title="49.3.11. addDocumentation() method">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.add_documentation"></a>49.3.11. addDocumentation() method</h3></div></div></div>
<p>
            <code>addDocumentation($input_node, $documentation)</code> method adds human readable documentation using
            optional 'wsdl:document' element.
        </p>
<p>
            '/definitions/binding/soap:binding' element is used to signify that the binding is bound to the SOAP protocol format.
        </p>
<p>
            See http://www.w3.org/TR/wsdl#_documentation for the details.
        </p>
</div>
<div class="sect2" title="49.3.12. Get finalized WSDL document">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.retrieve"></a>49.3.12. Get finalized WSDL document</h3></div></div></div>
<p>
            <code>toXML()</code>, <code>toDomDocument()</code> and <code>dump($filename = false)</code> methods may be used to get
            WSDL document as an XML, DOM structure or a file.
        </p>
</div>
<div class="sect2" title="49.3.13. Parsing WSDL documents">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.soap.wsdl.parser"></a>49.3.13. Parsing WSDL documents</h3></div></div></div>
<p>
            Zend_Soap_Wsdl also contains a parser for WSDL documents that has its main application in unit-testing and code-generation
            for SOAP Webservices (Client and Server). The following example will show how the Parser can be used:
        </p>
<pre class="code">
// Load WSDL into DOMDocument
$dom = new DOMDocument();
$dom-&gt;loadXML($wsdlString);

// Create parser
$parser = Zend_Soap_Wsdl_Parser::factory($dom);
$result = $parser-&gt;parse();

// Webservice Name
echo $result-&gt;getName();

// Access Ports and inner elements
foreach($result-&gt;ports AS $port) {
    echo $port-&gt;getName();
    foreach($port-&gt;bindings AS $binding) {
        echo $binding-&gt;getName();

        foreach($binding-&gt;operations AS $operation) {
            echo $operation-&gt;getName();
            echo $operation-&gt;inputMessage-&gt;getName();
            echo $operation-&gt;outputMessage-&gt;getName();
        }
    }
}
// You can access bindings, messages and operations
// and other elements directly too
foreach($result-&gt;operations AS $operation) {
    // do stuff
}
foreach($result-&gt;bindings AS $binding {
    // do stuff
}
foreach($result-&gt;messages AS $message) {
    // do stuff
}
foreach($result-&gt;services AS $service) {
    // do stuff
}
foreach($result-&gt;types AS $type) {
    // do stuff
}
</pre>
<p>All elements implement the interface <code class="classname">Zend_Soap_Wsdl_Element_Interface</code>
        that proxies a <code>getName()</code> and a <code>getDocumentation()</code> function with the
        unique identifier of the element and its documentation respectively. All the elements have
        public properties that describe its state in more detail and also contain their nested
        dependencies for easy iteratable access.</p>
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id4982369" href="#id4982369" class="para">19</a>] </sup>
                                    <code>'tns:' namespace</code> is defined as script URI
                                    (<code>'http://'  .$_SERVER['HTTP_HOST'] . $_SERVER['SCRIPT_NAME']</code>).
                                </p></div>
<div class="footnote"><p><sup>[<a name="ftn.id4982393" href="#id4982393" class="para">20</a>] </sup><code>'http://'  .$_SERVER['HTTP_HOST'] . $_SERVER['SCRIPT_NAME']</code></p></div>
<div class="footnote"><p><sup>[<a name="ftn.id4982518" href="#id4982518" class="para">21</a>] </sup>
                                By default <code class="classname">Zend_Soap_Wsdl</code> will be created with the <code class="classname">Zend_Soap_Wsdl_Strategy_DefaultComplexType</code>
                                class as detection algorithm for complex types. The first parameter of the AutoDiscover constructor takes
                                any complex type strategy implementing <code class="classname">Zend_Soap_Wsdl_Strategy_Interface</code> or a string with the name
                                of the class. For backwards compatibility with <code>$extractComplexType</code> boolean variables are parsed
                                the following way: If true, <code class="classname">Zend_Soap_Wsdl_Strategy_DefaultComplexType</code>, if false
                                <code class="classname">Zend_Soap_Wsdl_Strategy_AnyType</code>.
                            </p></div>
</div>
</div>
<div class="revinfo"></div>


<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->