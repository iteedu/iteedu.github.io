<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->



<div class="sect1" title="62.2. Zend_XmlRpc_Client">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.xmlrpc.client"></a>62.2. Zend_XmlRpc_Client</h2></div></div></div>
<div class="sect2" title="62.2.1. 介绍">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.introduction"></a>62.2.1. 介绍</h3></div></div></div>
<p>
            Zend Framework 通过 <code>Zend_XmlRpc_Client</code> 作为客户端提供了调用远程
            XML-RPC 服务的功能。主要功能包括在 PHP 和 XML-RPC 之间进行类型的自动转换，
            服务代理对象（a server proxy object），和访问服务器的自省功能
            （introspection capabilities）。
        </p>
</div>
<div class="sect2" title="62.2.2. 方法调用">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.method-calls"></a>62.2.2. 方法调用</h3></div></div></div>
<p>
            <code>Zend_XmlRpc_Client</code> 的构造函数接受 XML-RPC 服务器端 URL
            地址作为第一个参数。返回新的实例可以用来调用这个服务器端任意数量的远程方法。
        </p>
<p>
            使用 XML-RPC 客户端调用远程方法，需要实例化它并且使用 <code>call()</code>
            实力方法。下面的代码演示了调用 Zend Framework 网站上的 XML-RPC 服务。
            你可以使用它测试和学习 <code>Zend_XmlRpc</code> 组件。
        </p>
<div class="example">
<a name="zend.xmlrpc.client.method-calls.example-1"></a><p class="title"><b>例 62.1. XML-RPC 方法调用</b></p>
<div class="example-contents"><pre class="code">
require_once 'Zend/XmlRpc/Client.html';

$client = new Zend_XmlRpc_Client('http://framework.zend.com/xmlrpc');

echo $client-&gt;call('test.sayHello');

// hello

            </pre></div>
</div>
<br class="example-break"><p>
            从远程调用返回的 XML-RPC 值将会自动编排和转换为等价的 PHP 原始类型。
            在上面的例子中，一个 PHP <code>string</code> 会返回并即刻可以使用。
        </p>
<p>
            <code>call()</code> 方法接受远程调用的名字作为第一个参数。如果远程调用需要其他参数，
            可以通过 <code>call()</code> 的第二个可选参数使用 <code>array</code>
            的形式传递到远程方法。
        </p>
<div class="example">
<a name="zend.xmlrpc.client.method-calls.example-2"></a><p class="title"><b>例 62.2. XML-RPC 带参数的方法调用</b></p>
<div class="example-contents"><pre class="code">
require_once 'Zend/XmlRpc/Client.html';

$client = new Zend_XmlRpc_Client('http://framework.zend.com/xmlrpc');

$arg1 = 1.1;
$arg2 = 'foo';

$result = $client-&gt;call('test.sayHello', array($arg1, $arg2));

// $result is a native PHP type

            </pre></div>
</div>
<br class="example-break"><p>
            如果远程方法不需要任何参数，这个可选参数可以留空或者传递一个空的 <code>array()</code>
            过去。远程方法的参数数组可以包含原始的 PHP 类型，<code>Zend_XmlRpc_Value</code>
            对象，或者两种的混合。
        </p>
<p>
            <code>call()</code> 方法会自动转换 XML-PRC 响应并返回等价的 PHP 原始类型。
            返回值的 <code>Zend_XmlRpc_Response</code> 对象也可以在调用之后使用
            <code>getLastResponse()</code> 方法获得。
        </p>
</div>
<div class="sect2" title="62.2.3. 类型及转换">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.value.parameters"></a>62.2.3. 类型及转换</h3></div></div></div>
<p>
            一些远程方法调用时需要参数。它们作为数组传递到 <code>Zend_XmlRpc_Client</code>
            的 <code>call()</code> 方法的第二个参数。每个参数，不论是原始的 PHP 类型，
            还是一个对象表示的特定的 XML-RPC 类型（一个 <code>Zend_XmlRpc_Value</code>
            对象）都会自动转换。
        </p>
<div class="sect3" title="62.2.3.1. PHP 原始类型作为参数">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.value.parameters.html-native"></a>62.2.3.1. PHP 原始类型作为参数</h4></div></div></div>
<p>
                原始 PHP 变量如 <code>string</code>，<code>integer</code>，
                <code>float</code>，<code>boolean</code>，<code>array</code> 或者
                <code>object</code> 都可以作为参数传递到 <code>call()</code>。
                在这种情况下，每个 PHP 原始类型将会自动检测和转换到一个 XML-RPC 类型，
                如下表所示：
            </p>
<div class="table">
<a name="zend.xmlrpc.value.parameters.html-native.table-1"></a><p class="title"><b>表 62.1. PHP 与 XML-RPC 的类型转换</b></p>
<div class="table-contents"><table summary="PHP 与 XML-RPC 的类型转换" border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>PHP 原始类型</th>
<th>XML-RPC 类型</th>
</tr></thead>
<tbody>
<tr>
<td>integer</td>
<td>int</td>
</tr>
<tr>
<td>double</td>
<td>double</td>
</tr>
<tr>
<td>boolean</td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>string</td>
</tr>
<tr>
<td>array</td>
<td>array</td>
</tr>
<tr>
<td>associative array</td>
<td>struct</td>
</tr>
<tr>
<td>object</td>
<td>array</td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="note" title="一个空的数组会如何转换？"><table border="0" summary="Note: 一个空的数组会如何转换？">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">一个空的数组会如何转换？</th>
</tr>
<tr><td align="left" valign="top">
<p>
                    传递空数组到 XML-RPC 方法，由于它既可表示为一个数组也可表示为一个结构，
                    所以会产生问题。<code>Zend_XmlRpc_Client</code> 会监测这种情况并向服务器进行一个
                    <code>system.methodSignature</code> 请求来决定实际将要转换到的 XML-RPC 类型。
                </p>
<p>
                    不过，这样做本身就可能导致问题出现。首先，服务器不支持 <code>system.methodSignature</code>
                    将会产生一个失败请求，同时 <code>Zend_XmlRpc_Client</code>
                    会强制转换这个值为 XML-RPC 数组类型。此外，这意味着任何数组参数都可能导致对远端服务器的一次额外请求。
                </p>
<p>
                    可以在 XML-RPC 调用前调用 <code>setSkipSystemLookup()</code>
                    方法，以便完全屏蔽这个查询：
                </p>
<pre class="code">
$client-&gt;setSkipSystemLookup(true);
$result = $client-&gt;call('foo.bar', array(array()));

                </pre>
</td></tr>
</table></div>
</div>
<div class="sect3" title="62.2.3.2. Zend_XmlRpc_Value 对象作为参数">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.value.parameters.xmlrpc-value"></a>62.2.3.2. <code>Zend_XmlRpc_Value</code> 对象作为参数</h4></div></div></div>
<p>
                也可以创建 <code>Zend_XmlRpc_Value</code> 实例作为参数，以表示特定的
                XML-RPC 类型。这样做的主要原因如下：
                </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                            当希望确定的参数类型被传递传递时（例如，方法需要一个整型，
                            而可能从数据库获得的是一个字符串）。
                        </p></li>
<li class="listitem"><p>
                            当方法需要 <code>base64</code> 或者 <code>dateTime.iso8601</code>
                            类型时（这些在 PHP 原始类型中不存在）。
                        </p></li>
<li class="listitem"><p>
                            当自动转换失败时（例如，你希望传递一个空的 XML-RPC
                            结构作为参数。空的结构在 PHP 中应当是一个空的数组，
                            但是如果传递一个空数组作为参数，它将被自动转换为 XML-RPC
                            数组，虽然它同数组没有联系）。
                        </p></li>
</ul></div>
<p>
            </p>
<p>
                有两种方法创建 <code>Zend_XmlRpc_Value</code> 对象：直接实例化某个
                <code>Zend_XmlRpc_Value</code> 的子类；或者使用静态工厂方法
                <code>Zend_XmlRpc_Value::getXmlRpcValue()</code>。
            </p>
<div class="table">
<a name="zend.xmlrpc.value.parameters.xmlrpc-value.table-1"></a><p class="title"><b>表 62.2. <code>Zend_XmlRpc_Value</code> 对象作为 XML-RPC 类型</b></p>
<div class="table-contents"><table summary="Zend_XmlRpc_Value 对象作为 XML-RPC 类型" border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>XML-RPC 类型</th>
<th>
<code>Zend_XmlRpc_Value</code> 常量</th>
<th>
<code>Zend_XmlRpc_Value</code> 对象</th>
</tr></thead>
<tbody>
<tr>
<td>int</td>
<td><code>Zend_XmlRpc_Value::XMLRPC_TYPE_INTEGER</code></td>
<td><code>Zend_XmlRpc_Value_Integer</code></td>
</tr>
<tr>
<td>double</td>
<td><code>Zend_XmlRpc_Value::XMLRPC_TYPE_DOUBLE</code></td>
<td><code>Zend_XmlRpc_Value_Double</code></td>
</tr>
<tr>
<td>boolean</td>
<td><code>Zend_XmlRpc_Value::XMLRPC_TYPE_BOOLEAN</code></td>
<td><code>Zend_XmlRpc_Value_Boolean</code></td>
</tr>
<tr>
<td>string</td>
<td><code>Zend_XmlRpc_Value::XMLRPC_TYPE_STRING</code></td>
<td><code>Zend_XmlRpc_Value_String</code></td>
</tr>
<tr>
<td>base64</td>
<td><code>Zend_XmlRpc_Value::XMLRPC_TYPE_BASE64</code></td>
<td><code>Zend_XmlRpc_Value_Base64</code></td>
</tr>
<tr>
<td>dateTime.iso8601</td>
<td><code>Zend_XmlRpc_Value::XMLRPC_TYPE_DATETIME</code></td>
<td><code>Zend_XmlRpc_Value_DateTime</code></td>
</tr>
<tr>
<td>array</td>
<td><code>Zend_XmlRpc_Value::XMLRPC_TYPE_ARRAY</code></td>
<td><code>Zend_XmlRpc_Value_Array</code></td>
</tr>
<tr>
<td>struct</td>
<td><code>Zend_XmlRpc_Value::XMLRPC_TYPE_STRUCT</code></td>
<td><code>Zend_XmlRpc_Value_Struct</code></td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
                </p>
<div class="note" title="自动转换"><table border="0" summary="Note: 自动转换">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">自动转换</th>
</tr>
<tr><td align="left" valign="top"><p>
                        当创建新的 <code>Zend_XmlRpc_Value</code> 对象时，它的值通过
                        PHP 类型设置。PHP 类型将会通过 PHP 类型转换到指定的类型。例如，
                        如果给 <code>Zend_XmlRpc_Value_Integer</code>
                        对象提供一个字符串，它将由 <code>(int)$value</code> 转换。
                    </p></td></tr>
</table></div>
<p>
            </p>
</div>
</div>
<div class="sect2" title="62.2.4. 服务代理对象">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.requests-and-responses"></a>62.2.4. 服务代理对象</h3></div></div></div>
<p>
            另一个使用 XML-RPC 客户端调用远程方法的途径是使用服务代理。这是一个 PHP
            对象代理远程 XML-RPC 名字空间，使其工作方式尽可能的贴近原始的 PHP 对象。
        </p>
<p>
            调用 <code>Zend_XmlRpc_Client</code> 实例的 <code>getProxy()</code>
            方法实例化一个服务器代理。该方法将返回一个 <code>Zend_XmlRpc_Client_ServerProxy</code>
            实例。对服务器代理方法的任何调用将会传递到远程，而参数的传递就如同其他任何
            PHP 方法一样。
        </p>
<div class="example">
<a name="zend.xmlrpc.client.requests-and-responses.example-1"></a><p class="title"><b>例 62.3. 代理默认命名空间</b></p>
<div class="example-contents"><pre class="code">
require_once 'Zend/XmlRpc/Client.html';

$client = new Zend_XmlRpc_Client('http://framework.zend.com/xmlrpc');

$server = $client-&gt;getProxy();           // Proxy the default namespace

$hello = $server-&gt;test-&gt;sayHello(1, 2);  // test.Hello(1, 2) returns "hello"

            </pre></div>
</div>
<br class="example-break"><p>
            <code>getProxy()</code> 方法接受一个可选参数作为将要代理的远端服务器的命名空间。
            如果没有指定这个命名空间，默认的命名空间会被代理。在下面的例子中，命名空间
            <code>test</code> 将会被代理。
        </p>
<div class="example">
<a name="zend.xmlrpc.client.requests-and-responses.example-2"></a><p class="title"><b>例 62.4. 代理任意命名空间</b></p>
<div class="example-contents"><pre class="code">
$client = new Zend_XmlRpc_Client('http://framework.zend.com/xmlrpc');

$test  = $client-&gt;getProxy('test');     // Proxy the "test" namespace

$hello = $test-&gt;sayHello(1, 2);         // test.Hello(1,2) returns "hello"

            </pre></div>
</div>
<br class="example-break"><p>
            若远端服务器支持任意深度嵌套的命名空间，仍然可以通过服务器代理使用。例如，
            如果上面的例子有一个方法 <code>test.foo.bar()</code>，则可以使用
            <code>$test-&gt;foo-&gt;bar()</code> 来调用。
        </p>
</div>
<div class="sect2" title="62.2.5. 错误处理">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.error-handling"></a>62.2.5. 错误处理</h3></div></div></div>
<p>
            在 XML-RPC 方法中可能出现两种错误：HTTP 错误和 XML-RPC 失败。
            <code>Zend_XmlRpc_Client</code> 可以识别并分别检测并捕获它们。
        </p>
<div class="sect3" title="62.2.5.1. HTTP 错误">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.client.error-handling.http"></a>62.2.5.1. HTTP 错误</h4></div></div></div>
<p>
                当 HTTP 错误发生时，例如远端 HTTP 服务器返回
                <code>404 Not Found</code>，将会抛出一个
                <code>Zend_XmlRpc_Client_HttpException</code> 异常。
            </p>
<div class="example">
<a name="zend.xmlrpc.client.error-handling.http.example-1"></a><p class="title"><b>例 62.5. 处理 HTTP 错误</b></p>
<div class="example-contents"><pre class="code">
$client = new Zend_XmlRpc_Client('http://foo/404');

try {

    $client-&gt;call('bar', array($arg1, $arg2));

} catch (Zend_XmlRpc_Client_HttpException $e) {

    // $e-&gt;getCode() returns 404
    // $e-&gt;getMessage() returns "Not Found"

}

                </pre></div>
</div>
<br class="example-break"><p>
                不论是如何使用 XML-RPC 客户端的，当 HTTP 错误发生时，都会抛出
                <code>Zend_XmlRpc_Client_HttpException</code> 异常。
            </p>
</div>
<div class="sect3" title="62.2.5.2. XML-RPC 失败">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.client.error-handling.faults"></a>62.2.5.2. XML-RPC 失败</h4></div></div></div>
<p>
                XML-RPC 失败类似于 PHP 异常。它是从 XML-RPC 方法调用返回的，有着指定的类型，
                同时具有错误代码和错误消息。XML-RPC 失败的处理方式随着 <code>Zend_XmlRpc_Client</code>
                使用方式不同而不同。
            </p>
<p>
                当 <code>call()</code> 方法或者服务器代理对象被使用时，XML-RPC
                失败会抛出一个 <code>Zend_XmlRpc_Client_FaultException</code>
                异常。异常代码和消息会直接映射到原始的 XML-RPC 失败相应的内容上去。
            </p>
<div class="example">
<a name="zend.xmlrpc.client.error-handling.faults.example-1"></a><p class="title"><b>例 62.6. 处理 XML-RPC 失败</b></p>
<div class="example-contents"><pre class="code">
$client = new Zend_XmlRpc_Client('http://framework.zend.com/xmlrpc');

try {

    $client-&gt;call('badMethod');

} catch (Zend_XmlRpc_Client_FaultException $e) {

    // $e-&gt;getCode() returns 1
    // $e-&gt;getMessage() returns "Unknown method"

}

                </pre></div>
</div>
<br class="example-break"><p>
                当请求时使用 <code>call()</code> 方法，会在失败的时候抛出
                <code>Zend_XmlRpc_Client_FaultException</code> 异常。可以调用
                <code>getLastResponse()</code> 获得包含在 <code>Zend_XmlRpc_Response</code>
                对象中的异常。
            </p>
<p>
                当请求时使用 <code>doRequest()</code> 方法，则不会抛出异常。将返回一个包含错误信息的
                <code>Zend_XmlRpc_Response</code> 对象。可以使用 <code>Zend_XmlRpc_Response</code>
                示例的 <code>isFault()</code> 方法检查。
            </p>
</div>
</div>
<div class="sect2" title="62.2.6. 服务器自省（introspection）">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.introspection"></a>62.2.6. 服务器自省（introspection）</h3></div></div></div>
<p>
            一些 XML-RPC 服务器支持 <code>system.</code> 命名空间下的自省。<code>Zend_XmlRpc_Client</code>
            对这些服务器的这种功能特别进行了支持。
        </p>
<p>
            调用 <code>Zend_XmlRpcClient</code> 的 <code>getIntrospector()</code>
            方法可以获得 <code>Zend_XmlRpc_Client_ServerIntrospection</code> 实例。
            通过它可以使用服务器的自省功能。
        </p>
</div>
<div class="sect2" title="62.2.7. 从请求作出回应">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.request-to-response"></a>62.2.7. 从请求作出回应</h3></div></div></div>
<p>
            本质上说，<code>Zend_XmlRpc_Client</code> 实例的 <code>call()</code>
            方法创建了请求对象（<code>Zend_XmlRpc_Request</code>）并将其传递给另一个方法
            <code>doRequest()</code>，<code>doRequest()</code> 方法返回响应对象（<code>Zend_XmlRpc_Response</code>）。
        </p>
<p>
            <code>doRequest()</code> 方法也可直接调用。
        </p>
<div class="example">
<a name="zend.xmlrpc.client.request-to-response.example-1"></a><p class="title"><b>例 62.7. 处理请求作出回应</b></p>
<div class="example-contents"><pre class="code">
$client = new Zend_XmlRpc_Client('http://framework.zend.com/xmlrpc');

$request = new Zend_XmlRpc_Request();
$request-&gt;setMethod('test.sayHello');
$request-&gt;setParams(array('foo', 'bar'));

$client-&gt;doRequest($request);

// $server-&gt;getLastRequest() returns instanceof Zend_XmlRpc_Request
// $server-&gt;getLastResponse() returns instanceof Zend_XmlRpc_Response

            </pre></div>
</div>
<br class="example-break"><p>
            无论客户端通过任何方法调用 XML-RPC 方法，如 <code>call()</code> 方法、
            <code>doRequest()</code> 方法或者服务器代理，最后一个请求对象以及对应的响应对象总是可以分别调用
            <code>getLastRequest()</code> 和 <code>getLastResponse()</code> 获得。
        </p>
</div>
<div class="sect2" title="62.2.8. HTTP 客户端和测试">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.client.http-client"></a>62.2.8. HTTP 客户端和测试</h3></div></div></div>
<p>
            在前面所有的例子中，从未指定 HTTP 客户端。这是因为在使用 <code>Zend_XmlRpc_Client</code>
            时会使用默认配置自动创建一个 <code>Zend_Http_Client</code> 实例。
        </p>
<p>
            可以在任何时候使用 <code>getHttpClient()</code> 方法获得 HTTP 客户端。
            多数情况下默认的 HTTP 客户端已经足够使用。不过仍然可以使用 <code>setHttpClient()</code>
            方法设置新的 HTTP 客户端实例。
        </p>
<p>
            <code>setHttpClient()</code> 在单元测试时特别有用。在 <code>Zend_Http_Client_Adapter_Test</code>
            中测试时可以欺骗远程服务器。阅读 <code>Zend_XmlRpc_Client</code> 的单元测试了解如何这样做。
        </p>
</div>
</div>
<div class="revinfo"></div>


<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->