<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->



<div class="sect1" title="15.8. Zend_Db_Table Relationships">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.db.table.relationships"></a>15.8. Zend_Db_Table Relationships</h2></div></div></div>
<div class="sect2" title="15.8.1. Introduction">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.introduction"></a>15.8.1. Introduction</h3></div></div></div>
<p>
            Tables have relationships to each other in a relational database. An entity in one
            table can be linked to one or more entities in another table by using referential
            integrity constraints defined in the database schema.
        </p>
<p>
            The <code class="classname">Zend_Db_Table_Row</code> class has methods for querying related rows
            in other tables.
        </p>
</div>
<div class="sect2" title="15.8.2. Defining Relationships">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.defining"></a>15.8.2. Defining Relationships</h3></div></div></div>
<p>
            Define classes for each of your tables, extending the abstract class
            <code class="classname">Zend_Db_Table_Abstract</code>, as described in
            <a class="xref" href="">???</a>. Also
            see <a class="xref" href="">???</a> for a description of the
            example database for which the following example code is designed.
        </p>
<p>
            Below are the PHP class definitions for these tables:
        </p>
<pre class="code">
class Accounts extends Zend_Db_Table_Abstract
{
    protected $_name            = 'accounts';
    protected $_dependentTables = array('Bugs');
}

class Products extends Zend_Db_Table_Abstract
{
    protected $_name            = 'products';
    protected $_dependentTables = array('BugsProducts');
}

class Bugs extends Zend_Db_Table_Abstract
{
    protected $_name            = 'bugs';

    protected $_dependentTables = array('BugsProducts');

    protected $_referenceMap    = array(
        'Reporter' =&gt; array(
            'columns'           =&gt; 'reported_by',
            'refTableClass'     =&gt; 'Accounts',
            'refColumns'        =&gt; 'account_name'
        ),
        'Engineer' =&gt; array(
            'columns'           =&gt; 'assigned_to',
            'refTableClass'     =&gt; 'Accounts',
            'refColumns'        =&gt; 'account_name'
        ),
        'Verifier' =&gt; array(
            'columns'           =&gt; array('verified_by'),
            'refTableClass'     =&gt; 'Accounts',
            'refColumns'        =&gt; array('account_name')
        )
    );
}

class BugsProducts extends Zend_Db_Table_Abstract
{
    protected $_name = 'bugs_products';

    protected $_referenceMap    = array(
        'Bug' =&gt; array(
            'columns'           =&gt; array('bug_id'),
            'refTableClass'     =&gt; 'Bugs',
            'refColumns'        =&gt; array('bug_id')
        ),
        'Product' =&gt; array(
            'columns'           =&gt; array('product_id'),
            'refTableClass'     =&gt; 'Products',
            'refColumns'        =&gt; array('product_id')
        )
    );

}
</pre>
<p>
            If you use <code class="classname">Zend_Db_Table</code> to emulate cascading UPDATE and DELETE
            operations, declare the <code class="varname">$_dependentTables</code> array in the class for the
            parent table. List the class name for each dependent table. Use the class name, not the
            physical name of the SQL table.
        </p>
<div class="note" title="注意"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top"><p>
                Skip declaration of <code class="varname">$_dependentTables</code> if you use referential
                integrity constraints in the RDBMS server to implement cascading operations. See
                <a class="xref" href="zend.db.table.relationships.html#zend.db.table.relationships.cascading" title="15.8.6. Cascading Write Operations">第 15.8.6 节 “Cascading Write Operations”</a> for more information.
            </p></td></tr>
</table></div>
<p>
            Declare the <code class="varname">$_referenceMap</code> array in the class for each dependent
            table. This is an associative array of reference "rules". A reference rule identifies
            which table is the parent table in the relationship, and also lists which columns in the
            dependent table reference which columns in the parent table.
        </p>
<p>
            The rule key is a string used as an index to the <code class="varname">$_referenceMap</code>
            array. This rule key is used to identify each reference relationship. Choose a
            descriptive name for this rule key. It's best to use a string that can be part of a PHP
            method name, as you will see later.
        </p>
<p>
            In the example PHP code above, the rule keys in the Bugs table class are:
            <code>'Reporter'</code>, <code>'Engineer'</code>, <code>'Verifier'</code>, and
            <code>'Product'</code>.
        </p>
<p>
            The value of each rule entry in the <code class="varname">$_referenceMap</code> array is also an
            associative array. The elements of this rule entry are described below:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
                    <span class="emphasis"><em>columns</em></span> =&gt; A string or an array of strings
                    naming the foreign key column name(s) in the dependent table.
                </p>
<p>
                    It's common for this to be a single column, but some tables have multi-column
                    keys.
                </p>
</li>
<li class="listitem">
<p>
                    <span class="emphasis"><em>refTableClass</em></span> =&gt; The class name of the
                    parent table. Use the class name, not the physical name of the SQL table.
                </p>
<p>
                    It's common for a dependent table to have only one reference to its parent
                    table, but some tables have multiple references to the same parent table. In
                    the example database, there is one reference from the <code>bugs</code> table
                    to the <code>products</code> table, but three references from the
                    <code>bugs</code> table to the <code>accounts</code> table. Put each reference
                    in a separate entry in the <code class="varname">$_referenceMap</code> array.
                </p>
</li>
<li class="listitem">
<p>
                    <span class="emphasis"><em>refColumns</em></span> =&gt; A string or an array of
                    strings naming the primary key column name(s) in the parent table.
                </p>
<p>
                    It's common for this to be a single column, but some tables have multi-column
                    keys. If the reference uses a multi-column key, the order of columns in the
                    <code>'columns'</code> entry must match the order of columns in the
                    <code>'refColumns'</code> entry.
                </p>
<p>
                    It is optional to specify this element. If you don't specify the
                    <code>refColumns</code>, the column(s) reported as the primary key columns of
                    the parent table are used by default.
                </p>
</li>
<li class="listitem"><p>
                    <span class="emphasis"><em>onDelete</em></span> =&gt; The rule for an action to
                    execute if a row is deleted in the parent table. See
                    <a class="xref" href="zend.db.table.relationships.html#zend.db.table.relationships.cascading" title="15.8.6. Cascading Write Operations">第 15.8.6 节 “Cascading Write Operations”</a> for more information.
                </p></li>
<li class="listitem"><p>
                    <span class="emphasis"><em>onUpdate</em></span> =&gt; The rule for an action to
                    execute if values in primary key columns are updated in the parent table. See
                    <a class="xref" href="zend.db.table.relationships.html#zend.db.table.relationships.cascading" title="15.8.6. Cascading Write Operations">第 15.8.6 节 “Cascading Write Operations”</a> for more information.
                </p></li>
</ul></div>
</div>
<div class="sect2" title="15.8.3. Fetching a Dependent Rowset">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.fetching.dependent"></a>15.8.3. Fetching a Dependent Rowset</h3></div></div></div>
<p>
            If you have a Row object as the result of a query on a parent table, you can fetch rows
            from dependent tables that reference the current row. Use the method:
        </p>
<pre class="code">
$row-&gt;findDependentRowset($table, [$rule]);
</pre>
<p>
            This method returns a <code class="classname">Zend_Db_Table_Rowset_Abstract</code> object,
            containing a set of rows from the dependent table <code class="varname">$table</code> that refer
            to the row identified by the <code class="varname">$row</code> object.
        </p>
<p>
            The first argument <code class="varname">$table</code> can be a string that specifies the
            dependent table by its class name. You can also specify the dependent table by using an
            object of that table class.
        </p>
<div class="example">
<a name="zend.db.table.relationships.fetching.dependent.example"></a><p class="title"><b>例 15.12. Fetching a Dependent Rowset</b></p>
<div class="example-contents">
<p>
                This example shows getting a Row object from the table <code>Accounts</code>, and
                finding the <code>Bugs</code> reported by that account.
            </p>
<pre class="code">
$accountsTable = new Accounts();
$accountsRowset = $accountsTable-&gt;find(1234);
$user1234 = $accountsRowset-&gt;current();

$bugsReportedByUser = $user1234-&gt;findDependentRowset('Bugs');
</pre>
</div>
</div>
<br class="example-break"><p>
            The second argument <code class="varname">$rule</code> is optional. It is a string that names the
            rule key in the <code class="varname">$_referenceMap</code> array of the dependent table class. If
            you don't specify a rule, the first rule in the array that references the parent table
            is used. If you need to use a rule other than the first, you need to specify the key.
        </p>
<p>
            In the example code above, the rule key is not specified, so the rule used by default
            is the first one that matches the parent table. This is the rule
            <code>'Reporter'</code>.
        </p>
<div class="example">
<a name="zend.db.table.relationships.fetching.dependent.example-by"></a><p class="title"><b>例 15.13. Fetching a Dependent Rowset By a Specific Rule</b></p>
<div class="example-contents">
<p>
                This example shows getting a Row object from the table <code>Accounts</code>, and
                finding the <code>Bugs</code> assigned to be fixed by the user of that account. The
                rule key string that corresponds to this reference relationship in this example is
                <code>'Engineer'</code>.
            </p>
<pre class="code">
$accountsTable = new Accounts();
$accountsRowset = $accountsTable-&gt;find(1234);
$user1234 = $accountsRowset-&gt;current();

$bugsAssignedToUser = $user1234-&gt;findDependentRowset('Bugs', 'Engineer');
</pre>
</div>
</div>
<br class="example-break"><p>
            You can also add criteria, ordering and limits to your relationships using the parent
            row's select object.
        </p>
<p>

            </p>
<div class="example">
<a name="zend.db.table.relationships.fetching.dependent.example-by-select"></a><p class="title"><b>例 15.14. Fetching a Dependent Rowset using a Zend_Db_Table_Select</b></p>
<div class="example-contents">
<p>
                    This example shows getting a Row object from the table <code>Accounts</code>,
                    and finding the <code>Bugs</code> assigned to be fixed by the user of that
                    account, limited only to 3 rows and ordered by name.
                </p>
<pre class="code">
$accountsTable = new Accounts();
$accountsRowset = $accountsTable-&gt;find(1234);
$user1234 = $accountsRowset-&gt;current();
$select = $accountsTable-&gt;select()-&gt;order('name ASC')
                                  -&gt;limit(3);

$bugsAssignedToUser = $user1234-&gt;findDependentRowset('Bugs',
                                                     'Engineer',
                                                     $select);
</pre>
</div>
</div>
<p><br class="example-break">

            Alternatively, you can query rows from a dependent table using a special mechanism
            called a "magic method". <code class="classname">Zend_Db_Table_Row_Abstract</code> invokes the
            method: <code>findDependentRowset('&lt;TableClass&gt;', '&lt;Rule&gt;')</code> if you
            invoke a method on the Row object matching either of the following patterns:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                    <code>$row-&gt;find&lt;TableClass&gt;()</code>
                </p></li>
<li class="listitem"><p>
                    <code>$row-&gt;find&lt;TableClass&gt;By&lt;Rule&gt;()</code>
                </p></li>
</ul></div>
<p>
            In the patterns above, <code>&lt;TableClass&gt;</code> and <code>&lt;Rule&gt;</code> are
            strings that correspond to the class name of the dependent table, and the dependent
            table's rule key that references the parent table.
        </p>
<div class="note" title="注意"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top"><p>
                Some application frameworks, such as Ruby on Rails, use a mechanism called
                "inflection" to allow the spelling of identifiers to change depending on usage. For
                simplicity, <code class="classname">Zend_Db_Table_Row</code> does not provide any inflection
                mechanism. The table identity and the rule key named in the method call must match
                the spelling of the class and rule key exactly.
            </p></td></tr>
</table></div>
<div class="example">
<a name="zend.db.table.relationships.fetching.dependent.example-magic"></a><p class="title"><b>例 15.15. Fetching Dependent Rowsets using the Magic Method</b></p>
<div class="example-contents">
<p>
                This example shows finding dependent Rowsets equivalent to those in the previous
                examples. In this case, the application uses the magic method invocation instead of
                specifying the table and rule as strings.
            </p>
<pre class="code">
$accountsTable = new Accounts();
$accountsRowset = $accountsTable-&gt;find(1234);
$user1234 = $accountsRowset-&gt;current();

// Use the default reference rule
$bugsReportedBy = $user1234-&gt;findBugs();

// Specify the reference rule
$bugsAssignedTo = $user1234-&gt;findBugsByEngineer();
</pre>
</div>
</div>
<br class="example-break">
</div>
<div class="sect2" title="15.8.4. Fetching a Parent Row">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.fetching.parent"></a>15.8.4. Fetching a Parent Row</h3></div></div></div>
<p>
            If you have a Row object as the result of a query on a dependent table, you can fetch
            the row in the parent to which the dependent row refers. Use the method:
        </p>
<pre class="code">
$row-&gt;findParentRow($table, [$rule]);
</pre>
<p>
            There always should be exactly one row in the parent table referenced by a dependent
            row, therefore this method returns a Row object, not a Rowset object.
        </p>
<p>
            The first argument <code class="varname">$table</code> can be a string that specifies the parent
            table by its class name. You can also specify the parent table by using an object of
            that table class.
        </p>
<div class="example">
<a name="zend.db.table.relationships.fetching.parent.example"></a><p class="title"><b>例 15.16. Fetching the Parent Row</b></p>
<div class="example-contents">
<p>
                This example shows getting a Row object from the table <code>Bugs</code> (for
                example one of those bugs with status 'NEW'), and finding the row in the
                <code>Accounts</code> table for the user who reported the bug.
            </p>
<pre class="code">
$bugsTable = new Bugs();
$bugsRowset = $bugsTable-&gt;fetchAll(array('bug_status = ?' =&gt; 'NEW'));
$bug1 = $bugsRowset-&gt;current();

$reporter = $bug1-&gt;findParentRow('Accounts');
</pre>
</div>
</div>
<br class="example-break"><p>
            The second argument <code class="varname">$rule</code> is optional. It is a string that names the
            rule key in the <code class="varname">$_referenceMap</code> array of the dependent table class. If
            you don't specify a rule, the first rule in the array that references the parent table
            is used. If you need to use a rule other than the first, you need to specify the key.
        </p>
<p>
            In the example above, the rule key is not specified, so the rule used by default is the
            first one that matches the parent table. This is the rule <code>'Reporter'</code>.
        </p>
<div class="example">
<a name="zend.db.table.relationships.fetching.parent.example-by"></a><p class="title"><b>例 15.17. Fetching a Parent Row By a Specific Rule</b></p>
<div class="example-contents">
<p>
                This example shows getting a Row object from the table <code>Bugs</code>, and
                finding the account for the engineer assigned to fix that bug. The rule key string
                that corresponds to this reference relationship in this example is
                <code>'Engineer'</code>.
            </p>
<pre class="code">
$bugsTable = new Bugs();
$bugsRowset = $bugsTable-&gt;fetchAll(array('bug_status = ?', 'NEW'));
$bug1 = $bugsRowset-&gt;current();

$engineer = $bug1-&gt;findParentRow('Accounts', 'Engineer');
</pre>
</div>
</div>
<br class="example-break"><p>
            Alternatively, you can query rows from a parent table using a "magic method".
            <code class="classname">Zend_Db_Table_Row_Abstract</code> invokes the method:
            <code>findParentRow('&lt;TableClass&gt;', '&lt;Rule&gt;')</code> if you invoke a method
            on the Row object matching either of the following patterns:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                    <code>$row-&gt;findParent&lt;TableClass&gt;([Zend_Db_Table_Select $select])</code>
                </p></li>
<li class="listitem"><p>
                    <code>$row-&gt;findParent&lt;TableClass&gt;By&lt;Rule&gt;([Zend_Db_Table_Select
                    $select])</code>
                </p></li>
</ul></div>
<p>
            In the patterns above, <code>&lt;TableClass&gt;</code> and <code>&lt;Rule&gt;</code>
            are strings that correspond to the class name of the parent table, and the dependent
            table's rule key that references the parent table.
        </p>
<div class="note" title="注意"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top"><p>
                The table identity and the rule key named in the method call must match the
                spelling of the class and rule key exactly.
            </p></td></tr>
</table></div>
<div class="example">
<a name="zend.db.table.relationships.fetching.parent.example-magic"></a><p class="title"><b>例 15.18. Fetching the Parent Row using the Magic Method</b></p>
<div class="example-contents">
<p>
                This example shows finding parent Rows equivalent to those in the previous
                examples. In this case, the application uses the magic method invocation instead of
                specifying the table and rule as strings.
            </p>
<pre class="code">
$bugsTable = new Bugs();
$bugsRowset = $bugsTable-&gt;fetchAll(array('bug_status = ?', 'NEW'));
$bug1 = $bugsRowset-&gt;current();

// Use the default reference rule
$reporter = $bug1-&gt;findParentAccounts();

// Specify the reference rule
$engineer = $bug1-&gt;findParentAccountsByEngineer();
</pre>
</div>
</div>
<br class="example-break">
</div>
<div class="sect2" title="15.8.5. Fetching a Rowset via a Many-to-many Relationship">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.fetching.many-to-many"></a>15.8.5. Fetching a Rowset via a Many-to-many Relationship</h3></div></div></div>
<p>
            If you have a Row object as the result of a query on one table in a many-to-many
            relationship (for purposes of the example, call this the "origin" table), you can
            fetch corresponding rows in the other table (call this the "destination" table) via an
            intersection table. Use the method:
        </p>
<pre class="code">
$row-&gt;findManyToManyRowset($table,
                           $intersectionTable,
                           [$rule1,
                               [$rule2,
                                   [Zend_Db_Table_Select $select]
                               ]
                           ]);
</pre>
<p>
            This method returns a <code class="classname">Zend_Db_Table_Rowset_Abstract</code> containing
            rows from the table <code class="varname">$table</code>, satisfying the many-to-many relationship.
            The current Row object <code class="varname">$row</code> from the origin table is used to find
            rows in the intersection table, and that is joined to the destination table.
        </p>
<p>
            The first argument <code class="varname">$table</code> can be a string that specifies the
            destination table in the many-to-many relationship by its class name. You can also
            specify the destination table by using an object of that table class.
        </p>
<p>
            The second argument <code class="varname">$intersectionTable</code> can be a string that specifies
            the intersection table between the two tables in the many-to-many relationship by
            its class name. You can also specify the intersection table by using an object of that
            table class.
        </p>
<div class="example">
<a name="zend.db.table.relationships.fetching.many-to-many.example"></a><p class="title"><b>例 15.19. Fetching a Rowset with the Many-to-many Method</b></p>
<div class="example-contents">
<p>
                This example shows getting a Row object from the origin table
                <code>Bugs</code>, and finding rows from the destination table
                <code>Products</code>, representing products related to that bug.
            </p>
<pre class="code">
$bugsTable = new Bugs();
$bugsRowset = $bugsTable-&gt;find(1234);
$bug1234 = $bugsRowset-&gt;current();

$productsRowset = $bug1234-&gt;findManyToManyRowset('Products',
                                                 'BugsProducts');
</pre>
</div>
</div>
<br class="example-break"><p>
            The third and fourth arguments <code class="varname">$rule1</code> and <code class="varname">$rule2</code>
            are optional. These are strings that name the rule keys in the
            <code class="varname">$_referenceMap</code> array of the intersection table.
        </p>
<p>
            The <code class="varname">$rule1</code> key names the rule for the relationship from the
            intersection table to the origin table. In this example, this is the relationship from
            <code>BugsProducts</code> to <code>Bugs</code>.
        </p>
<p>
            The <code class="varname">$rule2</code> key names the rule for the relationship from the
            intersection table to the destination table. In this example, this is the relationship
            from <code>Bugs</code> to <code>Products</code>.
        </p>
<p>
            Similarly to the methods for finding parent and dependent rows, if you don't specify a
            rule, the method uses the first rule in the <code class="varname">$_referenceMap</code> array that
            matches the tables in the relationship. If you need to use a rule other than the first,
            you need to specify the key.
        </p>
<p>
            In the example code above, the rule key is not specified, so the rules used by default
            are the first ones that match. In this case, <code class="varname">$rule1</code> is
            <code>'Reporter'</code> and <code class="varname">$rule2</code> is <code>'Product'</code>.
        </p>
<div class="example">
<a name="zend.db.table.relationships.fetching.many-to-many.example-by"></a><p class="title"><b>例 15.20. Fetching a Rowset with the Many-to-many Method By a Specific Rule</b></p>
<div class="example-contents">
<p>
                This example shows geting a Row object from the origin table
                <code>Bugs</code>, and finding rows from the destination table
                <code>Products</code>, representing products related to that bug.
            </p>
<pre class="code">
$bugsTable = new Bugs();
$bugsRowset = $bugsTable-&gt;find(1234);
$bug1234 = $bugsRowset-&gt;current();

$productsRowset = $bug1234-&gt;findManyToManyRowset('Products',
                                                 'BugsProducts',
                                                 'Bug');
</pre>
</div>
</div>
<br class="example-break"><p>
            Alternatively, you can query rows from the destination table in a many-to-many
            relationship using a "magic method." <code class="classname">Zend_Db_Table_Row_Abstract</code>
            invokes the method: <code>findManyToManyRowset('&lt;TableClass&gt;',
            '&lt;IntersectionTableClass&gt;', '&lt;Rule1&gt;', '&lt;Rule2&gt;')</code> if you invoke
            a method matching any of the following patterns:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                    <code>$row-&gt;find&lt;TableClass&gt;Via&lt;IntersectionTableClass&gt;
                    ([Zend_Db_Table_Select $select])</code>
                </p></li>
<li class="listitem"><p>
                    <code>$row-&gt;find&lt;TableClass&gt;Via&lt;IntersectionTableClass&gt;By&lt;Rule1&gt;
                        ([Zend_Db_Table_Select $select])</code>
                </p></li>
<li class="listitem"><p>
                    <code>$row-&gt;find&lt;TableClass&gt;Via&lt;IntersectionTableClass&gt;By&lt;Rule1&gt;And&lt;Rule2&gt;
                        ([Zend_Db_Table_Select $select])</code>
                </p></li>
</ul></div>
<p>
            In the patterns above, <code>&lt;TableClass&gt;</code> and
            <code>&lt;IntersectionTableClass&gt;</code> are strings that correspond to the class
            names of the destination table and the intersection table, respectively.
            <code>&lt;Rule1&gt;</code> and <code>&lt;Rule2&gt;</code> are strings that correspond
            to the rule keys in the intersection table that reference the origin table and the
            destination table, respectively.
        </p>
<div class="note" title="注意"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top"><p>
                The table identities and the rule keys named in the method call must match the
                spelling of the class and rule key exactly.
            </p></td></tr>
</table></div>
<div class="example">
<a name="zend.db.table.relationships.fetching.many-to-many.example-magic"></a><p class="title"><b>例 15.21. Fetching Rowsets using the Magic Many-to-many Method</b></p>
<div class="example-contents">
<p>
                This example shows finding rows in the destination table of a many-to-many
                relationship representing products related to a given bug.
            </p>
<pre class="code">
$bugsTable = new Bugs();
$bugsRowset = $bugsTable-&gt;find(1234);
$bug1234 = $bugsRowset-&gt;current();

// Use the default reference rule
$products = $bug1234-&gt;findProductsViaBugsProducts();

// Specify the reference rule
$products = $bug1234-&gt;findProductsViaBugsProductsByBug();
</pre>
</div>
</div>
<br class="example-break">
</div>
<div class="sect2" title="15.8.6. Cascading Write Operations">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.db.table.relationships.cascading"></a>15.8.6. Cascading Write Operations</h3></div></div></div>
<div class="note" title="Declare DRI in the database:"><table border="0" summary="Note: Declare DRI in the database:">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">Declare DRI in the database:</th>
</tr>
<tr><td align="left" valign="top">
<p>
                Declaring cascading operations in <code class="classname">Zend_Db_Table</code> is intended
                <span class="emphasis"><em>only</em></span> for RDBMS brands that do not support
                declarative referential integrity (DRI).
            </p>
<p>
                For example, if you use MySQL's MyISAM storage engine, or SQLite, these solutions
                do not support DRI. You may find it helpful to declare the cascading operations
                with <code class="classname">Zend_Db_Table</code>.
            </p>
<p>
                If your RDBMS implements DRI and the <code>ON DELETE</code> and
                <code>ON UPDATE</code> clauses, you should declare these clauses in your database
                schema, instead of using the cascading feature in
                <code class="classname">Zend_Db_Table</code>. Declaring cascading DRI rules in the RDBMS is
                better for database performance, consistency, and integrity.
            </p>
<p>
                Most importantly, do not declare cascading operations both in the RDBMS and in your
                <code class="classname">Zend_Db_Table</code> class.
            </p>
</td></tr>
</table></div>
<p>
            You can declare cascading operations to execute against a dependent table when you
            apply an <code>UPDATE</code> or a <code>DELETE</code> to a row in a parent table.
        </p>
<div class="example">
<a name="zend.db.table.relationships.cascading.example-delete"></a><p class="title"><b>例 15.22. Example of a Cascading Delete</b></p>
<div class="example-contents">
<p>
                This example shows deleting a row in the <code>Products</code> table, which is
                configured to automatically delete dependent rows in the <code>Bugs</code> table.
            </p>
<pre class="code">
$productsTable = new Products();
$productsRowset = $productsTable-&gt;find(1234);
$product1234 = $productsRowset-&gt;current();

$product1234-&gt;delete();
// Automatically cascades to Bugs table
// and deletes dependent rows.
</pre>
</div>
</div>
<br class="example-break"><p>
            Similarly, if you use <code>UPDATE</code> to change the value of a primary key in a
            parent table, you may want the value in foreign keys of dependent tables to be updated
            automatically to match the new value, so that such references are kept up to date.
        </p>
<p>
            It's usually not necessary to update the value of a primary key that was generated by a
            sequence or other mechanism. But if you use a <span class="emphasis"><em>natural key</em></span> that may
            change value occasionally, it is more likely that you need to apply cascading updates
            to dependent tables.
        </p>
<p>
            To declare a cascading relationship in the <code class="classname">Zend_Db_Table</code>, edit
            the rules in the <code class="varname">$_referenceMap</code>. Set the associative array keys
            <code>'onDelete'</code> and <code>'onUpdate'</code> to the string 'cascade' (or the
            constant <code>self::CASCADE</code>). Before a row is deleted from the parent table, or
            its primary key values updated, any rows in the dependent table that refer to the
            parent's row are deleted or updated first.
        </p>
<div class="example">
<a name="zend.db.table.relationships.cascading.example-declaration"></a><p class="title"><b>例 15.23. Example Declaration of Cascading Operations</b></p>
<div class="example-contents">
<p>
                In the example below, rows in the <code>Bugs</code> table are automatically deleted
                if the row in the <code>Products</code> table to which they refer is deleted. The
                <code>'onDelete'</code> element of the reference map entry is set to
                <code>self::CASCADE</code>.
            </p>
<p>
                No cascading update is done in the example below if the primary key value in the
                parent class is changed. The <code>'onUpdate'</code> element of the reference map
                entry is <code>self::RESTRICT</code>. You can get the same result by omitting
                the <code>'onUpdate'</code> entry.
            </p>
<pre class="code">
class BugsProducts extends Zend_Db_Table_Abstract
{
    ...
    protected $_referenceMap = array(
        'Product' =&gt; array(
            'columns'           =&gt; array('product_id'),
            'refTableClass'     =&gt; 'Products',
            'refColumns'        =&gt; array('product_id'),
            'onDelete'          =&gt; self::CASCADE,
            'onUpdate'          =&gt; self::RESTRICT
        ),
        ...
    );
}
</pre>
</div>
</div>
<br class="example-break"><div class="sect3" title="15.8.6.1. Notes Regarding Cascading Operations">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.db.table.relationships.cascading.notes"></a>15.8.6.1. Notes Regarding Cascading Operations</h4></div></div></div>
<p>
                <span class="emphasis"><em>Cascading operations invoked by <code class="classname">Zend_Db_Table</code> are
                not atomic.</em></span>
            </p>
<p>
                This means that if your database implements and enforces referential integrity
                constraints, a cascading <code>UPDATE</code> executed by a
                <code class="classname">Zend_Db_Table</code> class conflicts with the constraint, and
                results in a referential integrity violation. You can use cascading
                <code>UPDATE</code> in <code class="classname">Zend_Db_Table</code>
                <span class="emphasis"><em>only</em></span> if your database does not enforce that referential
                integrity constraint.
            </p>
<p>
                Cascading <code>DELETE</code> suffers less from the problem of referential
                integrity violations. You can delete dependent rows as a non-atomic action before
                deleting the parent row that they reference.
            </p>
<p>
                However, for both <code>UPDATE</code> and <code>DELETE</code>, changing the
                database in a non-atomic way also creates the risk that another database user can
                see the data in an inconsistent state. For example, if you delete a row and all its
                dependent rows, there is a small chance that another database client program can
                query the database after you have deleted the dependent rows, but before you delete
                the parent row. That client program may see the parent row with no dependent rows,
                and assume this is the intended state of the data. There is no way for that client
                to know that its query read the database in the middle of a change.
            </p>
<p>
                The issue of non-atomic change can be mitigated by using transactions to isolate
                your change. But some RDBMS brands don't support transactions, or allow clients to
                read "dirty" changes that have not been committed yet.
            </p>
<p>
                <span class="emphasis"><em>Cascading operations in <code class="classname">Zend_Db_Table</code> are invoked
                only by <code class="classname">Zend_Db_Table</code>.</em></span>
            </p>
<p>
                Cascading deletes and updates defined in your <code class="classname">Zend_Db_Table</code>
                classes are applied if you execute the <code>save()</code> or <code>delete()</code>
                methods on the Row class. However, if you update or delete data using another
                interface, such as a query tool or another application, the cascading operations are
                not applied. Even when using <code>update()</code> and <code>delete()</code> methods
                in the <code class="classname">Zend_Db_Adapter</code> class, cascading operations defined in
                your <code class="classname">Zend_Db_Table</code> classes are not executed.
            </p>
<p>
                <span class="emphasis"><em>No Cascading <code>INSERT</code>.</em></span>
            </p>
<p>
                There is no support for a cascading <code>INSERT</code>. You must insert a row to a
                parent table in one operation, and insert row(s) to a dependent table in a separate
                operation.
            </p>
</div>
</div>
</div>
<div class="revinfo"></div>


<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->