<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->



<div class="chapter" title="第 5 章 Zend_Auth">
<div class="titlepage"><div><div><h2 class="title">
<a name="zend.auth"></a>第 5 章 Zend_Auth</h2></div></div></div>
<div class="toc">
<p><b>目录</b></p>
<dl>
<dt><span class="sect1"><a href="zend.auth.html#zend.auth.introduction">5.1. 简介</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="zend.auth.html#zend.auth.introduction.adapters">5.1.1. 适配器</a></span></dt>
<dt><span class="sect2"><a href="zend.auth.html#zend.auth.introduction.results">5.1.2. 结果</a></span></dt>
<dt><span class="sect2"><a href="zend.auth.html#zend.auth.introduction.persistence">5.1.3. 身份的持久（Persistence）</a></span></dt>
<dd><dl>
<dt><span class="sect3"><a href="zend.auth.html#zend.auth.introduction.persistence.default">5.1.3.1. 在PHP Session 中的缺省持久（Persistence）</a></span></dt>
<dt><span class="sect3"><a href="zend.auth.html#zend.auth.introduction.persistence.custom">5.1.3.2. 实现订制存储</a></span></dt>
</dl></dd>
<dt><span class="sect2"><a href="zend.auth.html#zend.auth.introduction.using">5.1.4. 使用Zend_Auth</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="zend.auth.adapter.dbtable.html">5.2. 数据库表认证</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="zend.auth.adapter.dbtable.html#zend.auth.adapter.dbtable.introduction">5.2.1. 简介</a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.dbtable.html#zend.auth.adapter.dbtable.advanced.storing_result_row">5.2.2. 高级使用：持久一个 DbTable 结果对象</a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.dbtable.html#zend.auth.adapter.dbtable.advanced.advanced_usage">5.2.3. 高级用法范例</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="zend.auth.adapter.digest.html">5.3. 摘要式认证</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="zend.auth.adapter.digest.html#zend.auth.adapter.digest.introduction">5.3.1. 简介</a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.digest.html#zend.auth.adapter.digest.specifics">5.3.2. 规范（Specifics）</a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.digest.html#zend.auth.adapter.digest.identity">5.3.3. 身份（Identity）</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="zend.auth.adapter.http.html">5.4. HTTP 认证适配器</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="zend.auth.adapter.http.html#zend.auth.adapter.http.introduction">5.4.1. 简介</a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.http.html#zend.auth.adapter.design_overview">5.4.2. 设计回顾</a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.http.html#zend.auth.adapter.configuration_options">5.4.3. 配置选项</a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.http.html#zend.auth.adapter.http.resolvers">5.4.4. Resolvers</a></span></dt>
<dd><dl><dt><span class="sect3"><a href="zend.auth.adapter.http.html#zend.auth.adapter.http.resolvers.file">5.4.4.1. 文件 Resolver</a></span></dt></dl></dd>
<dt><span class="sect2"><a href="zend.auth.adapter.http.html#zend.auth.adapter.http.basic_usage">5.4.5. 基本用法</a></span></dt>
</dl></dd>
<dt><span class="sect1"><a href="zend.auth.adapter.ldap.html">5.5. LDAP 认证 </a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="zend.auth.adapter.ldap.html#zend.auth.adapter.ldap.introduction">5.5.1.  简介 </a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.ldap.html#zend.auth.adapter.ldap.usage">5.5.2.  用法 </a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.ldap.html#zend.auth.adapter.ldap.api">5.5.3. The API</a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.ldap.html#zend.auth.adapter.ldap.server-options">5.5.4.  服务器选项 </a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.ldap.html#zend.auth.adapter.ldap.debugging">5.5.5.  收集调试信息 </a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.ldap.html#zend.auth.adapter.ldap.options-common-server-specific">5.5.6.  特定服务器的通用选项 </a></span></dt>
<dd><dl>
<dt><span class="sect3"><a href="zend.auth.adapter.ldap.html#zend.auth.adapter.ldap.options-common-server-specific.active-directory">5.5.6.1. Active Directory 的选项 </a></span></dt>
<dt><span class="sect3"><a href="zend.auth.adapter.ldap.html#zend.auth.adapter.ldap.options-common-server-specific.openldap">5.5.6.2. OpenLDAP 的选项 </a></span></dt>
</dl></dd>
</dl></dd>
<dt><span class="sect1"><a href="zend.auth.adapter.openid.html">5.6. Open ID Authentication</a></span></dt>
<dd><dl>
<dt><span class="sect2"><a href="zend.auth.adapter.openid.html#zend.auth.adapter.openid.introduction">5.6.1.  简介 </a></span></dt>
<dt><span class="sect2"><a href="zend.auth.adapter.openid.html#zend.auth.adapter.openid.specifics">5.6.2.  细节 </a></span></dt>
</dl></dd>
</dl>
</div>
<div class="sect1" title="5.1. 简介">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.auth.introduction"></a>5.1. 简介</h2></div></div></div>
<p>
        Zend_Auth 为认证（authentication）和一些通用用例情景的具体认证适配器提供了一个API。
    </p>
<p>
        Zend_Auth 只涉及 <span class="strong"><strong>认证</strong></span>而不是<span class="strong"><strong>授权</strong></span>。认证被宽松地定义为基于一些证书（credential）来确定一个实体（例如，身份）是否确实是它所声称的。授权是一个过程，它决定是否允许一个实体对其他实体进行访问、执行操作，它超出了Zend_Auth的范围。更多关于Zend Framework 授权和访问控制的信息，参见<a class="link" href="zend.acl.html" title="第 2 章 Zend_Acl">Zend_Acl</a>.
    </p>
<div class="note" title="注意"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top"><p>
            <code>Zend_Auth</code> 类通过它的<code>getInstance()</code>方法实现 Singleton 模式 - 只有一个实例可用。这意味着使用 <code>new</code>操作符和 <code>clone</code> 关键字将不能在<code>Zend_Auth</code> 类中工作，而要使用 <code>Zend_Auth::getInstance()</code>来代替。
        </p></td></tr>
</table></div>
<div class="sect2" title="5.1.1. 适配器">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.auth.introduction.adapters"></a>5.1.1. 适配器</h3></div></div></div>
<p>
            Zend_Auth适配器被用来依靠特定的认证服务（例如LDAP、RDBMS或基于文件的存储）来认证。不同的适配器可能有不同的选项和行为，但有些基本的事情在认证适配器中是通用的。例如，接受认证证书（包括声称身份）、依靠认证服务执行查询、返回结果在Zend_Auth适配器中是通用的。
        </p>
<p>
            每个Zend_Auth适配器类都实现<code>Zend_Auth_Adapter_Interface</code>。这个接口定义了一个方法<code>authenticate()</code>，适配器必须为执行认证查询而实现它。在调用<code>authenticate()</code>之前，每个适配器必需准备就绪。这样适配器准备包括设置证书（例如，用户名和密码）并为适配器专用的配置选项定义一些值，例如为数据库表适配器做的连接设置。
        </p>
<p>
            下面是一个认证适配器的例子，它要求为认证设置用户名和密码。为简明扼要，其它的细节（如查询认证服务）被省略了。
            </p>
<pre class="code">
class MyAuthAdapter implements Zend_Auth_Adapter_Interface
{
    /**
     * Sets username and password for authentication
     *
     * @return void
     */
    public function __construct($username, $password)
    {
        // ...
    }

    /**
     * Performs an authentication attempt
     *
     * @throws Zend_Auth_Adapter_Exception If authentication cannot
     *                                     be performed
     * @return Zend_Auth_Result
     */
    public function authenticate()
    {
        // ...
    }
}

            </pre>
<p>

           如上面所示，<code>authenticate()</code>必需返回一个<code>Zend_Auth_Result</code>的实例（或从<code>Zend_Auth_Result</code>派生的一个类的实例）。如果因为某些原因认证查询不能执行，<code>authenticate()</code>应该抛出一个由<code>Zend_Auth_Adapter_Exception</code>产生的异常。
        </p>
</div>
<div class="sect2" title="5.1.2. 结果">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.auth.introduction.results"></a>5.1.2. 结果</h3></div></div></div>
<p>
            为了表示一个认证尝试的结果，Zend_Auth适配器返回一个带有<code>authenticate()</code>的<code>Zend_Auth_Result</code>的实例。适配器基于结构组成<code>Zend_Auth_Result</code>对象，下面四个方法提供了一组基本的用户面临的通用Zend_Auth适配器结果的操作：
            </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                        <code>isValid()</code> - 返回 true 当且仅当结果表示一个成功的认证尝试
                    </p></li>
<li class="listitem"><p>
                      <code>getCode()</code> - 返回一个 <code>Zend_Auth_Result</code>  常量标识符用来决定认证失败的类型或者是否认证成功。这个可以用于开发者希望区别若干认证结果类型的情形，例如，这允许开发者维护详细的认证结果统计。尽管开发这被鼓励去考虑提供这样详细的原因给用户的风险，替而代之使用一般的认证失败信息，这个功能的其它用法是由于可用性的原因提供专用的，定制的信息给用户。更多的信息，参见下面的注释。
                     </p></li>
<li class="listitem"><p>
                        <code>getIdentity()</code> - 返回认证尝试的身份
                    </p></li>
<li class="listitem"><p>
                        <code>getMessages()</code> - 返回关于认证尝试失败的数组
                    </p></li>
</ul></div>
<p>
        </p>
<p>
           为了执行更多的操作，开发者可能希望基于认证结果的类型来分支化。一些开发者可能发信有用的操作是：在太多的不成功的密码尝试之后锁住帐号，在太多不存在的身份尝试后标记IP地址，并提供专用的，定制的认证结果信息给用户。下面的结果代码是可用的：

            </p>
<pre class="code">
Zend_Auth_Result::SUCCESS
Zend_Auth_Result::FAILURE
Zend_Auth_Result::FAILURE_IDENTITY_NOT_FOUND
Zend_Auth_Result::FAILURE_IDENTITY_AMBIGUOUS
Zend_Auth_Result::FAILURE_CREDENTIAL_INVALID
Zend_Auth_Result::FAILURE_UNCATEGORIZED

            </pre>
<p>

        </p>
<p>
            下面的例子举例说明开发者如何分支化结果代码：
            </p>
<pre class="code">
// inside of AuthController / loginAction
$result = $this-&gt;_auth-&gt;authenticate($adapter);

switch ($result-&gt;getCode()) {

    case Zend_Auth_Result::FAILURE_IDENTITY_NOT_FOUND:
        /** do stuff for nonexistent identity **/
        break;

    case Zend_Auth_Result::FAILURE_CREDENTIAL_INVALID:
        /** do stuff for invalid credential **/
        break;

    case Zend_Auth_Result::SUCCESS:
        /** do stuff for successful authentication **/
        break;

    default:
        /** do stuff for other failure **/
        break;
}

            </pre>
<p>

        </p>
</div>
<div class="sect2" title="5.1.3. 身份的持久（Persistence）">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.auth.introduction.persistence"></a>5.1.3. 身份的持久（Persistence）</h3></div></div></div>
<p>
            实质上，认证一个包含认证证书的请求很有用，但是维护已认证的身份并在每次请求时不需要出示认证证书也同样很重要。
        </p>
<p>
            HTTP是一个无连接的协议，然而，象cookie和session这样的技术已经被开发出来使在服务器端的web应用维护多请求状态变得容易。
        </p>
<div class="sect3" title="5.1.3.1. 在PHP Session 中的缺省持久（Persistence）">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.auth.introduction.persistence.default"></a>5.1.3.1. 在PHP Session 中的缺省持久（Persistence）</h4></div></div></div>
<p>
                 缺省地，<code>Zend_Auth</code>从使用PHP session成功的认证尝试中提供身份的持久存储。基于一个成功的认证尝试，<code>Zend_Auth::authenticate()</code>通过把认证结果放入持久存储中来保存身份。除非另有配置，<code>Zend_Auth</code> 使用名称为<code>Zend_Auth_Storage_Session</code> 的存储类，这个类使用<a class="link" href="zend.session.html" title="第 48 章 Zend_Session">Zend_Session</a>。通过实现<code>Zend_Auth_Storage_Interface</code>给<code>Zend_Auth::setStorage()</code>提供一个对象，一个定制的类可以被替代使用。
            </p>
<div class="note" title="注意"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top"><p>
                    对于特定的用例，如果身份的持久存储不合适，开发者可以放弃使用<code>Zend_Auth</code>类，替代地，而直接使用适配器类。
                </p></td></tr>
</table></div>
<div class="example">
<a name="zend.auth.introduction.persistence.default.example"></a><p class="title"><b>例 5.1. 修改 Session 名字空间</b></p>
<div class="example-contents">
<p>
                    <code>Zend_Auth_Storage_Session</code>使用<code>'Zend_Auth'</code>的seesion名字空间。通过给<code>Zend_Auth_Storage_Session</code>的构造器传递不同的值，这个名字空间可以被替换，并且这个值被从内部传递给<code>Zend_Session_Namespace</code>的构造器。这应该发生在认证尝试之前，因为<code>Zend_Auth::authenticate()</code>执行身份的自动存储。

                    </p>
<pre class="code">
// Save a reference to the Singleton instance of Zend_Auth
$auth = Zend_Auth::getInstance();

// Use 'someNamespace' instead of 'Zend_Auth'
$auth-&gt;setStorage(new Zend_Auth_Storage_Session('someNamespace'));

/**
 * @todo Set up the auth adapter, $authAdapter
 */

// Authenticate, saving the result, and persisting the identity on
// success
$result = $auth-&gt;authenticate($authAdapter);

                    </pre>
<p>

                </p>
</div>
</div>
<br class="example-break">
</div>
<div class="sect3" title="5.1.3.2. 实现订制存储">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.auth.introduction.persistence.custom"></a>5.1.3.2. 实现订制存储</h4></div></div></div>
<p>
               有时候开发者需要使用不同的身份持久行为，而不是<code>Zend_Auth_Storage_Session</code>提供的。对于这样的案例开发者可以简单地实现<code>Zend_Auth_Storage_Interface</code>并给<code>Zend_Auth::setStorage()</code>提供一个类的实例。
            </p>
<div class="example">
<a name="zend.auth.introduction.persistence.custom.example"></a><p class="title"><b>例 5.2. 使用定制存储类</b></p>
<div class="example-contents">
<p>
                   为了使用不同于<code>Zend_Auth_Storage_Session</code>的身份之久存储类，开发者可实现<code>Zend_Auth_Storage_Interface</code>：

                    </p>
<pre class="code">
class MyStorage implements Zend_Auth_Storage_Interface
{
    /**
     * Returns true if and only if storage is empty
     *
     * @throws Zend_Auth_Storage_Exception If it is impossible to
     *                                     determine whether storage
     *                                     is empty
     * @return boolean
     */
    public function isEmpty()
    {
        /**
         * @todo implementation
         */
    }

    /**
     * Returns the contents of storage
     *
     * Behavior is undefined when storage is empty.
     *
     * @throws Zend_Auth_Storage_Exception If reading contents from
     *                                     storage is impossible
     * @return mixed
     */
    public function read()
    {
        /**
         * @todo implementation
         */
    }

    /**
     * Writes $contents to storage
     *
     * @param  mixed $contents
     * @throws Zend_Auth_Storage_Exception If writing $contents to
     *                                     storage is impossible
     * @return void
     */
    public function write($contents)
    {
        /**
         * @todo implementation
         */
    }

    /**
     * Clears contents from storage
     *
     * @throws Zend_Auth_Storage_Exception If clearing contents from
     *                                     storage is impossible
     * @return void
     */
    public function clear()
    {
        /**
         * @todo implementation
         */
    }
}

                    </pre>
<p>

                </p>
<p>
                    为了使用这个定制的存储类，在认证查询被尝试前，<code>Zend_Auth::setStorage()</code>被调用：
                    </p>
<pre class="code">
// Instruct Zend_Auth to use the custom storage class
Zend_Auth::getInstance()-&gt;setStorage(new MyStorage());

/**
 * @todo Set up the auth adapter, $authAdapter
 */

// Authenticate, saving the result, and persisting the identity on
// success
$result = Zend_Auth::getInstance()-&gt;authenticate($authAdapter);

                    </pre>
<p>

                </p>
</div>
</div>
<br class="example-break">
</div>
</div>
<div class="sect2" title="5.1.4. 使用Zend_Auth">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.auth.introduction.using"></a>5.1.4. 使用Zend_Auth</h3></div></div></div>
<p>
            这里提供了两种方法使用Zend_Auth适配器：
            </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem"><p>
                    非直接地，通过<code>Zend_Auth::authenticate()</code>
                </p></li>
<li class="listitem"><p>
                    直接地，通过适配器的 <code>authenticate()</code> 方法
                </p></li>
</ol></div>
<p>
        </p>
<p>
            下面的例子通过<code>Zend_Auth</code>类来示例如何非直接地使用Zend_Auth适配器：
            </p>
<pre class="code">
// Get a reference to the singleton instance of Zend_Auth
require_once 'Zend/Auth.html';
$auth = Zend_Auth::getInstance();

// Set up the authentication adapter
$authAdapter = new MyAuthAdapter($username, $password);

// Attempt authentication, saving the result
$result = $auth-&gt;authenticate($authAdapter);

if (!$result-&gt;isValid()) {
    // Authentication failed; print the reasons why
    foreach ($result-&gt;getMessages() as $message) {
        echo "$message\n";
    }
} else {
    // Authentication succeeded; the identity ($username) is stored
    // in the session
    // $result-&gt;getIdentity() === $auth-&gt;getIdentity()
    // $result-&gt;getIdentity() === $username
}

            </pre>
<p>
        </p>
<p>
            一旦在一个请求里的认证被尝试，如上面的例子，检查一个成功的被认证的身份是否存在就是一个简单的匹配：
            </p>
<pre class="code">
$auth = Zend_Auth::getInstance();
if ($auth-&gt;hasIdentity()) {
    // Identity exists; get it
    $identity = $auth-&gt;getIdentity();
}

            </pre>
<p>
        </p>
<p>
            从持久存储空间出去一个身份，可简单地使用<code>clearIdentity()</code>方法。这将被典型地用作“logout”操作。
            </p>
<pre class="code">
Zend_Auth::getInstance()-&gt;clearIdentity();

            </pre>
<p>
        </p>
<p>
            当自动使用持久存储空间对特定的用例不合适，开发者可简单地忽略<code>Zend_Auth</code>类，直接使用适配器类。直接使用适配器类需要配置和准备适配器对象和调用它的<code>authenticate()</code>方法。适配器规范细节将在每个适配器的文档中讨论。下面的例子直接使用 <code>MyAuthAdapter</code>：
            </p>
<pre class="code">
// Set up the authentication adapter
$authAdapter = new MyAuthAdapter($username, $password);

// Attempt authentication, saving the result
$result = $authAdapter-&gt;authenticate();

if (!$result-&gt;isValid()) {
    // Authentication failed; print the reasons why
    foreach ($result-&gt;getMessages() as $message) {
        echo "$message\n";
    }
} else {
    // Authentication succeeded
    // $result-&gt;getIdentity() === $username
}

            </pre>
<p>
        </p>
</div>
</div>
</div>
<div class="revinfo"></div>


<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->