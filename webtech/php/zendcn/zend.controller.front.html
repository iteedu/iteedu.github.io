<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->



<div class="sect1" title="12.3. 前端控制器">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.controller.front"></a>12.3. 前端控制器</h2></div></div></div>
<div class="sect2" title="12.3.1. 概述">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.front.overview"></a>12.3.1. 概述</h3></div></div></div>
<p>
            <code>Zend_Controller_Front</code>实现了模型-视图-控制器 (MVC)应用程序的前端控制器模式。目的在于初始化请求环境，并路由到来的请求，接着分发任何发现的动作；收集所有的响应，在整个过程完成时就其返回。
        </p>
<p>
            <code>Zend_Controller_Front</code>也实现了单件（Singleton）模式，意味着任何时候，都只可能有一个有效实例。这使得它可以作为注册表，供分发过程中的其他对象引用。
        </p>
<p>
            <code>Zend_Controller_Front</code>自己注册了一个<a class="link" href="zend.controller.plugins.html" title="12.10. 插件">插件经纪人（plugin broker）</a>，允许插件观测它所触发的各种事件。大多数情况下，这将使得开发人员有机会裁剪站点的分发过程，而无需通过扩展前端控制器增加功能。
        </p>
<p>
            前端控制器最至少需要一个或多个包含<a class="link" href="zend.controller.action.html" title="12.7. 动作控制器">动作控制器</a>的目录的路径来完成工作。还有大量的方法可供调用，进一步裁剪前端控制器以及它的助手类环境。
        </p>
<div class="note" title="默认的行为"><table border="0" summary="Note: 默认的行为">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">默认的行为</th>
</tr>
<tr><td align="left" valign="top">
<p>
                默认地，前端控制器加载<a class="link" href="zend.controller.plugins.html#zend.controller.plugins.standard.errorhandler" title="12.10.5.2. Zend_Controller_Plugin_ErrorHandler">ErrorHandler</a>插件，以及<a class="link" href="zend.controller.actionhelpers.html#zend.controller.actionhelpers.viewrenderer" title="12.8.4.7. ViewRenderer">ViewRenderer</a>动作助手，分别为了简化控制器中的错误处理和视图渲染。
            </p>
<p>
                如需禁用<code>ErrorHandler</code>，调用<code>dispatch()</code>前执行下面代码：
            </p>
<pre class="code">
// Disable the ErrorHandler plugin:
$front-&gt;setParam('noErrorHandler', true);

            </pre>
<p>
                如需禁用<code>ViewRenderer</code>，调用<code>dispatch()</code>前执行下面代码：
            </p>
<pre class="code">
// Disable the ViewRenderer helper:
$front-&gt;setParam('noViewRenderer', true);

            </pre>
</td></tr>
</table></div>
</div>
<div class="sect2" title="12.3.2. 主要方法">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.front.methods.primary"></a>12.3.2. 主要方法</h3></div></div></div>
<p>
            前端控制器有很多建立其环境的访问器。但是，有三个是开启前端控制器功能的主要方法：
        </p>
<div class="sect3" title="12.3.2.1. getInstance()">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.front.methods.primary.getinstance"></a>12.3.2.1. getInstance()</h4></div></div></div>
<p>
                <code>getInstance()</code>方法用来获取前端控制器实例。因为前端控制器实现了单件模式，这可能是唯一创建前端控制器对象的方法。
            </p>
<pre class="code">
$front = Zend_Controller_Front::getInstance();

            </pre>
</div>
<div class="sect3" title="12.3.2.2. setControllerDirectory() 和 addControllerDirectory()">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.front.methods.primary.setcontrollerdirectory"></a>12.3.2.2. setControllerDirectory() 和 addControllerDirectory()</h4></div></div></div>
<p>
                <code>setControllerDirectory()</code>通知<a class="link" href="zend.controller.dispatcher.html" title="12.6. 分发器">分发器</a>到哪查找动作控制器<a class="link" href="zend.controller.action.html" title="12.7. 动作控制器">action controller</a>类文件。参数接受单一路径和模块/路径对关联数组。
            </p>
<p>
                例如：
            </p>
<pre class="code">
// Set the default controller directory:
$front-&gt;setControllerDirectory('../application/controllers');

// Set several module directories at once:
$front-&gt;setControllerDirectory(array(
    'default' =&gt; '../application/controllers',
    'blog'    =&gt; '../modules/blog/controllers',
    'news'    =&gt; '../modules/news/controllers',
));

// Add a 'foo' module directory:
$front-&gt;addControllerDirectory('../modules/foo/controllers', 'foo');

            </pre>
<div class="note" title="注意"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[注意]" src="images/note.png"></td>
<th align="left">注意</th>
</tr>
<tr><td align="left" valign="top"><p>
                    如果使用<code>addControllerDirectory()</code>时不带模块名，将会为<code>default</code>模块设定目录——如果目录已设定，就覆盖掉。
                </p></td></tr>
</table></div>
<p>
                可以通过<code>getControllerDirectory()</code>获取控制器目录的当前设置；它将返回一个模块/目录对关联数组。
            </p>
</div>
<div class="sect3" title="12.3.2.3. addModuleDirectory() and getModuleDirectory()">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.front.methods.primary.addmoduledirectory"></a>12.3.2.3. addModuleDirectory() and getModuleDirectory()</h4></div></div></div>
<p>
                前端控制器的一个功能是你可以
                <a class="link" href="zend.controller.modular.html" title="12.11. 使用传统的模块目录结构">定义一个模块目录结构
                </a>
                来创建独立的组件，被叫做“模块”。
            </p>
<p>
                每个模块位于自己的目录并和缺省模块的目录结构一样 － 例如，它至少
                有个 "controllers" 字目录和 "views" 子目录以及其它应用子目录。
            </p>
<p>
                <code>addModuleDirectory()</code> 让你传递一个包含一个或多个模块目录的目录名。
                然后进行扫描并把它们作为控制器目录添加到前端控制器。
            </p>
<p>
                然后，如果你想确定特定模块或当前模块路径，调用 <code>getModuleDirectory()</code>，
                可选地传递模块名来获得模块目录。
            </p>
</div>
<div class="sect3" title="12.3.2.4. dispatch()">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.front.methods.primary.dispatch"></a>12.3.2.4. dispatch()</h4></div></div></div>
<p>
                <code>dispatch(Zend_Controller_Request_Abstract $request = null, Zend_Controller_Response_Abstract $response = null)</code>完成前端控制器最繁重的工作。该方法带有可选的参数<a class="link" href="zend.controller.request.html" title="12.4. 请求对象">请求对象</a>和/或<a class="link" href="zend.controller.response.html" title="12.9. 响应对象">响应对象</a>，允许开发人员为每一个传入定制的对象。
            </p>
<p>
                        如果没有请求或者响应对象传入，<code>dispatch()</code>将检查先前注册的对象并使用，如果没有发现则创建默认的对象版本（它们两个都默认使用HTTP对象）。
            </p>
<p>
                        类似的，<code>dispatch()</code>先检查已注册的<a class="link" href="zend.controller.router.html" title="12.5. 标准路由器">路由器（router）</a>和<a class="link" href="zend.controller.dispatcher.html" title="12.6. 分发器">分发器（dispatcher）</a>对象，如果没有发现则实例化它们的默认版本。
            </p>
<p>
                        分发过程有三个不同的事件：
            </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>路由（Routing）</p></li>
<li class="listitem"><p>分发（Dispatching）</p></li>
<li class="listitem"><p>响应（Response）</p></li>
</ul></div>
<p>
                        路由只发生一次，当调用<code>dispatch()</code>时利用请求对象中的值。分发发生在一个循环中;请求可能指示	分发多个动作，或者控制器或插件可能重置请求对象，强制分发附加的动作。所有都完成后，前端控制器返回响应对象。
            </p>
</div>
<div class="sect3" title="12.3.2.5. run()">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.controller.front.methods.primary.run"></a>12.3.2.5. run()</h4></div></div></div>
<p>
                <code>Zend_Controller_Front::run($path)</code>是静态方法，只带一个参数，就是指向包含控制器的目录的路径。它首先通过<a class="link" href="zend.controller.front.html#zend.controller.front.methods.primary.getinstance" title="12.3.2.1. getInstance()">getInstance()</a>获取前端控制器实例，然后通过<a class="link" href="zend.controller.front.html#zend.controller.front.methods.primary.setcontrollerdirectory" title="12.3.2.2. setControllerDirectory() 和 addControllerDirectory()">setControllerDirectory()</a>注册传入的路径，最后<a class="link" href="zend.controller.front.html#zend.controller.front.methods.primary.dispatch" title="12.3.2.4. dispatch()">分发</a>。
            </p>
<p>
                        基本上，如果不要求定制前端控制器环境，<code>run()</code>是一个很方便的建立前端控制器环境的方法。
            </p>
<pre class="code">
// Instantiate front controller, set controller directory, and dispatch in one
// easy step:
Zend_Controller_Front::run('../application/controllers');

            </pre>
</div>
</div>
<div class="sect2" title="12.3.3. 环境访问器方法">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.front.methods.environment"></a>12.3.3. 环境访问器方法</h3></div></div></div>
<p>
                  除了上面所列的方法以外，还有很多访问器方法可以影响前端控制器环境 —— 因而也影响前端控制器代理（delegate）的类的环境。
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                    <code>resetInstance()</code>方法清除当前的所有设置。主要用来测试，不过，在希望将几个前端控制器连锁的地方也是很有用的（but it can also be used for instances where you wish to chain together multiple front controllers）。
                </p></li>
<li class="listitem"><p>
                    <code>(set|get)DefaultControllerName()</code>方法可以为默认的控制器指定另外一个名字（否则使用'index'），以及获取当前值。它们将代理<a class="link" href="zend.controller.dispatcher.html" title="12.6. 分发器">分发器</a>。
                </p></li>
<li class="listitem"><p>
                    <code>(set|get)DefaultAction()</code>方法可以为默认的动作指定另外一个名字（否则使用'index'）,以及获取当前值。它们将代理<a class="link" href="zend.controller.dispatcher.html" title="12.6. 分发器">分发器</a>。
                </p></li>
<li class="listitem"><p>
                    <code>(set|get)Request()</code>方法指定分发过程中使用的<a class="link" href="zend.controller.request.html" title="12.4. 请求对象">请求</a>类或对象，以及获取当前的请求对象。设置请求对象时，可以传入一个请求类的名字，该方法将加载类文件并创建实例。
                </p></li>
<li class="listitem">
<p>
                    <code>(set|get)Router()</code>方法指定分发过程中使用的<a class="link" href="zend.controller.router.html" title="12.5. 标准路由器">路由器</a>类或对象，以及获取当前对象。设置路由器时，可以传入一个路由器类的名字，该方法将加载类文件并创建实例。
                </p>
<p>
                             获取路由器对象的时候，首先检查是否已有一个，如果没有，创建默认的路由器实例（rewrite路由器）。
                </p>
</li>
<li class="listitem"><p>
                    <code>(set|get)BaseUrl()</code>方法指定路由请求时剥离（strip）的<a class="link" href="zend.controller.request.html#zend.controller.request.http.baseurl" title="12.4.2.2. 基地址和子目录">基地址（base URL）</a>，以及获取当前值。这个值将在路由前提供给路由器。
                        </p></li>
<li class="listitem">
<p>
                    <code>(set|get)Dispatcher()</code>方法指定分发过程中使用的<a class="link" href="zend.controller.dispatcher.html" title="12.6. 分发器">分发器</a>类或对象，以及获取当前对象。设定分发器对象时，可以传入一个分发器类的名字，该方法将加载类文件并创建实例。
                </p>
<p>
                              获取分发器对象时，首先检查是否已有一个存在，如果没有，将创建一个默认的分发器实例。
                </p>
</li>
<li class="listitem"><p>
                    <code>(set|get)Response()</code>方法指定分发过程中使用的<a class="link" href="zend.controller.response.html" title="12.9. 响应对象">响应</a>类或对象，已经获取当前对象。设定响应对象时，可以传入一个响应类的名字，该方法将加载类文件并创建实例。
                </p></li>
<li class="listitem"><p>
                    <code>registerPlugin(Zend_Controller_Plugin_Abstract $plugin, $stackIndex = null)</code>方法允许注册一个<a class="link" href="zend.controller.plugins.html" title="12.10. 插件">插件对象</a>。通过设置可选参数<code>$stackIndex</code>，插件执行的顺序。
                </p></li>
<li class="listitem"><p>
                    <code>unregisterPlugin($plugin)</code>方法移除<a class="link" href="zend.controller.plugins.html" title="12.10. 插件">插件对象</a>。<code>$plugin</code>可以是一个插件对象或者代表移除插件类的字符串。
                </p></li>
<li class="listitem">
<p>
                    <code>throwExceptions($flag)</code>方法用来开启或者关闭分发过程中抛出异常的能力。默认的，异常引起并放置在<a class="link" href="zend.controller.response.html" title="12.9. 响应对象">响应对象</a>中；开启<code>throwExceptions()</code>将覆盖这一行为。
                </p>
<p>
                              想知道更多信息的话，请阅读<a class="xref" href="zend.controller.exceptions.html" title="12.12. MVC 异常">第 12.12 节 “MVC 异常”</a>。
                </p>
</li>
<li class="listitem">
<p>
                    <code>returnResponse($flag)</code>方法通知前端控制器是否从<code>dispatch()</code>中返回请求对象（<code>true</code>），否则自动发送响应对象（<code>false</code>—）。默认的，响应对象被自动发送（通过调用<code>Zend_Controller_Response_Abstract::sendResponse()</code>）；开启<code>returnResponse()</code>将覆盖这一行为。
                </p>
<p>
                              返回响应对象的原因包括希望在发送响应前检查异常，记录响应的各种属性（例如消息头）等等。
                </p>
</li>
</ul></div>
</div>
<div class="sect2" title="12.3.4. 前端控制器参数">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.front.methods.params"></a>12.3.4. 前端控制器参数</h3></div></div></div>
<p>
                  介绍里曾提到前端控制器可以用作各种控制器组件的注册表。它通过一个"param"家族的方法来做到这些。这些方法允许通过前端控制器注册任意类型的数据 —— 对象和变量，可以在分发链中的任何时候获取。这些变量被传递到路由器，分发器，以及动作控制器。这些方法包括：
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                    <code>setParam($name, $value)</code>方法设定值为<code>$value</code>的单个参数<code>$name</code>。
                </p></li>
<li class="listitem"><p>
                    <code>setParams(array $params)</code>方法通过关联数组一次设定多个参数。
                </p></li>
<li class="listitem"><p>
                    <code>getParam($name)</code>方法通过<code>$name</code>标识符获取单个参数。
                </p></li>
<li class="listitem"><p>
                    <code>getParams()</code>方法一次获取整个参数列表。
                </p></li>
<li class="listitem"><p>
                    <code>clearParams()</code>方法可以清空一个参数（传入单个字符串标识符），清空多个参数（传入字符串标识符数组），清空整个参数栈（不传入参数）。
                </p></li>
</ul></div>
<p>
                  有几个预定义的参数可供设定，它们在分发链中有特别的用途：
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
                    <code>useDefaultControllerAlways</code>用来提示 <a class="link" href="zend.controller.dispatcher.html" title="12.6. 分发器">分发器</a>遇到无法分发的请求时使用默认模块的默认控制器。这默认是关闭的。
                </p>
<p>
                    阅读<a class="xref" href="zend.controller.exceptions.html#zend.controller.exceptions.internal" title="12.12.3. 可能遭遇的MVC异常">第 12.12.3 节 “可能遭遇的MVC异常”</a>获得使用该设定的更详尽信息。
                </p>
</li>
<li class="listitem"><p>
                    <code>disableOutputBuffering</code>用来提示 is used to hint to <a class="link" href="zend.controller.dispatcher.html" title="12.6. 分发器">分发器</a>不使用输出缓冲来捕捉动作控制器产生的输出。默认的，分发器捕捉任何输出并追加到响应对象的主体内容。
                </p></li>
<li class="listitem"><p>
                    <code>noViewRenderer</code>用来禁用<a class="link" href="zend.controller.actionhelpers.html#zend.controller.actionhelpers.viewrenderer" title="12.8.4.7. ViewRenderer">ViewRenderer</a>。设定该参数为true可以禁用该助手。
                </p></li>
<li class="listitem"><p>
                    <code>noErrorHandler</code> 用来禁用<a class="link" href="zend.controller.plugins.html#zend.controller.plugins.standard.errorhandler" title="12.10.5.2. Zend_Controller_Plugin_ErrorHandler">错误处理器插件</a>。设定该参数为true可以禁用该插件。
                </p></li>
</ul></div>
</div>
<div class="sect2" title="12.3.5. 继承前端控制器">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.controller.front.subclassing"></a>12.3.5. 继承前端控制器</h3></div></div></div>
<p>
                  要继承前端控制器，至少需要覆盖<code>getInstance()</code>方法：
        </p>
<pre class="code">
class My_Controller_Front extends Zend_Controller_Front
{
    public static function getInstance()
    {
        if (null === self::$_instance) {
            self::$_instance = new self();
        }

        return self::$_instance;
    }
}

        </pre>
<p>
                  覆盖<code>getInstance()</code>保证后面调用<code>Zend_Controller_Front::getInstance()</code>会返回子类的实例，而不是<code>Zend_Controller_Front</code>实例 —— 这对于一些可替换的路由器和视图助手非常有用。
        </p>
<p>
                  通常不需要继承前端控制器，除非你需要增加新的功能（比如，一个插件自动加载器，或者一个方法来指定动作助手路径）。你想要改动的地方可能包括修改控制器目录的存储方式，使用的默认路由器以及分发器。
        </p>
</div>
</div>
<div class="revinfo"></div>


<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->