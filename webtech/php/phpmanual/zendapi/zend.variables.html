
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<TABLE BORDER="0" WIDTH="100%" HEIGHT="100%" CELLSPACING="0" CELLPADDING="0"><TR><TD COLSPAN="3"><DIV CLASS="NAVHEADER"><TABLE BGCOLOR="#CCCCFF" BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR><TD><TABLE  SUMMARY="Header navigation table" WIDTH="100%" BORDER="0" CELLPADDING="3" CELLSPACING="0"><TR><TH  COLSPAN="3" ALIGN="center">PHP 手册</TH></TR><TR><TD  WIDTH="10%" ALIGN="left" VALIGN="bottom"><A  HREF="zend.arguments.html" ACCESSKEY="P">后退</A></TD><TD  WIDTH="80%" ALIGN="center" VALIGN="bottom">章 45. Zend API：深入 PHP 内核</TD><TD  WIDTH="10%" ALIGN="right" VALIGN="bottom"><A  HREF="zend.copy-constructor.html" ACCESSKEY="N">前进</A></TD></TR></TABLE></TD></TR><TR BGCOLOR="#333366"><TD><IMG SRC="../spacer.gif" BORDER="0" WIDTH="1" HEIGHT="1"><BR></TD></TR></TABLE></DIV></TD></TR><TR><TD><IMG SRC="../spacer.gif" WIDTH="10" HEIGHT="1"></TD><TD HEIGHT="100%" VALIGN="TOP" WIDTH="100%"><BR><DIV  CLASS="sect1"><H1  CLASS="sect1"><A  NAME="zend.variables">Creating Variables</A></H1><P>&#13;   When exchanging data from your own extensions with PHP scripts, one
   of the most important issues is the creation of variables. This
   section shows you how to deal with the variable types that PHP
   supports.
  </P><DIV  CLASS="sect2"><H2  CLASS="sect2"><A  NAME="zend.variables.overview">Overview</A></H2><P>&#13;    To create new variables that can be seen "from the outside" by the
    executing script, you need to allocate a new <VAR  CLASS="envar">zval</VAR>
    container, fill this container with meaningful values, and then
    introduce it to Zend's internal symbol table. This basic process
    is common to all variable creations: 
   </P><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_variable; 

/* allocate and initialize new container */
MAKE_STD_ZVAL(new_variable); 

/* set type and variable contents here, see the following sections */ 

/* introduce this variable by the name "new_variable_name" into the symbol table */
ZEND_SET_SYMBOL(EG(active_symbol_table), "new_variable_name", new_variable); 

/* the variable is now accessible to the script by using $new_variable_name */</PRE></TD></TR></TABLE><P>&#13;    The macro <VAR  CLASS="literal">MAKE_STD_ZVAL</VAR> allocates a new
    <VAR  CLASS="envar">zval</VAR> container using <VAR  CLASS="literal">ALLOC_ZVAL</VAR>
    and initializes it using <VAR  CLASS="literal">INIT_ZVAL</VAR>. As
    implemented in Zend at the time of this writing,
    <SPAN  CLASS="emphasis"><I  CLASS="emphasis">initializing</I></SPAN> means setting the reference
    count to <VAR  CLASS="literal">1</VAR> and clearing the
    <VAR  CLASS="envar">is_ref</VAR> flag, but this process could be extended
    later - this is why it's a good idea to keep using
    <VAR  CLASS="literal">MAKE_STD_ZVAL</VAR> instead of only using
    <VAR  CLASS="literal">ALLOC_ZVAL</VAR>. If you want to optimize for speed
    (and you don't have to explicitly initialize the
    <VAR  CLASS="envar">zval</VAR> container here), you can use
    <VAR  CLASS="literal">ALLOC_ZVAL</VAR>, but this isn't recommended because
    it doesn't ensure data integrity.
   </P><P>&#13;    <VAR  CLASS="literal">ZEND_SET_SYMBOL</VAR> takes care of introducing the
    new variable to Zend's symbol table. This macro checks whether the
    value already exists in the symbol table and converts the new
    symbol to a reference if so (with automatic deallocation of the
    old <VAR  CLASS="envar">zval</VAR> container). This is the preferred method
    if speed is not a crucial issue and you'd like to keep memory
    usage low.
   </P><P>&#13;    Note that <VAR  CLASS="literal">ZEND_SET_SYMBOL</VAR> makes use of the Zend
    executor globals via the macro <VAR  CLASS="literal">EG</VAR>. By
    specifying <VAR  CLASS="literal">EG(active_symbol_table)</VAR>, you get access to the
    currently active symbol table, dealing with the active, local scope. The local
    scope may differ depending on whether the function was invoked from
    within a function.
   </P><P>&#13;    If you need to optimize for speed and don't care about optimal memory
    usage, you can omit the check for an existing variable with the same value and instead
    force insertion into the symbol table by using
    <A  HREF="zend-api.zend-hash-update.html"><B  CLASS="function">zend_hash_update()</B></A>: 
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_variable;

/* allocate and initialize new container */
MAKE_STD_ZVAL(new_variable);

/* set type and variable contents here, see the following sections */

/* introduce this variable by the name "new_variable_name" into the symbol table */
zend_hash_update(
    EG(active_symbol_table),
    "new_variable_name",
    strlen("new_variable_name") + 1,
    &#38;new_variable,
    sizeof(zval *),
    NULL
);</PRE></TD></TR></TABLE>
    This is actually the standard method used in most modules.
   <P>&#13;    The variables generated with the snippet above will always be of local
    scope, so they reside in the context in which the function has been called. To
    create new variables in the global scope, use the same method
    but refer to another symbol table: 
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_variable;
     
// allocate and initialize new container
MAKE_STD_ZVAL(new_variable);

//
// set type and variable contents here
//

// introduce this variable by the name "new_variable_name" into the global symbol table
ZEND_SET_SYMBOL(&#38;EG(symbol_table), "new_variable_name", new_variable);</PRE></TD></TR></TABLE>
    The macro <VAR  CLASS="literal">ZEND_SET_SYMBOL</VAR> is now being
    called with a reference to the main, global symbol table by referring
    <VAR  CLASS="literal">EG(symbol_table)</VAR>.
   <P>&#13;    <SPAN  CLASS="emphasis"><I  CLASS="emphasis">Note:</I></SPAN> The <VAR  CLASS="envar">active_symbol_table</VAR>
    variable is a pointer, but <VAR  CLASS="envar">symbol_table</VAR> is not.
    This is why you have to use
    <VAR  CLASS="literal">EG(active_symbol_table)</VAR> and
    <VAR  CLASS="literal">&#38;EG(symbol_table)</VAR> as parameters to
    <VAR  CLASS="literal">ZEND_SET_SYMBOL</VAR> - it requires a pointer.
   </P><P>&#13;    Similarly, to get a more efficient version, you can hardcode the
    symbol table update: 
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_variable;

// allocate and initialize new container
MAKE_STD_ZVAL(new_variable);

//
// set type and variable contents here
//

// introduce this variable by the name "new_variable_name" into the global symbol table
zend_hash_update(
    &#38;EG(symbol_table),
    "new_variable_name",
    strlen("new_variable_name") + 1,
    &#38;new_variable,
    sizeof(zval *),
    NULL
);</PRE></TD></TR></TABLE>
    <A  HREF="zend.variables.html#example.variable-scopes">例子 45-9</A> shows a sample source that
    creates two variables - <VAR  CLASS="envar">local_variable</VAR> with a local scope
    and <VAR  CLASS="envar">global_variable</VAR> with a global scope (see Figure 9.7). 
    The full example can be found on the CD-ROM.
   <P>&#13;    Note: You can see that the global variable is actually not accessible from
    within the function. This is because it's not imported into the local scope
    using <VAR  CLASS="literal">global $global_variable;</VAR> in the PHP source. 
   </P><TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE"><TR><TD><DIV  CLASS="example"><A  NAME="example.variable-scopes"></A><P><B>例子 45-9. Creating variables with different scopes.</B></P><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">ZEND_FUNCTION(variable_creation)
{
    zval *new_var1, *new_var2;

    MAKE_STD_ZVAL(new_var1);
    MAKE_STD_ZVAL(new_var2);

    ZVAL_LONG(new_var1, 10);
    ZVAL_LONG(new_var2, 5);

    ZEND_SET_SYMBOL(EG(active_symbol_table), "local_variable", new_var1);
    ZEND_SET_SYMBOL(&#38;EG(symbol_table), "global_variable", new_var2);

    RETURN_NULL();

}</PRE></TD></TR></TABLE><P><IMG  SRC="../figures/zend.06-variable-creation.png"></P></DIV></TD></TR></TABLE></DIV><DIV  CLASS="sect2"><H2  CLASS="sect2"><A  NAME="zend.variables.long">Longs (Integers)</A></H2><P>Now let's get to the assignment of data to variables, starting with
    longs. Longs are PHP's integers and are very simple to store. Looking at
    the <VAR  CLASS="envar">zval.value</VAR> container structure discussed earlier in this
    chapter, you can see that the long data type is directly contained in the union,
    namely in the <VAR  CLASS="envar">lval</VAR> field. The corresponding 
    <VAR  CLASS="envar">type</VAR> value for longs is <VAR  CLASS="literal">IS_LONG</VAR> 
    (see <A  HREF="zend.variables.html#example.create-long">例子 45-10</A>). 
    <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE"><TR><TD><DIV  CLASS="example"><A  NAME="example.create-long"></A><P><B>例子 45-10. Creation of a long.</B></P><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_long;

MAKE_STD_ZVAL(new_long);

new_long-&#62;type = IS_LONG;
new_long-&#62;value.lval = 10;</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
    Alternatively, you can use the macro <VAR  CLASS="literal">ZVAL_LONG</VAR>:
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_long;

MAKE_STD_ZVAL(new_long);
ZVAL_LONG(new_long, 10);</PRE></TD></TR></TABLE>
   </DIV><DIV  CLASS="sect2"><H2  CLASS="sect2"><A  NAME="zend.variables.float">Doubles (Floats)</A></H2><P>&#13;    Doubles are PHP's floats and are as easy to assign as longs, because their value
    is also contained directly in the union. The member in the 
    <VAR  CLASS="envar">zval.value</VAR> container is <VAR  CLASS="envar">dval</VAR>; 
    the corresponding type is <VAR  CLASS="literal">IS_DOUBLE</VAR>. 
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_double;

MAKE_STD_ZVAL(new_double);

new_double-&#62;type = IS_DOUBLE;
new_double-&#62;value.dval = 3.45;</PRE></TD></TR></TABLE>
    Alternatively, you can use the macro <VAR  CLASS="literal">ZVAL_DOUBLE</VAR>:
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_double;

MAKE_STD_ZVAL(new_double);
ZVAL_DOUBLE(new_double, 3.45);</PRE></TD></TR></TABLE>
   </DIV><DIV  CLASS="sect2"><H2  CLASS="sect2"><A  NAME="zend.variables.string">Strings</A></H2><P>&#13;    Strings need slightly more effort. As mentioned earlier, all strings
    that will be associated with Zend's internal data structures need to be
    allocated using Zend's own memory-management functions. Referencing of static
    strings or strings allocated with standard routines is not allowed. To assign
    strings, you have to access the structure <VAR  CLASS="envar">str</VAR> in
    the <VAR  CLASS="envar">zval.value</VAR> container. The corresponding type
    is <VAR  CLASS="literal">IS_STRING</VAR>:
<TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_string;
char *string_contents = "This is a new string variable";

MAKE_STD_ZVAL(new_string);

new_string-&#62;type = IS_STRING;
new_string-&#62;value.str.len = strlen(string_contents);
new_string-&#62;value.str.val = estrdup(string_contents);</PRE></TD></TR></TABLE>
    Note the usage of Zend's <B  CLASS="function">estrdup()</B> here.
    Of course, you can also use the predefined macro
    <VAR  CLASS="literal">ZVAL_STRING</VAR>:
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_string;
char *string_contents = "This is a new string variable";

MAKE_STD_ZVAL(new_string);
ZVAL_STRING(new_string, string_contents, 1);</PRE></TD></TR></TABLE>
    <VAR  CLASS="literal">ZVAL_STRING</VAR> accepts a third parameter that
    indicates whether the supplied string contents should be duplicated (using
    <B  CLASS="function">estrdup()</B>). Setting this parameter
    to <VAR  CLASS="literal">1</VAR> causes the string to be
    duplicated; <VAR  CLASS="literal">0</VAR> simply uses the supplied pointer for the
    variable contents. This is most useful if you want to create a new variable
    referring to a string that's already allocated in Zend internal memory.
   <P>&#13;    If you want to truncate the string at a certain position or you
    already know its length, you can use <VAR  CLASS="literal">ZVAL_STRINGL(zval,
     string, length, duplicate)</VAR>, which accepts an explicit
    string length to be set for the new string. This macro is faster
    than <VAR  CLASS="literal">ZVAL_STRING</VAR> and also binary-safe.
   </P><P>&#13;    To create empty strings, set the string length to <VAR  CLASS="literal">0</VAR> and
    use <VAR  CLASS="literal">empty_string</VAR> as contents: 
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">new_string-&#62;type = IS_STRING;
new_string-&#62;value.str.len = 0;
new_string-&#62;value.str.val = empty_string;</PRE></TD></TR></TABLE>
    Of course, there's a macro for this as
    well (<VAR  CLASS="literal">ZVAL_EMPTY_STRING</VAR>):
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">MAKE_STD_ZVAL(new_string);
ZVAL_EMPTY_STRING(new_string);</PRE></TD></TR></TABLE>
   </DIV><DIV  CLASS="sect2"><H2  CLASS="sect2"><A  NAME="zend.variables.boolean">Booleans</A></H2><P>&#13;    Booleans are created just like longs, but have the
    type <VAR  CLASS="literal">IS_BOOL</VAR>. Allowed values in
    <VAR  CLASS="envar">lval</VAR> are <VAR  CLASS="literal">0</VAR> and <VAR  CLASS="literal">1</VAR>:
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_bool;

MAKE_STD_ZVAL(new_bool);

new_bool-&#62;type = IS_BOOL;
new_bool-&#62;value.lval = 1;</PRE></TD></TR></TABLE>
    The corresponding macros for this type
    are <VAR  CLASS="literal">ZVAL_BOOL</VAR> (allowing specification of the value) as well
    as <VAR  CLASS="literal">ZVAL_TRUE</VAR> and <VAR  CLASS="literal">ZVAL_FALSE</VAR> (which
    explicitly set the value to <VAR  CLASS="literal">TRUE</VAR> and <VAR  CLASS="literal">FALSE</VAR>,
    respectively).
   </DIV><DIV  CLASS="sect2"><H2  CLASS="sect2"><A  NAME="zend.variables.array">Arrays</A></H2><P>&#13;    Arrays are stored using Zend's internal hash tables, which can be
    accessed using the <B  CLASS="function">zend_hash_*()</B> API. For every
    array that you want to create, you need a new hash table handle,
    which will be stored in the <VAR  CLASS="envar">ht</VAR> member of the
    <VAR  CLASS="envar">zval.value</VAR> container.
   </P><P>&#13;    There's a whole API solely for the creation of arrays, which is extremely
    handy. To start a new array, you call
    <A  HREF="zend-api.array-init.html"><B  CLASS="function">array_init()</B></A>. 
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_array;

MAKE_STD_ZVAL(new_array);

array_init(new_array);</PRE></TD></TR></TABLE>
    <A  HREF="zend-api.array-init.html"><B  CLASS="function">array_init()</B></A> always returns <VAR  CLASS="literal">SUCCESS</VAR>.
   <P>&#13;    To add new elements to the array, you can use numerous functions,
    depending on what you want to do. 
    <A  HREF="zend.variables.html#tab.api-assoc-arrays">表格 45-8</A>,
    <A  HREF="zend.variables.html#tab.api-indexed-arrays">表格 45-9</A> and
    <A  HREF="zend.variables.html#tab.api-indexed-array-2">表格 45-10</A>
    describe these functions. All functions return
    <VAR  CLASS="literal">FAILURE</VAR> on failure and
    <VAR  CLASS="literal">SUCCESS</VAR> on success.
   </P><DIV  CLASS="table"><A  NAME="tab.api-assoc-arrays"></A><P><B>表格 45-8. Zend's API for Associative Arrays</B></P><TABLE  BORDER="1" CLASS="CALSTABLE"><COL  WIDTH="1*" TITLE="col1"><COL  WIDTH="1*" TITLE="col2"><TBODY><TR><TD>Function</TD><TD>Description</TD></TR><TR><TD>&#13;         <B  CLASS="function">add_assoc_long(zval *array, char *key, long n);()</B>
        </TD><TD>Adds an element of type <VAR  CLASS="literal">long</VAR>.</TD></TR><TR><TD>&#13;         <B  CLASS="function">add_assoc_unset(zval *array, char *key);()</B></TD><TD>Adds an unset element.</TD></TR><TR><TD>&#13;         <B  CLASS="function">add_assoc_bool(zval *array, char *key, int b);()</B>
        </TD><TD>Adds a Boolean element.</TD></TR><TR><TD>&#13;         <B  CLASS="function">add_assoc_resource(zval *array, char *key, int r);()</B>
        </TD><TD>Adds a resource to the array.</TD></TR><TR><TD>&#13;         <B  CLASS="function">add_assoc_double(zval *array, char *key, double d);()</B>
        </TD><TD>Adds a floating-point value.</TD></TR><TR><TD>&#13;         <B  CLASS="function">add_assoc_string(zval *array, char *key, char *str, int duplicate);()</B>
        </TD><TD>&#13;         Adds a string to the array. The
         flag <VAR  CLASS="envar">duplicate</VAR> specifies whether the string contents have to be
         copied to Zend internal memory.
        </TD></TR><TR><TD>&#13;         <B  CLASS="function">&#13;          add_assoc_stringl(zval *array, char *key, char *str, uint length, int duplicate);
         ()</B>
        </TD><TD>&#13;         Adds a string with the desired length <VAR  CLASS="envar">length</VAR>
         to the array. Otherwise, behaves like
         <A  HREF="zend-api.add-assoc-string.html"><B  CLASS="function">add_assoc_string()</B></A>.
        </TD></TR><TR><TD><B  CLASS="function">add_assoc_zval(zval *array, char *key, zval *value);()</B></TD><TD>Adds a zval to the array.  Useful for adding other arrays, objects, streams, etc...</TD></TR></TBODY></TABLE></DIV><DIV  CLASS="table"><A  NAME="tab.api-indexed-arrays"></A><P><B>表格 45-9. Zend's API for Indexed Arrays, Part 1</B></P><TABLE  BORDER="1" CLASS="CALSTABLE"><COL  WIDTH="1*" TITLE="col1"><COL  WIDTH="1*" TITLE="col2"><TBODY><TR><TD>Function</TD><TD>Description</TD></TR><TR><TD><B  CLASS="function">add_index_long(zval *array, uint idx, long
          n);()</B></TD><TD>Adds an element of type <VAR  CLASS="literal">long</VAR>.</TD></TR><TR><TD><B  CLASS="function">add_index_unset(zval *array, uint
          idx);()</B></TD><TD>Adds an unset element.</TD></TR><TR><TD><B  CLASS="function">add_index_bool(zval *array, uint idx, int
          b);()</B></TD><TD>Adds a Boolean element.</TD></TR><TR><TD><B  CLASS="function">add_index_resource(zval *array, uint idx, int
          r);()</B></TD><TD>Adds a resource to the array.</TD></TR><TR><TD><B  CLASS="function">add_index_double(zval *array, uint idx, double
          d);()</B></TD><TD>Adds a floating-point value.</TD></TR><TR><TD><B  CLASS="function">add_index_string(zval *array, uint idx, char
          *str, int duplicate);()</B></TD><TD>Adds a string to the array. The
         flag <VAR  CLASS="envar">duplicate</VAR> specifies whether the string contents have to be
         copied to Zend internal memory.</TD></TR><TR><TD><B  CLASS="function">add_index_stringl(zval *array, uint idx, char
          *str, uint length, int duplicate);()</B></TD><TD>Adds a string with the desired
         length <VAR  CLASS="envar">length</VAR> to the array. This function is faster and binary-safe. Otherwise, behaves like <B  CLASS="function">add_index_string()()</B>.</TD></TR><TR><TD><B  CLASS="function">add_index_zval(zval *array, uint idx, zval *value);()</B></TD><TD>Adds a zval to the array.  Useful for adding other arrays, objects, streams, etc...</TD></TR></TBODY></TABLE></DIV><DIV  CLASS="table"><A  NAME="tab.api-indexed-array-2"></A><P><B>表格 45-10. Zend's API for Indexed Arrays, Part 2</B></P><TABLE  BORDER="1" CLASS="CALSTABLE"><COL  WIDTH="1*" TITLE="col1"><COL  WIDTH="1*" TITLE="col2"><TBODY><TR><TD>Function</TD><TD>Description</TD></TR><TR><TD><B  CLASS="function">add_next_index_long(zval *array, long
          n);()</B></TD><TD>Adds an element of type <VAR  CLASS="literal">long</VAR>.</TD></TR><TR><TD><B  CLASS="function">add_next_index_unset(zval
          *array);()</B></TD><TD>Adds an unset element.</TD></TR><TR><TD><B  CLASS="function">add_next_index_bool(zval *array, int
          b);()</B></TD><TD>Adds a Boolean element.</TD></TR><TR><TD><B  CLASS="function">add_next_index_resource(zval *array, int
          r);()</B></TD><TD>Adds a resource to the array.</TD></TR><TR><TD><B  CLASS="function">add_next_index_double(zval *array, double
          d);()</B></TD><TD>Adds a floating-point value.</TD></TR><TR><TD><B  CLASS="function">add_next_index_string(zval *array, char *str,
          int duplicate);()</B></TD><TD>Adds a string to the array. The
         flag <VAR  CLASS="envar">duplicate</VAR> specifies whether the string contents have to be
         copied to Zend internal memory.</TD></TR><TR><TD><B  CLASS="function">add_next_index_stringl(zval *array, char *str,
          uint length, int duplicate);()</B></TD><TD>Adds a string with the desired
         length <VAR  CLASS="envar">length</VAR> to the array. This function is faster and binary-safe. Otherwise, behaves like <B  CLASS="function">add_index_string()()</B>.</TD></TR><TR><TD><B  CLASS="function">add_next_index_zval(zval *array, zval *value);()</B></TD><TD>Adds a zval to the array.  Useful for adding other arrays, objects, streams, etc...</TD></TR></TBODY></TABLE></DIV><P>&#13;    All these functions provide a handy abstraction to Zend's internal hash
    API. Of course, you can also use the hash functions directly - for example, if
    you already have a <VAR  CLASS="envar">zval</VAR> container allocated that you want to 
    insert into an array. This is done using <B  CLASS="function">zend_hash_update()()</B>
    for associative arrays (see <A  HREF="zend.variables.html#example.array-add-assoc">例子 45-11</A>) and 
    <B  CLASS="function">zend_hash_index_update()</B> for indexed arrays 
    (see <A  HREF="zend.variables.html#example.array-add-indexed">例子 45-12</A>): 
    <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE"><TR><TD><DIV  CLASS="example"><A  NAME="example.array-add-assoc"></A><P><B>例子 45-11. Adding an element to an associative array.</B></P><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_array, *new_element;
char *key = "element_key";
      
MAKE_STD_ZVAL(new_array);
MAKE_STD_ZVAL(new_element);

array_init(new_array);

ZVAL_LONG(new_element, 10);

if(zend_hash_update(new_array-&#62;value.ht, key, strlen(key) + 1, (void *)&#38;new_element, sizeof(zval *), NULL) == FAILURE)
{
    // do error handling here
}</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE> 
    <TABLE  WIDTH="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0" CLASS="EXAMPLE"><TR><TD><DIV  CLASS="example"><A  NAME="example.array-add-indexed"></A><P><B>例子 45-12. Adding an element to an indexed array.</B></P><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_array, *new_element;
int key = 2;

MAKE_STD_ZVAL(new_array);
MAKE_STD_ZVAL(new_element);

array_init(new_array);

ZVAL_LONG(new_element, 10);

if(zend_hash_index_update(new_array-&#62;value.ht, key, (void *)&#38;new_element, sizeof(zval *), NULL) == FAILURE)
{
    // do error handling here
}</PRE></TD></TR></TABLE></DIV></TD></TR></TABLE>
   <P>&#13;    To emulate the functionality of
    <B  CLASS="function">add_next_index_*()</B>, you can use this:
   </P><TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zend_hash_next_index_insert(ht, zval **new_element, sizeof(zval *), NULL)</PRE></TD></TR></TABLE><P>&#13;    <SPAN  CLASS="emphasis"><I  CLASS="emphasis">Note:</I></SPAN> To return arrays from a function, use <A  HREF="zend-api.array-init.html"><B  CLASS="function">array_init()</B></A> and
    all following actions on the predefined variable <VAR  CLASS="envar">return_value</VAR>
    (given as argument to your exported function; see the earlier discussion of the call interface). You do not have to use
    <VAR  CLASS="literal">MAKE_STD_ZVAL</VAR> on this.
   </P><P>&#13;    <SPAN  CLASS="emphasis"><I  CLASS="emphasis">Tip:</I></SPAN> To avoid having to
    write <VAR  CLASS="literal">new_array-&#62;value.ht</VAR> every time, you can
    use <VAR  CLASS="literal">HASH_OF(new_array)</VAR>, which is also recommended for
    compatibility and style reasons.
   </P></DIV><DIV  CLASS="sect2"><H2  CLASS="sect2"><A  NAME="zend.variables.object">Objects</A></H2><P>&#13;    Since objects can be converted to arrays (and vice versa), you
    might have already guessed that they have a lot of similarities to
    arrays in PHP. Objects are maintained with the same hash
    functions, but there's a different API for creating them.
   </P><P>&#13;    To initialize an object, you use the
    function <A  HREF="zend-api.object-init.html"><B  CLASS="function">object_init()</B></A>: 
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">zval *new_object;

MAKE_STD_ZVAL(new_object);

if(object_init(new_object) != SUCCESS)
{
    // do error handling here
}</PRE></TD></TR></TABLE>
    You can use the functions described in 
    <A  HREF="zend.variables.html#tab.object-creation">表格 45-11</A> 
    to add members to your object.
   <DIV  CLASS="table"><A  NAME="tab.object-creation"></A><P><B>表格 45-11. Zend's API for Object Creation</B></P><TABLE  BORDER="1" CLASS="CALSTABLE"><COL  WIDTH="1.24*" TITLE="col1"><COL  WIDTH="1*" TITLE="col2"><TBODY><TR><TD>Function</TD><TD>Description</TD></TR><TR><TD><B  CLASS="function">add_property_long(zval *object, char *key, long
          l);()</B></TD><TD>Adds a long to the object.</TD></TR><TR><TD><B  CLASS="function">add_property_unset(zval *object, char
          *key);()</B></TD><TD>Adds an unset property to the object.</TD></TR><TR><TD><B  CLASS="function">add_property_bool(zval *object, char *key, int
          b);()</B></TD><TD>Adds a Boolean to the object.</TD></TR><TR><TD><B  CLASS="function">add_property_resource(zval *object, char *key,
          long r);()</B></TD><TD>Adds a resource to the object.</TD></TR><TR><TD><B  CLASS="function">add_property_double(zval *object, char *key,
          double d);()</B></TD><TD>Adds a double to the object.</TD></TR><TR><TD><B  CLASS="function">add_property_string(zval *object, char *key,
          char *str, int duplicate);()</B></TD><TD>Adds a string to the object.</TD></TR><TR><TD><B  CLASS="function">add_property_stringl(zval *object, char *key,
          char *str, uint length, int duplicate);()</B></TD><TD>Adds a string of the specified length to the object. This
         function is faster than <A  HREF="zend-api.add-property-string.html"><B  CLASS="function">add_property_string()</B></A> and also
         binary-safe.</TD></TR><TR><TD>&#13;         <B  CLASS="function">add_property_zval(zval *obect, char *key, zval *container):()</B>
        </TD><TD>&#13;         Adds a <VAR  CLASS="literal">zval</VAR> container to the object. This is useful if you
         have to add properties which aren't simple types like integers or strings but
         arrays or other objects.
        </TD></TR></TBODY></TABLE></DIV></DIV><DIV  CLASS="sect2"><H2  CLASS="sect2"><A  NAME="zend.variables.resource">Resources</A></H2><P>&#13;		Resources are a special kind of data type in PHP. The term
		<SPAN  CLASS="emphasis"><I  CLASS="emphasis">resources</I></SPAN> doesn't really refer to any special
		kind of data, but to an abstraction method for maintaining any kind
		of information. Resources are kept in a special resource list within
		Zend. Each entry in the list has a correspondending type definition
		that denotes the kind of resource to which it refers. Zend then
		internally manages all references to this resource. Access to a
		resource is never possible directly - only via a provided API. As soon
		as all references to a specific resource are lost, a corresponding
		shutdown function is called.
	</P><P>&#13;		For example, resources are used to store database links and file
		descriptors. The <SPAN  CLASS="emphasis"><I  CLASS="emphasis">de facto</I></SPAN> standard implementation
		can be found in the MySQL module, but other modules such as the Oracle
		module also make use of resources.
		<DIV  CLASS="note"><BLOCKQUOTE  CLASS="note"><P><B>注: </B>
      In fact, a resource can be a pointer to anything you need to
      handle in your functions (e.g. pointer to a structure) and the
      user only has to pass a single resource variable to your
      function.
     </P></BLOCKQUOTE></DIV>
   <P>&#13;		To create a new resource you need to register a resource
		destruction handler for it. Since you can store any kind of data as a
		resource, Zend needs to know how to free this resource if its not longer
		needed. This works by registering your own resource destruction handler
		to Zend which in turn gets called by Zend whenever your resource can be
		freed (whether manually or automatically).  Registering your resource
		handler within Zend returns you the <SPAN  CLASS="strong"><B  CLASS="emphasis">resource
		type handle</B></SPAN> for that resource.  This handle is needed
		whenever you want to access a resource of this type later and is most
		of time stored in a global static variable within your extension.
		There is no need to worry about thread safety here because you only
		register your resource handler once during module initialization.
   </P><P>&#13;		The Zend function to register your resource handler is defined as:
		<TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">ZEND_API int zend_register_list_destructors_ex(rsrc_dtor_func_t ld, rsrc_dtor_func_t pld, char *type_name, int module_number);</PRE></TD></TR></TABLE>
   <P>&#13;		There are two different kinds of resource destruction handlers you can
		pass to this function: a handler for normal resources and a handler
		for persistent resources. Persistent resources are for example used
		for database connection. When registering a resource, either of these
		handlers must be given. For the other handler just pass
		<VAR  CLASS="literal">NULL</VAR>.
   </P><P>&#13;		<B  CLASS="function">zend_register_list_destructors_ex()</B> accepts the
		following parameters:
		<DIV  CLASS="informaltable"><P></P><A  NAME="AEN183706"></A><TABLE  BORDER="1" CLASS="CALSTABLE"><COL  WIDTH="1*" TITLE="col1"><COL  WIDTH="5*" TITLE="col2"><TBODY><TR><TD><VAR  CLASS="literal">ld</VAR></TD><TD>Normal resource destruction
         handler callback</TD></TR><TR><TD><VAR  CLASS="literal">pld</VAR></TD><TD>Pesistent resource destruction
         handler callback</TD></TR><TR><TD><VAR  CLASS="literal">type_name</VAR></TD><TD>A string specifying the name of
         your resource. It's always a good thing to
         specify an unique name within PHP for the resource type
         so when the user for example calls
         <VAR  CLASS="literal">var_dump($resource);</VAR>
         he also gets the name of the resource.</TD></TR><TR><TD><VAR  CLASS="literal">module_number</VAR></TD><TD>The <VAR  CLASS="literal">module_number</VAR>
         is automatically available in your
         <VAR  CLASS="literal">PHP_MINIT_FUNCTION</VAR>
         function and therefore you just pass it over.</TD></TR></TBODY></TABLE><P></P></DIV>
		The return value is an unique integer ID for your
		<SPAN  CLASS="strong"><B  CLASS="emphasis">resource type</B></SPAN>.
   <P>&#13;		The resource destruction handler (either normal or persistent
		resources) has the following prototype:
		<TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">void resource_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC);</PRE></TD></TR></TABLE>
		The passed <VAR  CLASS="literal">rsrc</VAR> is a pointer to the following structure:
		<TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">typedef struct _zend_rsrc_list_entry {
     
    void *ptr;
    int type;
    int refcount;

} zend_rsrc_list_entry;</PRE></TD></TR></TABLE>
		The member <VAR  CLASS="literal">void *ptr</VAR> is the actual pointer to
		your resource.
   <P>&#13;		Now we know how to start things, we define our own resource we want
		register within Zend. It is only a simple structure with two integer
		members:
		<TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">typedef struct {
     
    int resource_link;
    int resource_type;

} my_resource;</PRE></TD></TR></TABLE>
		Our resource destruction handler is probably going to look something like this:
		<TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">void my_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) {

    // You most likely cast the void pointer to your structure type

    my_resource *my_rsrc = (my_resource *) rsrc-&#62;ptr;

    // Now do whatever needs to be done with you resource. Closing
    // Files, Sockets, freeing additional memory, etc.
    // Also, don't forget to actually free the memory for your resource too!

    do_whatever_needs_to_be_done_with_the_resource(my_rsrc);
}</PRE></TD></TR></TABLE>
		<DIV  CLASS="note"><BLOCKQUOTE  CLASS="note"><P><B>注: </B>One important thing to mention: If your resource
		is a rather complex structure which also contains pointers to
		memory you allocated during runtime you have to free them
		<SPAN  CLASS="strong"><B  CLASS="emphasis">before</B></SPAN> freeing
		the resource itself!
     </P></BLOCKQUOTE></DIV>
   <P>&#13;		Now that we have defined
		<P></P><OL  TYPE="1"><LI><P>what our resource is and</P></LI><LI><P>our resource destruction handler</P></LI></OL>
		we can go on and do the rest of the steps:
		<P></P><OL  TYPE="1"><LI><P>create a global variable within the extension holding
       the resource ID so it can be accessed from every function
       which needs it</P></LI><LI><P>define the resource name</P></LI><LI><P>write the resource destruction handler</P></LI><LI><P>and finally register the handler</P></LI></OL>
		<TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">// Somewhere in your extension, define the variable for your registered resources.
    // If you wondered what 'le' stands for: it simply means 'list entry'.
    static int le_myresource;

    // It's nice to define your resource name somewhere
    #define le_myresource_name  "My type of resource"

    [...]

    // Now actually define our resource destruction handler
    void my_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) {

        my_resource *my_rsrc = (my_resource *) rsrc-&#62;ptr;
        do_whatever_needs_to_be_done_with_the_resource(my_rsrc);
    }

    [...]

    PHP_MINIT_FUNCTION(my_extension) {

        // Note that 'module_number' is already provided through the
        // PHP_MINIT_FUNCTION() function definition.

        le_myresource = zend_register_list_destructors_ex(my_destruction_handler, NULL, le_myresource_name, module_number);

        // You can register additional resources, initialize
        // your global vars, constants, whatever.
    }</PRE></TD></TR></TABLE>
   <P>&#13;		To actually register a new resource you use can either use
		the <B  CLASS="function">zend_register_resource()</B> function or
		the <B  CLASS="function">ZEND_REGISTER_RESOURE()</B> macro, both
		defined in zend_list.h . Although the arguments for both map
		1:1 it's a good idea to always use macros to be upwards
		compatible:
		<TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">int ZEND_REGISTER_RESOURCE(zval *rsrc_result, void *rsrc_pointer, int rsrc_type);</PRE></TD></TR></TABLE>
		<DIV  CLASS="informaltable"><P></P><A  NAME="AEN183762"></A><TABLE  BORDER="1" CLASS="CALSTABLE"><COL  WIDTH="1*" TITLE="col1"><COL  WIDTH="5*" TITLE="col2"><TBODY><TR><TD><VAR  CLASS="literal">rsrc_result</VAR></TD><TD>This is an already initialized
         <VAR  CLASS="literal">zval *</VAR> container.</TD></TR><TR><TD><VAR  CLASS="literal">rsrc_pointer</VAR></TD><TD>Your resource pointer you want to
         store.</TD></TR><TR><TD><VAR  CLASS="literal">rsrc_type</VAR></TD><TD>The type which you received when
         you registered the resource destruction handler. If you
         followed the naming scheme this would be
         <VAR  CLASS="literal">le_myresource</VAR>.</TD></TR></TBODY></TABLE><P></P></DIV>
		The return value is an unique integer identifier for that resource.
   <P>&#13;		What is really going on when you register a new resource is it gets
		inserted in an internal list in Zend and the result is just stored
		in the given <VAR  CLASS="literal">zval *</VAR> container:
		<TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">rsrc_id = zend_list_insert(rsrc_pointer, rsrc_type);
     
    if (rsrc_result) {
        rsrc_result-&#62;value.lval = rsrc_id;
        rsrc_result-&#62;type = IS_RESOURCE;
    }

    return rsrc_id;</PRE></TD></TR></TABLE>
    The returned <VAR  CLASS="literal">rsrc_id</VAR> uniquly identifies the newly
    registered resource. You can use the macro
    <VAR  CLASS="literal">RETURN_RESOURE</VAR> to return it to the user:
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">RETURN_RESOURCE(rsrc_id)</PRE></TD></TR></TABLE>
    <DIV  CLASS="note"><BLOCKQUOTE  CLASS="note"><P><B>注: </B>It is common practice that if you want to return the resource
      immidiately to the user you specify the <VAR  CLASS="literal">return_value</VAR>
      as the <VAR  CLASS="literal">zval *</VAR> container.
     </P></BLOCKQUOTE></DIV>
   <P>&#13;		Zend now keeps track of all references to this resource. As soon as
		all references to the resource are lost, the destructor that you
		previously registered for this resource is called. The nice thing
		about this setup is that you don't have to worry about memory leakages
		introduced by allocations in your module - just register all memory
		allocations that your calling script will refer to as resources. As
		soon as the script decides it doesn't need them anymore, Zend will
		find out and tell you.
   </P><P>&#13;		Now that the user got his resource, at some point he is passing it
		back to one of your functions. The <VAR  CLASS="envar">value.lval</VAR> inside
		the <VAR  CLASS="literal">zval *</VAR> container contains the key to your
		resource and thus can be used to fetch the resource with the following
		macro:
		<VAR  CLASS="literal">ZEND_FETCH_RESOURCE</VAR>:
		<TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">ZEND_FETCH_RESOURCE(rsrc, rsrc_type, rsrc_id, default_rsrc_id, resource_type_name, resource_type)</PRE></TD></TR></TABLE>
		<DIV  CLASS="informaltable"><P></P><A  NAME="AEN183797"></A><TABLE  BORDER="1" CLASS="CALSTABLE"><COL  WIDTH="1*" TITLE="col1"><COL  WIDTH="5*" TITLE="col2"><TBODY><TR><TD><VAR  CLASS="literal">rsrc</VAR></TD><TD>This is your pointer which will
         point to your previously registered resource.</TD></TR><TR><TD><VAR  CLASS="literal">rsrc_type</VAR></TD><TD>This is the typecast argument for
         your pointer, e.g. <VAR  CLASS="literal">myresource *</VAR>.</TD></TR><TR><TD><VAR  CLASS="literal">rsrc_id</VAR></TD><TD>This is the address of the
         <VAR  CLASS="literal">zval *</VAR>container the user passed to
         your function, e.g. <VAR  CLASS="literal">&#38;z_resource</VAR> if
         <VAR  CLASS="literal">zval *z_resource</VAR> is given.</TD></TR><TR><TD><VAR  CLASS="literal">default_rsrc_id</VAR></TD><TD>This integer specifies the default
         resource <VAR  CLASS="literal">ID</VAR> if no resource could be fetched
         or -1.</TD></TR><TR><TD><VAR  CLASS="literal">resource_type_name</VAR></TD><TD>This is the name of the requested resource.
         It's a string and is used when the resource can't be
         found or is invalid to form a meaningful error
         message.</TD></TR><TR><TD><VAR  CLASS="literal">resource_type</VAR></TD><TD>The <VAR  CLASS="literal">resource_type</VAR>
         you got back when registering the resource destruction handler.
         In our example this was <VAR  CLASS="envar">le_myresource</VAR>.</TD></TR></TBODY></TABLE><P></P></DIV>
		This macro has no return value.
		It is for the developers convenience and takes care
		of TSRMLS arguments passing and also does check if the resource
		could be fetched.
		It throws a warning message and returns the current PHP function
		with <VAR  CLASS="literal">NULL</VAR> if there was a problem retrieving the
		resource.
   <P>&#13;		To force removal of a resource from the list, use the function
		<B  CLASS="function">zend_list_delete()</B>. You can also force the
		reference count to increase if you know that you're creating another
		reference for a previously allocated value (for example, if you're
		automatically reusing a default database link). For this case, use the
		function <B  CLASS="function">zend_list_addref()</B>. To search for
		previously allocated resource entries, use
		<B  CLASS="function">zend_list_find()</B>. The complete API can be found
		in <TT  CLASS="filename">zend_list.h</TT>.
   </P></DIV><DIV  CLASS="sect2"><H2  CLASS="sect2"><A  NAME="zend.variables.global">Macros for Automatic Global Variable Creation</A></H2><P>&#13;    In addition to the macros discussed earlier, a few macros allow
    easy creation of simple global variables. These are nice to know
    in case you want to introduce global flags, for example. This is
    somewhat bad practice, but Table <A  HREF="zend.variables.html#tab.macros-global-vars">表格 45-12</A> 
    describes macros that do
    exactly this task. They don't need any <VAR  CLASS="envar">zval</VAR>
    allocation; you simply have to supply a variable name and value.
   </P><DIV  CLASS="table"><A  NAME="tab.macros-global-vars"></A><P><B>表格 45-12. Macros for Global Variable Creation</B></P><TABLE  BORDER="1" CLASS="CALSTABLE"><COL  WIDTH="1*" TITLE="col1"><COL  WIDTH="1*" TITLE="col2"><TBODY><TR><TD>Macro</TD><TD>Description</TD></TR><TR><TD><VAR  CLASS="literal">SET_VAR_STRING(name, value)</VAR></TD><TD>Creates a new string.</TD></TR><TR><TD><VAR  CLASS="literal">SET_VAR_STRINGL(name, value,
          length)</VAR></TD><TD>Creates a new string of the specified length. This macro
         is faster than <VAR  CLASS="literal">SET_VAR_STRING</VAR> and also binary-safe.</TD></TR><TR><TD><VAR  CLASS="literal">SET_VAR_LONG(name, value)</VAR></TD><TD>Creates a new long.</TD></TR><TR><TD><VAR  CLASS="literal">SET_VAR_DOUBLE(name, value)</VAR></TD><TD>Creates a new double.</TD></TR></TBODY></TABLE></DIV></DIV><DIV  CLASS="sect2"><H2  CLASS="sect2"><A  NAME="zend.variables.constant">Creating Constants</A></H2><P>&#13;    Zend supports the creation of true constants (as opposed to
    regular variables). Constants are accessed without the typical
    dollar sign (<VAR  CLASS="literal">$</VAR>) prefix and are available in all
    scopes. Examples include <VAR  CLASS="literal">TRUE</VAR> and
    <VAR  CLASS="literal">FALSE</VAR>, to name just two.
   </P><P>&#13;    To create your own constants, you can use the macros in
    <A  HREF="zend.variables.html#tab.create-const">表格 45-13</A>. 
    All the macros create a constant with the specified name and value.
   </P><P>&#13;    You can also specify flags for each constant: 
    <P></P><UL><LI><P>&#13;       <VAR  CLASS="literal">CONST_CS</VAR> - This constant's name is to be
       treated as case sensitive.
      </P></LI><LI><P>&#13;       <VAR  CLASS="literal">CONST_PERSISTENT</VAR> - This constant is
       persistent and won't be "forgotten" when the current process
       carrying this constant shuts down.
      </P></LI></UL> To use the flags, combine them using a inary OR:
    <TABLE  BORDER="0" BGCOLOR="#E0E0E0" CELLPADDING="5"><TR><TD><PRE  CLASS="programlisting">// register a new constant of type "long"
     REGISTER_LONG_CONSTANT("NEW_MEANINGFUL_CONSTANT", 324, CONST_CS |
     CONST_PERSISTENT);</PRE></TD></TR></TABLE> There are two types of
    macros -      	 	<VAR  CLASS="literal">REGISTER_*_CONSTANT</VAR>
    and<VAR  CLASS="literal">REGISTER_MAIN_*_CONSTANT</VAR>. The first type
    creates constants bound to the current module. These constants are
    dumped from the symbol table as soon as the module that registered
    the constant is unloaded from memory. The second type creates
    constants that remain in the symbol table independently of the
    module.
   <DIV  CLASS="table"><A  NAME="tab.create-const"></A><P><B>表格 45-13. Macros for Creating Constants</B></P><TABLE  BORDER="1" CLASS="CALSTABLE"><COL  WIDTH="1.53*" TITLE="col1"><COL  WIDTH="1*" TITLE="col2"><TBODY><TR><TD>Macro</TD><TD>Description</TD></TR><TR><TD> 
         <VAR  CLASS="literal">REGISTER_LONG_CONSTANT(name, value, flags)</VAR>
         <VAR  CLASS="literal">REGISTER_MAIN_LONG_CONSTANT(name, value, flags)</VAR>
        </TD><TD>Registers a new constant of type long.</TD></TR><TR><TD> 
         <VAR  CLASS="literal">REGISTER_DOUBLE_CONSTANT(name, value, flags)</VAR>
         <VAR  CLASS="literal">REGISTER_MAIN_DOUBLE_CONSTANT(name, value, flags)</VAR>
        </TD><TD>Registers a new constant of type double.</TD></TR><TR><TD> 
         <VAR  CLASS="literal">REGISTER_STRING_CONSTANT(name, value, flags)</VAR>
         <VAR  CLASS="literal">REGISTER_MAIN_STRING_CONSTANT(name, value, flags)</VAR>
        </TD><TD> Registers a new constant of type string. The specified
         string must reside in Zend's internal memory.</TD></TR><TR><TD> 
         <VAR  CLASS="literal">REGISTER_STRINGL_CONSTANT(name, value, length, flags)</VAR> 
         <VAR  CLASS="literal">REGISTER_MAIN_STRINGL_CONSTANT(name, value, length,
          flags)</VAR>
        </TD><TD>Registers a new constant of type string. The string length
         is explicitly set to <VAR  CLASS="envar">length</VAR>. The specified string must reside
         in Zend's internal memory.</TD></TR></TBODY></TABLE></DIV></DIV></DIV><BR></TD><TD><IMG SRC="../spacer.gif" WIDTH="10" HEIGHT="1"></TD></TR><TR><TD COLSPAN="3"><DIV CLASS="NAVFOOTER"><TABLE BGCOLOR="#CCCCFF" BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%"><TR BGCOLOR="#333366"><TD><IMG SRC="../spacer.gif" BORDER="0" WIDTH="1" HEIGHT="1"><BR></TD></TR><TR><TD><TABLE  SUMMARY="Footer navigation table" WIDTH="100%" BORDER="0" CELLPADDING="3" CELLSPACING="0"><TR><TD  WIDTH="33%" ALIGN="left" VALIGN="top"><A  HREF="zend.arguments.html" ACCESSKEY="P">后退</A></TD><TD  WIDTH="34%" ALIGN="center" VALIGN="top"><A  HREF="../index.html" ACCESSKEY="H">起点</A></TD><TD  WIDTH="33%" ALIGN="right" VALIGN="top"><A  HREF="zend.copy-constructor.html" ACCESSKEY="N">前进</A></TD></TR><TR><TD  WIDTH="33%" ALIGN="left" VALIGN="top">Accepting Arguments</TD><TD  WIDTH="34%" ALIGN="center" VALIGN="top"><A  HREF="zend.html" ACCESSKEY="U">上一级</A></TD><TD  WIDTH="33%" ALIGN="right" VALIGN="top">Duplicating Variable Contents: The Copy Constructor</TD></TR></TABLE></TD></TR></TABLE></DIV></TD></TR></TABLE>

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
