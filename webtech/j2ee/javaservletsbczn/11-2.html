<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end -->
<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
  
    <div class="lpindex"><a href="index.html">首页</a><a href="11-1.html"> 上一页</a><a href="12.html"> 下一页</a></div>
    <h1>第11章 编写servlet程序的自动化applet程序(下) </h1>
    <h5>　编写代码生成器</h5>
　　
            现在基本的代码生成器完成了，让我们集中精力编写每个客户代理和服务器存根代码生成器的最后实现。这里有一些必须实现的抽象方法，其中最让人感到有兴趣的就是方法codeMethod()。codeMethod()方法是代码生成器的核心，它为每个方法调用产生必要的重复性代码。图11.15显示了用户HTTP遂道客户端的codeMethod()方法。
    <pre class="code">/**
<p>   *Generates the code for the given method
　　*
　　* @param m Method to generate
　　* @param numIndent Number of indentations (tabs)
　　* @param out Print writer
　　*/
　　public void codeMethod(java.lang.reflect.Method m,int numIndent,
　　java.io.PrintWriter out)　throws java.io.IOException
　　{
　　　String line;
　　　String tab = indent(numIndent);
　　　boolean throwsClassNotFoundException = false;

　　　// Get the method return type
　　　Class ret = m.getReturnType();
　　　String retName = decodeType(ret.getName());

　　　// Validate the return type to ensure we can marshal it
　　　if (!validateType(ret)) {
　　　　throw new java.io.IOException("Invalid return data type " +
　　　　retName);
　　　}

　　　// Get the method parameters
　　　Class params[] = m.getParameterTypes();

　　　// Get the exceptions thrown by the method
　　　Class exceptions[] = m.getExceptionTypes();

　　　// Generate the method signature
　　　line = "public " +
　　　retName + " " +
　　　m.getName() + "(";

　　　// Loop for each parameter
　　　for (int i = 0; i < params.length; i++) {

　　　　// Validate the parameter type to ensure we can marshal it
　　　　if (!validateType(params[i])) {
　　　　　throw new java.io.IOException("Invalid parameter " +
　　　　　"data type " + retName);
　　　　}

　　　　// Insert a comma if necessary
　　　　if (i > 0) {
　　　　　line += ", ";
　　　　}

　　　　// Call the parameters p0, p1, etc.
　　　　line += decodeType(params[i].getName()) + " p" + i;
　　　}

　　　// Add the ending paren
　　　line += ")";

　　　// Write out the method signature
　　　out.println(tab + line);

　　　// Take care of any exceptions thrown by the method
　　　if (exceptions.length > 0) {
　　　　line = "throws ";
　　　　for (int i = 0; i < exceptions.length; i++) {
　　
　　　　　// Insert a comma if necessary
　　　　　if (i > 0) {
　　　　　　line += ", ";
　　　　　}
　　　　　line += exceptions[i].getName();
　　　　}
　　　　out.println(tab + indent(1) + line);
　　　}

　　　// Start the method body
　　　numIndent++;
　　　tab = indent(numIndent);
　　　out.println(tab + "{");
　　　numIndent++;
　　　tab = indent(numIndent);

　　　// Generate the default return value
　　　if (!retName.equals("void")) {
　　　　line = retName + " retValue = ";

　　　　// Determine the default value
　　　　if (retName.equals("boolean")) {
　　　　　line += "false;";
　　　　}
　　　　else if (retName.equals("char") ||
　　　　　retName.equals("byte") ||
　　　　　retName.equals("short") ||
　　　　　retName.equals("int") ||
　　　　　retName.equals("long") ||
　　　　　retName.equals("float") ||
　　　　　retName.equals("double")) {
　　　　　line += "0;";
　　　　}
　　　　else {
　　　　　line += "null;";
　　　　}
　　　　out.println(tab + line);
　　　}

　　　out.println(tab + "try {");
　　　numIndent++;
　　　tab = indent(numIndent);

　　　out.println(tab + "// Create an internal buffer");
　　　out.println(tab + "ByteArrayOutputStream baos = " +
　　　"new ByteArrayOutputStream();");
　　　out.println("");
　　　out.println(tab + "// Create an object stream to write " +
　　　"the request");
　　　out.println(tab + "ObjectOutputStream out =");
　　　out.println(tab + indent(1) + "(ObjectOutputStream) "+
　　　"_createHeader(baos, " + m_methodNum + ");");

　　　// Write the parameters
　　　for (int i = 0; i < params.length; i++) {
　　　　String param = "p" + i;
　　　　String paramType = decodeType(params[i].getName());

　　　　// Convert scalars to the proper object
　　　　if (paramType.equals("boolean")) {
　　　　　param = "new Boolean(" + param + ")";
　　　　}
　　　　else if (paramType.equals("byte")) {
　　　　　param = "new Byte(" + param + ")";
　　　　}
　　　　else if (paramType.equals("char")) {
　　　　　param = "new Character(" + param + ")";
　　　　}
　　　　else if (paramType.equals("short")) {
　　　　　param = "new Short(" + param + ")";
　　　　　}
　　　　else if (paramType.equals("int")) {
　　　　　param = "new Integer(" + param + ")";
　　　　}
　　　　else if (paramType.equals("long")) {
　　　　　param = "new Long(" + param + ")";
　　　　}
　　　　else if (paramType.equals("float")) {
　　　　　param = "new Float(" + param + ")";
　　　　　}
　　　　else if (paramType.equals("double")) {
　　　　　param = "new Double(" + param + ")";
　　　　}

　　　　out.println(tab + "out.writeObject(" + param + ");");
　　　}

　　　// Invoke the method
　　　out.println("");
　　　out.println(tab + "// Invoke the method");
　　　out.println(tab + "ObjectInputStream in = ");
　　　out.println(tab + indent(1) + "(ObjectInputStream) " +
　　　"_invokeMethod(baos.toByteArray());");

　　　// Get the return value if necessary
　　　if (!retName.equals("void")) {
　　　　out.println("");
　　　　out.println(tab + "// Get the return value");
　　　　out.println(tab + "Object retObject = in.readObject();");
　　　　if (retName.equals("boolean")) {
　　　　　out.println(tab + "retValue = " +
　　　　　"((Boolean) retObject).booleanValue();");
　　　　}
　　　　else if (retName.equals("byte")) {
　　　　　out.println(tab + "retValue = " +
　　　　　"((Byte) retObject).byteValue();");
　　　　}
　　　　else if (retName.equals("char")) {
　　　　　out.println(tab + "retValue = " +
　　　　　"((Character) retObject).charValue();");
　　　　}
　　　　else if (retName.equals("short")) {
　　　　　out.println(tab + "retValue = " +
　　　　　"((Short) retObject).shortValue();");
　　　　}
　　　　else if (retName.equals("int")) {
　　　　　out.println(tab + "retValue = " +
　　　　　"((Integer) retObject).intValue();");
　　　　}
　　　　else if (retName.equals("long")) {
　　　　　out.println(tab + "retValue = " +
　　　　　"((Long) retObject).longValue();");
　　　　}
　　　　else if (retName.equals("float")) {
　　　　　out.println(tab + "retValue = " +
　　　　　"((Float) retObject).floatValue();");
　　　　}
　　　　else if (retName.equals("double")) {
　　　　　out.println(tab + "retValue = " +
　　　　　"((Double) retObject).doubleValue();");
　　　　}
　　　　else {
　　　　　out.println(tab + "retValue = (" +
　　　　　retName + ") retObject;");
　　　　}
　　　　throwsClassNotFoundException = true;
　　　}

　　　// Wrap up
　　　out.println(tab + "out.close();");
　　　out.println(tab + "in.close();");

　　　// End the try block
　　　numIndent--;
　　　out.println(indent(numIndent) + "}");
　　　out.println(indent(numIndent) +
　　　"catch (java.io.IOException ex) {");
　　　out.println(indent(numIndent + 1) + "ex.printStackTrace();");
　　　out.println(indent(numIndent) + "}");

　　　if (throwsClassNotFoundException) {
　　　　out.println(indent(numIndent) +
　　　　"catch (ClassNotFoundException ex) {");
　　　　out.println(indent(numIndent + 1) + "ex.printStackTrace();");
　　　　out.println(indent(numIndent) + "}");
　　　}

　　　out.println(indent(numIndent) +
　　　"catch (TunnelException ex) {");
　　　out.println(indent(numIndent + 1) + "ex.printStackTrace();");
　　　out.println(indent(numIndent) + "}");

　　　// Write the return value
　　　if (!retName.equals("void")) {
　　　　out.println(indent(numIndent) + "return retValue;");
　　　}

　　　// End the method body
　　　numIndent--;
　　　out.println(indent(numIndent) + "}");
　　　out.println("");

　　　// Increment the method number
　　　m_methodNum++;
　　}</pre>
    图11.15 生成每一个方法的代码
    </p>
    让我们分析一下在这个方法中都要做些什么：
    </p>
    <p> 　　1.验证返回类型的有效性，确保它可以完全地被编发。</p>
    <p> 　　2.创建方法签名。这个签名包括所有的语法修饰符、返回类型、方法名、参数类型和异常。每个参数类型都要验证有效性以保证它可以被完全地编发。</p>
    <p> 　　3.创建方法正文。参考图11.2，其中举例说明了方法是如何被生成的。</p>
    <p> 　　确认数据类型以保证它们可以被完全地编发。这项工作主要依据是它们属于可以被用于“Lite”遂道的HTTP遂道类型也可以被JDK1.0.2使用的类型，是可以使用DataInputStream和DataOutputStream方法来编发的类型。因此，只有标量和字符串对象可以使用。正规的遂道使用ObjectInputStream和ObjectOutputStream编发数据并且需要所使用的对象实现java.io.Serializable。</p>
　　
实现了所有的代码生成器后，最后要做的就是要建立一个应用程序来测试它们。这个名为ServletGen的应用程序接收命令行参数并调用适当的代码生成器。在图11.16中列出了它的完整代码。
   
    <pre class="code">　package javaservlets.CodeGen;

　　/**
　　* <p>This application will invoke the proper code generator
　　* depending upon the command line options given:
　　*
　　* -i Interface name
　　* -c Class name
　　* -l (option) Lite version
　　*
　　* All generated source will be created in the current directory.
　　*/

　　public class ServletGen
　　{
　　　public static void main(String args[])
　　　{
　　　　// Get the interface name
　　　　String interfaceName = getArg(args, "-i");

　　　　// Get the class name
　　　　String className = getArg(args, "-c");

　　　　// Get the optional 'lite' arg
　　　　boolean lite = argExists(args, "-l");

　　　　// Make sure the required parameters were given
　　　　if ((interfaceName == null) ||
　　　　　(className == null)) {
　　　　　　System.out.println("\nServletGen usage:\n");
　　　　　　System.out.println("ServletGen -i<interface> -c<class> " +
　　　　　　"[-l]");
　　　　　　return;
　　　　}

　　　　try {

　　　　　// Generate the appropriate code
　　　　　if (lite) {
　
　　　　　　// Generate the lite client
　　　　　　ServletGenLiteClient client = new ServletGenLiteClient();
　　　　　　client.setInterfaceName(interfaceName);
　　　　　　client.setObjectName(className);
　　　　　　System.out.println("Generating servlet client proxy");
　　　　　　client.generate();
　
　　　　　　// Generate the server
　　　　　　ServletGenLiteServer server = new ServletGenLiteServer();
　　　　　　server.setInterfaceName(interfaceName);
　　　　　　server.setObjectName(className);
　　　　　　System.out.println("Generating servlet server stub");
　　　　　　server.generate();
　　　　　}
　　　　　else {
　　　　　　
　　　　　　// Generate the client
　　　　　　ServletGenClient client = new ServletGenClient();
　　　　　　client.setInterfaceName(interfaceName);
　　　　　　client.setObjectName(className);
　　　　　　System.out.println("Generating servlet client proxy");
　　　　　　client.generate();

　　　　　　// Generate the server
　　　　　　ServletGenServer server = new ServletGenServer();
　　　　　　server.setInterfaceName(interfaceName);
　　　　　　server.setObjectName(className);
　　　　　　System.out.println("Generating servlet server stub");
　　　　　　server.generate();

　　　　　}
　　　　}
　　　　catch (Exception ex) {
　　　　　ex.printStackTrace();
　　　　}
　　　}

　　　/**
　　　* Find the given argument switch.
　　　*
　　　* @param args Array of command line arguments
　　　* @param s Switch to find
　　　* @return Value of the argument or null if not found
　　　*/
　　　public static String getArg(String args[], String s)
　　　{
　　　　String arg = null;

　　　　if (args != null) {
　　　　　// Find the switch in the array
　　　　　for (int i = 0; i < args.length; i++) {

　　　　　　// Does the switch match?
　　　　　　if (args[i].startsWith(s)) {
　　　　　　　if (args[i].length() > s.length()) {

　　　　　　　　// Get the value
　　　　　　　　arg = args[i].substring(s.length());
　　　　　　　　break;
　　　　　　　}
　　　　　　}
　　　　　}
　　　　}
　　
　　　　return arg;
　　　}

　　　/**
　　　* <p>Determines if the given argument switch exists.
　　　*
　　　* @param args Array of command line arguments
　　　* @param s Switch to find
　　　* @return true if the switch exists
　　　*/
　　　public static boolean argExists(String args[], String s)
　　　{
　　　　boolean rc = false;
　　　　
　　　　if (args != null) {
　　　　　// Find the switch in the array
　　　　　for (int i = 0; i < args.length; i++) {

　　　　　　// Does the switch match?
　　　　　　if (args[i].startsWith(s)) {
　　　　　　　rc = true;
　　　　　　　break;
　　　　　　}
　　　　　}
　　　　}

　　　　return rc;
　　　}
　　}</pre>
    <p>图11.16 应用程序ServletGen
    </p>
    <h3> 　<a name="1133" id="1133"></a>11.3.3 遂道实例再访：RemoteMathLite</h3>
    <p>　　在第10章中，我们开发了一个非常基本的算术对象。我们从定义这个对象的接口开始（见图11.17）并最后实现了这个接口（见图11.18)。当时实现的时候，我们是通过手工编写一个客户代理和服务器端代码存根来实现对服务器端的算术对象的“lite”HTTP遂道方法调用的。</p>
    <pre class="code"><p>　　package javaservlets.CodeGen;</p>
　　/**</p>
<p>              　　* &lt;p&gt;This interface defines the methods available for</p>
<p>              　　* performing math</p>
<p>              　　* 下面的double在原文中是int</p>
              　　*/</p>
　　public interface MathInterface</p>
<p>              　　{</p>
<p>              　　　/**</p>
<p>              　　　* &lt;p&gt;Adds two numbers</p>
<p>              　　　*/</p>
              　　　double add(double a, double b);</p>
　　　/**</p>
<p>              　　　* &lt;p&gt;Subtracts two numbers</p>
<p>              　　　*/</p>
              　　　double subtract(double a, double b);</p>
　　　/**</p>
<p>              　　　* &lt;p&gt;Multiplies two numbers</p>
<p>              　　　*/</p>
              　　　double multiply(double a, double b);</p>
　　}</p>
              　　　　图11.17 MathInterface.java</p>
            <p>　　package javaservlets.CodeGen;</p>
　　/**</p>
              　　* &lt;p&gt;This class performs simple math functions in order 
<p>              to</p>
<p>              　　* illustrate remote method tunneling.</p>
<p>              　　* 下面的double在原文中是int </p>
              　　*/</p>
　　public class Math implements MathInterface</p>
<p>              　　{</p>
<p>              　　　/**</p>
<p>              　　　* &lt;p&gt;Adds two numbers</p>
<p>              　　　*/</p>
<p>              　　　public double add(double a, double b)</p>
<p>              　　　{</p>
<p>              　　　　return (a + b);</p>
              　　　}</p>
　　　/**</p>
<p>              　　　* &lt;p&gt;Subtracts two numbers</p>
<p>              　　　*/</p>
<p>              　　　public double subtract(double a, double b)</p>
<p>              　　　{</p>
<p>              　　　　return (a - b);</p>
              　　　}</p>
　　　/**</p>
<p>              　　　* &lt;p&gt;Multiplies two numbers</p>
<p>              　　　*/</p>
<p>              　　　public double multiply(double a, double b)</p>
<p>              　　　{</p>
<p>              　　　　return (a * b);</p>
              　　　}</p>
　　}</pre>
    图11.18 Math.java
    <p>　　现在进入令兴奋的部分！取代手工编制客户代理和服务器代码存根，让我们使用新的代码生成器来为我们做所有的事情吧（为了提高可读性，Java命令被分成为两行书写）。</p>
    <pre class="code">java javaservlets.CodeGen.ServletGen -ijavaservlets.CodeGen.MathInterface

-cjavaservlets.CodeGen.Math -l

Generating servlet client proxy

Writing RemoteMathLiteClient.java

Generationg servlet server stub

Writing RemoteMathLiteServer.java </pre>
    <p>　　只要很短的时间，ServletGen就可以使用Reflection API技术找到在指定接口中(javaservlets.CodeGen.MathInterface)的所有的方法并生成“lite”HTTP遂道类型的客户代理和服务器代码存根（使用-l开关指定)。图11.19显示了RemoteMathLiteClient的代码，图11.20显示了RemoteMathLiteServer的代码。要知道所有的这些源文件都是完全通过机器生成的。</p>
　　
    <pre class="code">/* * @(#)RemoteMathClient

*

* Generated by javaservlets.CodeGen.ServletGenClient

* on Sat Jan 16 13:57:11 EST 1999

*

* This software is provided WITHOUT WARRANTY either expressed or

* implied.

*

*/ package javaservlets.CodeGen;

import java.io.*; import javaservlets.tunnel.client.*; /** * <p>This class implements the client for tunneling

* calls to the javaservlets.CodeGen.Math object.

*/ public class RemoteMathClient extends javaservlets.tunnel.client.TunnelClient

implements javaservlets.CodeGen.MathInterface

{ /** * </p><p>Constructs a new RemoteMathClient for the

* given URL. This will create a new javaservlets.CodeGen.Math

* object on the server as well.

* @param url The server root URL for servlets

*/

public RemoteMathClient(String url)

throws TunnelException, IOException

{

this(url, false);

} /** * </p><p>Constructs a new RemoteMathClient for the

* given URL. This will create a new javaservlets.CodeGen.Math

* object on the server as well.

* @param url The server root URL for servlets

* @param usePackage Indicates whether to use the package name

* in the servlet URL

*/

public RemoteMathClient(String url, boolean usePackage)

throws TunnelException, IOException

{

// Append the package name if necessary

if (usePackage) {

url += &quot;javaservlets.CodeGen.&quot;;

}



// Append the remote server name

url += &quot;RemoteMathServer&quot;; // Set the URL _setURL(new java.net.URL(url)); // Initialize the client and server _initialize(); 

}

public double add(double p0, double p1)

{

double retValue = 0;

try {

// Create an internal buffer

ByteArrayOutputStream baos = new ByteArrayOutputStream(); // Create an object stream to write the request ObjectOutputStream out =

(ObjectOutputStream) _createHeader(baos, 0);

out.writeObject(new Double(p0));

out.writeObject(new Double(p1)); // Invoke the method ObjectInputStream in = 

(ObjectInputStream) _invokeMethod(baos.toByteArray()); // Get the return value Object retObject = in.readObject();

retValue = ((Double) retObject).doubleValue();

out.close();

in.close();

}

catch (java.io.IOException ex) {

ex.printStackTrace();

}

catch (ClassNotFoundException ex) {

ex.printStackTrace();

}

catch (TunnelException ex) {

ex.printStackTrace();

}

return retValue;

} public double subtract(double p0, double p1) {

double retValue = 0;

try {

// Create an internal buffer

ByteArrayOutputStream baos = new ByteArrayOutputStream(); // Create an object stream to write the request ObjectOutputStream out =

(ObjectOutputStream) _createHeader(baos, 1);

out.writeObject(new Double(p0));

out.writeObject(new Double(p1)); // Invoke the method ObjectInputStream in = 

(ObjectInputStream) _invokeMethod(baos.toByteArray()); // Get the return value Object retObject = in.readObject();

retValue = ((Double) retObject).doubleValue();

out.close();

in.close();

}

catch (java.io.IOException ex) {

ex.printStackTrace();

}

catch (ClassNotFoundException ex) {

ex.printStackTrace();

}

catch (TunnelException ex) {

ex.printStackTrace();

}

return retValue;

} public double multiply(double p0, double p1) {

double retValue = 0;

try {

// Create an internal buffer

ByteArrayOutputStream baos = new ByteArrayOutputStream(); // Create an object stream to write the request ObjectOutputStream out =

(ObjectOutputStream) _createHeader(baos, 2);

out.writeObject(new Double(p0));

out.writeObject(new Double(p1)); // Invoke the method ObjectInputStream in = 

(ObjectInputStream) _invokeMethod(baos.toByteArray()); // Get the return value Object retObject = in.readObject();

retValue = ((Double) retObject).doubleValue();

out.close();

in.close();

}

catch (java.io.IOException ex) {

ex.printStackTrace();

}

catch (ClassNotFoundException ex) {

ex.printStackTrace();

}

catch (TunnelException ex) {

ex.printStackTrace();

}

return retValue;

}

}

图11.19 生成的RemoteMathLiteClient.java /* * @(#)RemoteMathLiteServer

*

* Generated by javaservlets.CodeGen.ServletGenLiteServer

* on Fri Jan 15 21:59:30 EST 1999

*

* This software is provided WITHOUT WARRANTY either expressed or

* implied.

*

*/ package javaservlets.CodeGen;

import javax.servlet.*; import javax.servlet.http.*;

import java.io.*;

import javaservlets.tunnel.server.*; /** * </p><p>This class implements the lite server for tunneling

* calls to the javaservlets.CodeGen.Math object. 'Lite' servers use

* simple data input and output streams and can be used

* with JDK 1.0.2

*/ public class RemoteMathLiteServer extends javaservlets.tunnel.server.TunnelLiteServer

{

/**

* </p><p>Creates a new instance of the server object. 

*

* @return Instance of the server object

*/

public Object _getNewInstance()

throws ServletException

{

return new javaservlets.CodeGen.Math();

} /** * </p><p>Invokes the method for the ordinal given. If the method

* throws an exception it will be sent to the client. 

*

* @param Object Server object

* @param ordinal Method ordinal

* @param in Input stream to read additional parameters

* @param out Output stream to write return values

*/

public void _invokeMethod(Object serverObject, int ordinal,

DataInput in, DataOutput out)

throws Exception

{

// Cast the server object

javaservlets.CodeGen.Math o = (javaservlets.CodeGen.Math) serverObject; // Evaluate the ordinal switch (ordinal) {

case 0: //add

double p0_0 =

((DataInputStream) in).readDouble();

double p0_1 =

((DataInputStream) in).readDouble();

double r0 = o.add(p0_0, p0_1);

((DataOutputStream) out).writeDouble(r0);

break;

case 1: //subtract

double p1_0 =

((DataInputStream) in).readDouble();

double p1_1 =

((DataInputStream) in).readDouble();

double r1 = o.subtract(p1_0, p1_1);

((DataOutputStream) out).writeDouble(r1);

break;

case 2: //multiply

double p2_0 =

((DataInputStream) in).readDouble();

double p2_1 =

((DataInputStream) in).readDouble();

double r2 = o.multiply(p2_0, p2_1);

((DataOutputStream) out).writeDouble(r2);

break;

default:

throw new Exception(&quot;Invalid ordinal: &quot; + ordinal);

}

}

}</p>
</pre>
    <p>图11.19 生成的RemoteMathLiteServer.java </p>
    <h3> 　<a name="1134" id="1134"></a>11.3.4 遂道实例再访：RemoteIndy</h3>
    <p>　　在第10章中，我们开发了一个名为Indy的使用JDBC的简单对象。这个对象获取指定年份的Indianapolis 500赛事冠军的信息并将它们发送给客户端。我们定义了接口（见图11.21)并编写了它的实现（见图11.22）。</p>
    <pre class="code">package javaservlets.CodeGen;

/** * <p>This interface defines the methods available for

* performing queries on the Indianapolis 500 database

*/ public interface IndyInterface {

/**

* </p><p>Connects to the database.

*

* @return True if the database connection was established

*/

boolean connect(); /** * </p><p>Closes the database connection

*/

void close(); /** * </p><p>Given the year return the corresponding Indianapolis

* 500 record

*

* @param year Year of the race

* @return Indy 500 record or null if not found

*/

IndyRecord query(int year); } </p>
</pre>
    <p>　　图11.21 IndyInterface.java </p>
    <pre class="code">　package javaservlets.CodeGen;

import java.sql.*;

/** * <p>Implements the IndyInterface to provide query capabilities

* into the Indianapolis 500 database.

*/ public class Indy implements IndyInterface {

// The JDBC Connection

Connection m_connection = null; // A prepared statement to use to query the database PreparedStatement m_ps = null; /** * </p><p>Connects to the database.

*

* @return True if the database connection was established

*/

public boolean connect()

{

boolean rc = false; try { 

// Load the Bridge

Class.forName(&quot;sun.jdbc.odbc.JdbcOdbcDriver&quot;).newInstance(); // Connect to the Access database m_connection =

DriverManager.getConnection(&quot;jdbc:odbc:MyAccessDataSource&quot;); // Go ahead and create a prepared statement m_ps = m_connection.prepareStatement

(&quot;SELECT Year, Driver, AvgSpeed from IndyWinners &quot; +

&quot;WHERE Year = ?&quot;);



rc = true;

}

catch (Exception ex) {

ex.printStackTrace();

}



return rc;

} /** * </p><p>Closes the database connection

*/

public void close()

{

// Close the connection if it was opened

if (m_connection != null) {

try {

m_connection.close();

}

catch (SQLException ex) {

ex.printStackTrace();

}

m_connection = null;

}

} /** * </p><p>Given the year return the corresponding Indianapolis

* 500 record

*

* @param year Year of the race

* @return Indy 500 record or null if not found

*/

public IndyRecord query(int year)

{

IndyRecord record = null; try {

// Set the year parameter m_ps.setInt(1, year); // Execute the query ResultSet rs = m_ps.executeQuery(); // Make sure a record exists if (rs.next()) {



// Create a new IndyRecord object

record = new IndyRecord();



// Set the values

record.year = rs.getInt(1);

record.driver = rs.getString(2);

record.speed = rs.getDouble(3);

}

rs.close();

}

catch (SQLException ex) {

ex.printStackTrace();

record = null;

}



return record;

} } </p>
</pre>
    图11.22 Indy.java 我们还手工编写了一个HTTP遂道类型的客户代理和服务器代码存根。现在让我们坐下来，放松，让计算机来为你进行全部的工作。
    <pre class="code">java javaservlets.CodeGen.ServletGen -ijavaservlets.CodeGen.IndyInterface

-cjavaservlets.CodeGen.Indy

Generating servlet client proxy

Writing RemoteINdyClient.java

Generationg servlet server stub

Writing RemoteIndyServer.java 　</pre>
    <p>　　这时ServletGen已经创建了基于正规HTTP遂道方法调用（使用ObjectInputStream和ObjectOutputStream来编发数据）的客户代理和服务器代码存根。图11.23显示了RemoteIndyClient的代码，图11.24显示了RemoteIndySer的代码。</p>
　
    <pre class="code">/* * @(#)RemoteIndyClient

*

* Generated by javaservlets.CodeGen.ServletGenClient

* on Mon May 04 23:31:58 EDT 1998

*

* This software is provided WITHOUT WARRANTY either expressed or

* implied.

*

*/ package javaservlets.CodeGen;

import java.io.*; import javaservlets.tunnel.client.*; /** * <p>This class implements the client for tunneling

* calls to the javaservlets.CodeGen.Indy object.

*/ public class RemoteIndyClient extends javaservlets.tunnel.client.TunnelClient

implements javaservlets.CodeGen.IndyInterface

{ /** * </p><p>Constructs a new RemoteIndyClient for the

* given URL. This will create a new javaservlets.CodeGen.Indy

* object on the server as well.

*/

public RemoteIndyClient(String url)

throws TunnelException, IOException

{

// Append the remote server name

url += &quot;RemoteIndyServer&quot;; // Set the URL _setURL(new java.net.URL(url)); // Initialize the client and server _initialize(); 

}



public boolean connect()

{

boolean retValue = false;

try {

// Create an internal buffer

ByteArrayOutputStream baos = new ByteArrayOutputStream(); // Create an object stream to write the request ObjectOutputStream out =

(ObjectOutputStream) _createHeader(baos, 0); // Invoke the method ObjectInputStream in = 

(ObjectInputStream) _invokeMethod(baos.toByteArray()); // Get the return value Object retObject = in.readObject();

retValue = ((Boolean) retObject).booleanValue();

out.close();

in.close();

}

catch (java.io.IOException ex) {

ex.printStackTrace();

}

catch (ClassNotFoundException ex) {

ex.printStackTrace();

}

catch (TunnelException ex) {

ex.printStackTrace();

}

return retValue;

} public void close() {

try {

// Create an internal buffer

ByteArrayOutputStream baos = new ByteArrayOutputStream(); // Create an object stream to write the request ObjectOutputStream out =

(ObjectOutputStream) _createHeader(baos, 1); // Invoke the method ObjectInputStream in = 

(ObjectInputStream) _invokeMethod(baos.toByteArray());

out.close();

in.close();

}

catch (java.io.IOException ex) {

ex.printStackTrace();

}

catch (TunnelException ex) {

ex.printStackTrace();

}

} public javaservlets.CodeGen.IndyRecord query(int p0) {

javaservlets.CodeGen.IndyRecord retValue = null;

try {

// Create an internal buffer

ByteArrayOutputStream baos = new ByteArrayOutputStream(); // Create an object stream to write the request ObjectOutputStream out =

(ObjectOutputStream) _createHeader(baos, 2);

out.writeObject(new Integer(p0)); // Invoke the method ObjectInputStream in = 

(ObjectInputStream) _invokeMethod(baos.toByteArray()); // Get the return value Object retObject = in.readObject();

retValue = (javaservlets.CodeGen.IndyRecord) retObject;

out.close();

in.close();

}

catch (java.io.IOException ex) {

ex.printStackTrace();

}

catch (ClassNotFoundException ex) {

ex.printStackTrace();

}

catch (TunnelException ex) {

ex.printStackTrace();

}

return retValue;

} }

图11.23 生成的RemoteIndyClient.java /* * @(#)RemoteIndyServer

*

* Generated by javaservlets.CodeGen.ServletGenServer

* on Mon May 04 23:31:59 EDT 1998

*

* This software is provided WITHOUT WARRANTY either expressed or

* implied.

*

*/ package javaservlets.CodeGen;

import javax.servlet.*; import javax.servlet.http.*;

import java.io.*;

import javaservlets.tunnel.server.*; /** * </p><p>This class implements the server for tunneling

* calls to the javaservlets.CodeGen.Indy object.

*/ public class RemoteIndyServer extends javaservlets.tunnel.server.TunnelServer

{

/**

* </p><p>Creates a new instance of the server object. 

*

* @return Instance of the server object

*/

public Object _getNewInstance()

throws ServletException

{

return new javaservlets.CodeGen.Indy();

} /** * </p><p>Invokes the method for the ordinal given. If the method

* throws an exception it will be sent to the client. 

*

* @param Object Server object

* @param ordinal Method ordinal

* @param in Input stream to read additional parameters

* @param out Output stream to write return values

*/

public void _invokeMethod(Object serverObject, int ordinal,

DataInput in, DataOutput out)

throws Exception

{

// Cast the server object

javaservlets.CodeGen.Indy o = (javaservlets.CodeGen.Indy) serverObject; // Evaluate the ordinal switch (ordinal) {

case 0: //connect

boolean r0 = o.connect();

((ObjectOutputStream) out).writeObject(new Boolean(r0));

break;

case 1: //close

o.close();

break;

case 2: //query

int p2_0 =

((Integer) read(in)).intValue();

javaservlets.CodeGen.IndyRecord r2 = o.query(p2_0);

((ObjectOutputStream) out).writeObject(r2);

break;

default:

throw new Exception(&quot;Invalid ordinal: &quot; + ordinal);

}

} /** * </p><p>Helper method to read an object from the input stream

*

* @param in Input stream

* @return The next object read from the input stream

*/

protected Object read(DataInput in)

throws Exception

{

return ((ObjectInputStream) in).readObject();

}

}</p>
</pre>
    <p>图11.24 生成的RemoteIndyServer.java </p>
    <h2><a name="114" id="114"></a>11.4 小结</h2>
    <p>　　在这一章中，我们进入到了Java编程的一个新的水平，使用Java的内建特性自动创建其他的Java类。这种实现的基础就是Reflection </p>
    <p> API技术。Reflection API技术是一组方法和类，它们可以提供有关类的内部结构的信息。我们使用这种强有力的API技术开发代码生成器来生成HTTP上的遂道方法调用所必须的客户代理和服务器端代码存根。</p>
　　
接下来，我们要终止一下Servlet的编程，开发一种可以减轻applet发布工作的应用程序。我们将通过自动创建一个包含applet程序所需的所有类文件的存档文件来实现这项工作。
    <div class="rpindex"><a href="12.html"> 下一页</a><a href="11-1.html"> 上一页</a><a href="index.html">首页</a></div>
<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->
