<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->


<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="orm-jpa"></a>12.6.&#160;JPA</h2></div></div></div>
<p>（<code class="literal">org.springframework.orm.jpa</code> 包下的）Spring JPA以类似整合Hibernate或者JDO的方式，
		提供了对 <a href="" target="_top">Java Persistence API</a>
		的全面支持，同时为提供附加的特性，必须了解底层的实现。</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="orm-jpa-setup"></a>12.6.1.&#160;在Spring环境中建立JPA</h3></div></div></div>
<p>Spring JPA 提供了三种方法创建JPA <code class="interfacename">EntityManagerFactory</code>：</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="orm-jpa-setup-lemfb"></a>12.6.1.1.&#160;<code class="classname">LocalEntityManagerFactoryBean</code></h4></div></div></div>
<p>
			<code class="classname">LocalEntityManagerFactoryBean</code>负责创建一个适合于仅使用JPA进行数据访问的环境的
					<code class="interfacename">EntityManager</code>。
			Factory bean将使用JPA <code class="interfacename">PersistenceProvider</code> 类的自动检测机制（根据JPA的
			Java SE启动），而在绝大多数情况下，只需要指定persistence unit名称：</p>
<pre class="code">&lt;beans&gt;

   &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean"&gt;
      &lt;property name="persistenceUnitName" value="myPersistenceUnit"/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;</pre>
<p>这种JPA部署方式最为简单，但却最受限制。例如，不能连接到现有的JDBC<code class="interfacename">DataSource</code>，
        并且不支持全局事务。甚至，持久化类的织入（字节码转换）也是特定于提供者的，经常需要在启动时指定一个特定的JVM代理。
        总之，这种方法实际上只适用于独立的应用程序和测试环境（这正是JPA规范设计它的原因）。</p>
<p><span class="emphasis"><em>仅在简单部署环境中只使用这种方式，比如独立的应用程序和集成测试。</em></span></p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="orm-jpa-setup-jndi"></a>12.6.1.2.&#160;从JNDI中获取 <code class="classname">EntityManagerFactory</code> </h4></div></div></div>
<p>从JNDI获取 <code class="interfacename">EntityManagerFactory</code> （例如在Java EE 5环境中），仅通过修改XML配置即可实现：</p>
<pre class="code">&lt;beans&gt;

    &lt;jee:jndi-lookup id="entityManagerFactory" jndi-name="persistence/myPersistenceUnit"/&gt;

&lt;/beans&gt;</pre>
<p>在标准的Java EE 5启动过程中，Java EE服务器自动检测持久化单元（例如应用程序文件包中的<code class="literal">META-INF/persistence.xml</code>）
        ，以及Java EE部署描述符中定义给那些持久化单元命名上下文位置的环境的<code class="literal">persistence-unit-ref</code>项（例如<code class="literal">web.xml</code>）。</p>
<p>在这种情况下，整个持久化单元部署，包括持久化类的织入（字码码转换）都取决于Java EE服务器。
        JDBC <code class="interfacename">DataSource</code> 通过在<code class="literal">META-INF/persistence.xml</code>
        文件中的JNDI位置进行定义；EntityManager事务与服务器的JTA子系统整合。Spring仅仅用获得的<code class="interfacename">EntityManagerFactory</code>,
        通过依赖注入将它传递给应用程序对象，并为它管理事务（一般通过<code class="classname">JtaTransactionManager</code>）。</p>
<p>注意，如果在同一个应用程序中使用了多个持久化单元，JNDI获取的这种持久化单元的bean名称
        应该与应用程序用来引用它们的持久化单元名称相符（例如<code class="literal">@PersistenceUnit</code>和
        <code class="literal">@PersistenceContext注解）。</code></p>
<p><span class="emphasis"><em>在部署到Java EE 5服务器时使用该方法。关于如何将自定义JPA提供者部署到服务器，以及允许使用服务器提供的缺省提供者之外的JPA提供者，请查看服务器文档的相关说明。</em></span></p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="orm-jpa-setup-lcemfb"></a>12.6.1.3.&#160;<code class="classname">LocalContainerEntityManagerFactoryBean</code></h4></div></div></div>
<p><code class="classname">LocalContainerEntityManagerFactoryBean</code> 提供了对JPA <code class="interfacename">EntityManagerFactory</code> 
		的全面控制，非常适合那种需要细粒度定制的环境。<code class="classname">LocalContainerEntityManagerFactoryBean</code> 将基于 
		<code class="literal">persistence.xml</code> 文件创建 <code class="interfacename">PersistenceUnitInfo</code> 类，并提供 <code class="literal">dataSourceLookup</code> 策略和 <code class="literal">loadTimeWeaver</code>。
		因此它可以在JNDI之外的用户定义的数据源之上工作，并控制织入流程。</p>
<pre class="code">&lt;beans&gt;
        
 &lt;bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="dataSource" ref="someDataSource"/&gt;
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/&gt;
  &lt;/property&gt;
 &lt;/bean&gt;
 
&lt;/beans&gt;</pre>
<p>这是最为强大的JPA配置方式，允许在应用程序中灵活进行本地配置。它支持连接现有JDBC <code class="interfacename">DataSource</code> ，
        支持本地事务和全局事务等等。然而，它也将需求强加到了运行时环境中，例如，如果持久化提供者需要字节码转换，则必须有织入ClassLoader的能力。</p>
<p>注意，这个选项可能与Java EE 5服务器内建的JPA功能相冲突。因此，当运行在完全Java EE 5环境中时，
        要考虑从JNDI获取<code class="interfacename">EntityManagerFactory</code>。另一种可以替代的方法是，在
        <code class="classname">LocalContainerEntityManagerFactoryBean</code>定义中通过“persistenceXmlLocation”指定相关位置，
        例如“META-INF/my-persistence.xml”，并且只将包含该名称的描述符放在应用程序包文件中。因为Java EE 5服务器将只
        查找默认的<code class="literal">META-INF/persistence.xml</code>文件，它会忽略这种定制的持久化单元，因而避免与前面Spring
        驱动的JPA配置冲突。（例如，适用于Rdsin 3.1）。</p>
<p><span class="emphasis"><em>在基于Spring的应用程序环境中使用该方式可获得全部JPA功能。这包括web容器，如Tomcat，
        以及独立的应用程序和包含复杂持久化需求的集成测试。</em></span></p>
<div class="sidebar">
<p class="title"><b>何时需要加载时织入？</b></p>
<p>并非所有的JPA提供者都需要JVM代理(Hibernate就是一个例子)。
          如果你的提供者不需要代理(agent)或者你有其他选择(例如通过自定义编译器或者ant任务在构建时进行增强)，那么就<span class="bold"><strong>不应该</strong></span>使用加载时织入。</p>
</div>
<p><code class="interfacename">LoadTimeWeaver</code> 接口由Spring提供，允许JPA <code class="interfacename">ClassTransformer</code> 实例
		能够根据环境（web容器/应用服务器）以特定的方式插入。
		通过Java 5 <a href="" target="_top">代理</a>挂钩
		<code class="literal">ClassTransformers</code>经常是无效的 —— 代理通常在 <span class="emphasis"><em>整个虚拟机</em></span> 环境下工作，并且监控
		<span class="emphasis"><em>每一个</em></span> 被加载的类 —— 这在生产环境下一般是不提倡的。</p>
<p>Spring提供了大量用于不同环境的 <code class="interfacename">LoadTimeWeaver</code> 实现类，
		允许 <code class="interfacename">ClassTransformer</code> 实例能够仅用于<span class="emphasis"><em>每个classloader</em></span> ，而不是每个虚拟机。</p>
<p>接下来的一节将讨论在Tomcat以及使用Spring的VM代理情况下的典型JPA织入配置。关于设置常用加载时织入的详细内容，
        请参见AOP一章中的<a href="ch06s08.html#aop-aj-ltw-spring" title="6.8.4.5.&#160;Spring配置">第&#160;6.8.4.5&#160;节 “Spring配置”</a>一节，它涵盖了Tomcat、VM代理以及WebLogic、OC4J、GlassFish和Resin。</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h5 class="title">
<a name="orm-jpa-setup-lcemfb-tomcat"></a>12.6.1.3.1.&#160;Tomcat（5.0以上）加载时的织入配置</h5></div></div></div>
<p><a href="" target="_top">Apache Tomcat</a> 缺省的ClassLoader（类装载器）并不支持类的切换，
		  但是它允许使用用户自定义的类装载器。Spring提供了 <code class="classname">TomcatInstrumentableClassLoader</code> 类
		  （在<code class="literal">org.springframework.instrument.classloading.tomcat</code> 包中），这个类继承自Tomcat的类装载器
		  （<code class="classname">WebappClassLoader</code>）并且允许JPA <code class="classname">ClassTransformer</code> 的实例来“增强”所有由它加载的类。
		简单说，JPA转化器（JPA transformer）仅仅在（使用 <code class="classname">TomcatInstrumentableClassLoader</code> 的）特定web应用程序中才能被使用。</p>
<p>为使用用户自定义的类装载器：</p>
<div class="itemizedlist">
<div class="orderedlist"><ol type="1">
<li><p>将 <code class="literal">spring-tomcat-weaver.jar</code> 复制到 <span class="emphasis"><em>$CATALINA_HOME</em></span>/server/lib 下
				（其中<span class="emphasis"><em>$CATALINA_HOME</em></span> 表示Tomcat的安装路径）。</p></li>
<li>
<p>通过修改web application context使Tomcat使用用户自定义的类装载器（而不是默认的类装载器）：</p>
<pre class="code">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"/&gt;
&lt;/Context&gt;</pre>
<p>Tomcat 5.0.x 和 5.5.x 系列支持多个上下文路径（context locations）：
							服务器配置文件(<span class="emphasis"><em>$CATALINA_HOME/conf/server.xml</em></span>)，
							默认的上下文配置（<span class="emphasis"><em>$CATALINA_HOME/conf/context.xml</em></span>）会影响所有被部署的web应用程序、
							单独部署在Server端的web应用程序的配置<span class="emphasis"><em>（$CATALINA_HOME/conf/[enginename]/[hostname]/my-webapp-context.xml</em></span>）
							或者与web应用程序一起（<span class="emphasis"><em>your-webapp.war/META-INF/context.xml</em></span>）。从效率的角度说，
							我们推荐在web-app的内部配置的方式，因为仅仅使用JPA的应用程序会使用用户自定义的类装载器。
							更多具体有关可用的上下文路径的内容请参见Tomcat 5.x的<a href="" target="_top">文档</a>。</p>
<p>注意，5.5.20之前的版本有一个XML配置解析的bug，造成<span class="emphasis"><em> server.xml </em></span>
							中无法使用<code class="literal">Loader</code>标签，无论是否指定了classloader，也不管这个classloader是官方的还是自定义的。</p>

　　　　　　　　<p>如果你正在使用的是Tomcat 5.5.20以上的版本，就可以将<span class="emphasis"><em>useSystemClassLoaderAsParent</em></span>设置成
　　　　　　　　<code class="literal">false</code>来解决这个问题：</p>
<pre class="code">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"
            useSystemClassLoaderAsParent="false"/&gt;
&lt;/Context&gt;</pre>
</li>
</ol></div>
<div class="orderedlist"><ol type="1">
<li><p>将<code class="literal">spring-tomcat-weaver.jar</code>复制到<span class="emphasis"><em>$CATALINA_HOME</em></span>/lib (where
                <span class="emphasis"><em>$CATALINA_HOME</em></span>表示Tomcat安装根目录的位置）。</p></li>
<li>
<p>通过编辑web应用程序上下文文件，使Tomcat使用自定义的ClassLoader（而不是默认的ClassLoader）：</p>
<pre class="code">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"/&gt;
&lt;/Context&gt;</pre>
<p>Tomcat 6.0.x (类似于5.0.x/5.5.x)系列支持几种上下文路径：（context locations）：
							服务器配置文件(<span class="emphasis"><em>$CATALINA_HOME/conf/server.xml</em></span>)，
							默认的上下文配置（<span class="emphasis"><em>$CATALINA_HOME/conf/context.xml</em></span>）会影响所有被部署的web应用程序、
							单独部署在Server端的web应用程序的配置<span class="emphasis"><em>（$CATALINA_HOME/conf/[enginename]/[hostname]/my-webapp-context.xml</em></span>）
							或者与web应用程序一起（<span class="emphasis"><em>your-webapp.war/META-INF/context.xml</em></span>）。从效率的角度说，
							我们推荐在web-app的内部配置的方式，因为仅仅使用JPA的应用程序会使用用户自定义的类装载器。
							更多具体有关可用的上下文路径的内容请参见Tomcat 5.x <a href="" target="_top">documentation</a>。</p>
</li>
</ol></div>
<ul type="disc">
<li><p>Tomcat 5.0.x/5.5.x</p></li>
<li><p>Tomcat 6.0.x</p></li>
</ul>
</div>
<p>所有Tomcat版本所需的最后一步，是在配置<code class="classname">LocalContainerEntityManagerFactoryBean</code>的时，使用
          相应的<code class="interfacename">LoadTimeWeaver</code>：</p>
<pre class="code">&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre>
<p>利用这种方法，依赖工具的JPA应用程序无需代理就可以在Tomcat上运行。这在宿主应用程序依赖不同的JPA实现时尤为重要，
          因为JPA转化器只适用于ClassLoader级别，它们之间是彼此隔离的。</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>如果Tomcat使用TopLink作为JPA提供者，请将核心的toplink jar包放在<span class="emphasis"><em>$CATALINA_HOME</em></span>/shared/lib文件夹中，而不再放到war中。</p>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h5 class="title">
<a name="orm-jpa-setup-lcemfb-agent"></a>12.6.1.3.2.&#160;使用VM代理的全局加载时织入</h5></div></div></div>
<p>对于需要类工具，同时现有的LoadTimeWeaver实现不提供这种支持的环境，JDK代理是唯一的解决方案。对于这种情况，Spring提供了
          需要特定于Spring（但非常常用）的VM代理（<code class="filename">spring-agent.jar</code>）的<code class="classname">InstrumentationLoadTimeWeaver</code>：</p>
<pre class="code">&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre>
<p>请注意在启动虚拟机时，同时启动Spring代理，方法是提供下列JVM选项：</p>
<pre class="code">-javaagent:/path/to/spring-agent.jar</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h5 class="title">
<a name="orm-jpa-setup-lcemfb-weaver"></a>12.6.1.3.3.&#160;上下文范围内的加载时织入配置</h5></div></div></div>
<p>自Spring 2.5，可以使用<code class="literal">context:load-time-weaver</code>元素来配置
          上下文范围的<code class="interfacename">LoadTimeWeaver</code>了。这种“全局”织入器由所有JPA
          <code class="classname">LocalContainerEntityManagerFactoryBeans</code>自动拣选。</p>
<p>这是配置加载时织入器的推荐方法，提供平台（ebLogic, OC4J, GlassFish, Tomcat, Resin, VM agent）的自动检测，以及织入器到所有织入器知道的bean的自动传播。</p>
<pre class="code">&lt;context:load-time-weaver/&gt;

&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    ...
&lt;/bean&gt;</pre>
<p>关于如何建立常用加载时织入的详细内容，请参见<a href="ch06s08.html#aop-aj-ltw-spring" title="6.8.4.5.&#160;Spring配置">第&#160;6.8.4.5&#160;节 “Spring配置”</a>一节，它涵盖了
          Tomcat、VM代理，以及WebLogic, OC4J, GlassFish和Resin。</p>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="orm-jpa-multiple-pu"></a>12.6.1.4.&#160;处理多持久化单元</h4></div></div></div>
<p>对于那些依靠多个持久化单元位置(例如存放在classpath中的多个jar中)的应用程序，
        Spring提供了作为中央仓库的<code class="literal">PersistenceUnitManager</code>，
        避免了持久化单元查找过程(的潜在开销)。缺省实现允许指定多个位置
        (默认情况下classpath会搜索META-INF/persistence.xml文件)，它们会被解析然后通过持久化单元名称被获取：</p>
<pre class="code">&lt;bean id="pum" class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager"&gt;
  &lt;property name="persistenceXmlLocation"&gt;
    &lt;list&gt;
     &lt;value&gt;org/springframework/orm/jpa/domain/persistence-multi.xml&lt;/value&gt;
     &lt;value&gt;classpath:/my/package/**/custom-persistence.xml&lt;/value&gt;
     &lt;value&gt;classpath*:META-INF/persistence.xml&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="dataSources"&gt;
   &lt;map&gt;
    &lt;entry key="localDataSource" value-ref="local-db"/&gt;
    &lt;entry key="remoteDataSource" value-ref="remote-db"/&gt;
   &lt;/map&gt;
  &lt;/property&gt;
  <em class="lineannotation"><span class="lineannotation">&lt;!-- if no datasource is specified, use this one --&gt;</span></em>
  &lt;property name="defaultDataSource" ref="remoteDataSource"/&gt;
&lt;/bean&gt;

&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="persistenceUnitManager" ref="pum"/&gt;
&lt;/bean&gt;</pre>
<p>要注意的是，缺省实现允许在将持久化单元信息传入JPA provider之前用
        <code class="literal">PersistenceUnitPostProcessor</code>(它允许选择持久化单元)修改它们，
        传入的过程可以是通过属性声明式地传入(影响其中所有的单元)或编程式地传入。
        如果没有指定persistenceUnitManager，<code class="literal">LocalContainerEntityManagerFactoryBean</code>
        会创建一个并在内部使用它。</p>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="orm-jpa-template"></a>12.6.2.&#160;<code class="classname">JpaTemplate</code> 和 <code class="classname">JpaDaoSupport</code></h3></div></div></div>
<p>每个基于JPA的DAO都将通过依赖注入接收一个 <code class="interfacename">EntityManagerFactory</code> 实例。
		这样的DAO可以通过指定的 <code class="interfacename">EntityManagerFactory</code> 来操作原生JPA的API进行数据访问，
		也可以直接使用Spring的 <code class="classname">JpaTemplate</code>：</p>
<pre class="code">&lt;beans&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre>
<pre class="code">public class JpaProductDao implements ProductDao {
  
    private JpaTemplate jpaTemplate;

    public void setEntityManagerFactory(EntityManagerFactory emf) {
        this.jpaTemplate = new JpaTemplate(emf);
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        return (Collection) this.jpaTemplate.execute(new JpaCallback() {
            public Object doInJpa(EntityManager em) throws PersistenceException {
                Query query = em.createQuery("from Product as p where p.category = :category");
                query.setParameter("category", category);
                List result = query.getResultList(); 
                <em class="lineannotation"><span class="lineannotation">// do some further processing with the result list</span></em>
                return result;
            }
        });
    }
}</pre>
<p>
	<code class="interfacename">JpaCallback</code> 实现允许任意类型的JPA数据访问。
<code class="classname">JpaTemplate</code> 将确保 <code class="interfacename">EntityManager</code> 正确地打开和关闭，并且能够自动地参与到事务中去。
除此之外，<code class="classname">JpaTemplate</code> 能够恰当地处理异常，确保资源的及时清理以及必要时的事务回滚。
Template实例不仅是线程安全的，而且它是可重用的，因而它能够作为实例变量被一个类持有。
注意， <code class="classname">JpaTemplate</code> 提供了简单的诸如find、load、merge等操作的快捷函数来替代默认的回调实现。</p>
<p>不仅如此，Spring还提供了一个方便的 <code class="classname">JpaDaoSupport</code> 基类，提供了
			<code class="literal">get/setEntityManagerFactory</code> 方法以及 <code class="literal">getJpaTemplate()</code> 方法供子类调用：</p>
<pre class="code">public class ProductDaoImpl extends JpaDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
        params.put("category", category);
        return getJpaTemplate().findByNamedParams("from Product as p where p.category = :category", params);
    }
}</pre>
<p>除了直接使用Spring的 <code class="classname">JpaTemplate</code>之外，也可以使用原生JPA的API来实现基于Spring的DAO，
		此时你需要自行明确地处理<code class="literal">EntityManager</code>。正如在相应的Hibernate章节描述的一样，这种做法的主要优
		点在于你的数据访问代码可以在整个过程中抛出checked exceptions。<code class="classname">JpaDaoSupport</code> 为这种情况提
		供了多种函数支持，包括获取和释放一个具备事务管理功能的 <code class="interfacename">EntityManager</code> 和相关的异常转化。</p>
<p><span class="emphasis"><em>JpaTemplate主要以JdoTemplate和HibernateTemplate的同胞而存在，为使用它的人们提供相同的风格。
      对于新启动的项目，要考虑采用原生的JPA风格编写数据访问对象的代码，基于通过JPA<code class="literal">@PersistenceContext</code>注解
      获取的一个“共享EntityManager”引用（利用Spring的<code class="classname">PersistenceAnnotationBeanPostProcessor</code>；详情如下。）</em></span></p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="orm-jpa-straight"></a>12.6.3.&#160;基于原生的JPA实现DAO</h3></div></div></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>虽然<code class="interfacename">EntityManagerFactory</code>实例是线程安全的，
        但<code class="interfacename">EntityManager</code>实例确实不是这样。被注入的JPA 
        <code class="interfacename">EntityManager</code>的行为和从应用服务器JNDI环境中获取的没有区别，
        和JPA规范定义的一样。如果存在一个被注入的JPA <code class="interfacename">EntityManager</code>，
        它会代理对当前事务化的<code class="interfacename">EntityManager</code>的所有调用；
        否则每个操作都会创建一个<code class="interfacename">EntityManager</code>，确保线程安全。</p>
</div>
<p>你完全可以使用原生的JPA的API进行编程，而无需对Spring产生任何依赖，这可以通过一个被注入的 
			<code class="interfacename">EntityManagerFactory</code> 或 <code class="interfacename">EntityManager</code> 来完成。
		注意，如果 <code class="classname">PersistenceAnnotationBeanPostProcessor</code> 被启用，Spring就能够识别字段或者方法级别的 <code class="interfacename">@PersistenceUnit</code> 和 
		<code class="interfacename">@PersistenceContext</code> 注解。相应的DAO实现看起来像这样：</p>
<pre class="code">public class ProductDaoImpl implements ProductDao {

    private EntityManagerFactory emf;

    @PersistenceUnit
    public void setEntityManagerFactory(EntityManagerFactory emf) {
        this.emf = emf;
    }

    public Collection loadProductsByCategory(String category) {
        EntityManager em = this.emf.createEntityManager();
        try {
             Query query = em.createQuery("from Product as p where p.category = ?1");
             query.setParameter(1, category);
             return query.getResultList();
        }
        finally {
            if (em != null) {
                em.close();
            }
        }
    }
}</pre>
<p>上述的DAO不对Spring产生任何依赖，而它就如同使用Spring的 <code class="classname">JpaTemplate</code> 那样，仍然非常适合
			在Spring的application context中进行配置。此外，这样的DAO可以利用注解来要求缺省<code class="interfacename">EntityManagerFactory</code> 的注入：</p>
<pre class="code">&lt;beans&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- bean post-processor for JPA annotations --&gt;</span></em>
  &lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</pre>
<p>注意：作为显式定义<code class="classname">PersistenceAnnotationBeanPostProcessor</code>的另一种方法，
      可以考虑在应用程序上下文配置中使用Spring 2.5的<code class="literal">context:annotation-config</code> XML元素。
      它会自动为基于注解的配置注册Spring所有标准的后置处理器（包括<code class="classname">CommonAnnotationBeanPostProcessor</code>等等）。</p>
<pre class="code">&lt;beans&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- post-processors for all standard config annotations --&gt;</span></em>
  &lt;context:annotation-config/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</pre>
<p>这类DAO的主要问题在于每次总是从工厂中获取一个新的 <code class="interfacename">EntityManager</code> 实例。
这一点可以通过对 <code class="interfacename">EntityManager</code> 而不是factory进行注入来解决：</p>
<pre class="code">public class ProductDaoImpl implements ProductDao {

    @PersistenceContext
    private EntityManager em;

    public Collection loadProductsByCategory(String category) {
       Query query = em.createQuery("from Product as p where p.category = :category");
       query.setParameter("category", category);
       return query.getResultList(); 
    }
}</pre>
<p>注意：<code class="literal">@PersistenceContext</code>注解有一个可选的属性<code class="literal">type</code>，它的默认值是
      <code class="literal">PersistenceContextType.TRANSACTION</code>。该默认需要你接收一个“共享EntityManager”代理。
      另一种方式，<code class="literal">PersistenceContextType.EXTENDED</code>则完全不同：它会产生一个所谓的“扩展EntityManager”,
      这个<span class="emphasis"><em>不是线程安全的</em></span>，因此不应该用在当前被访问的组件中，例如Spring管理的singleton bean。
      扩展的EntityManager只能用在有状态的组件中，例如，在会话中，EntityManager的生命周期与当前事务无关，完全取决于应用程序。</p>
<div class="sidebar">
<p class="title"><b>方法级和属性级的注入</b></p>
<p>表明依赖注入的注解(例如@PersistenceUnit和@PersistenceContext)能被用于类内的属性或者方法，
        这就叫做“方法/属性级注入”。属性级注解的使用十分简单、简洁，而方法级注解则允许处理注入的依赖。
        这两种情况对成员可见性(public, protected, private)均没有要求。</p>
<p>那么类级的注解又会怎么样呢？</p>
<p>在JEE 5平台上，它们是用于依赖声明，而非资源注入。</p>
</div>
<p>被注入的 <code class="interfacename">EntityManager</code> 由Spring管理（能够感知当前的事务）。
		值得注意的是，即使这种新的实现更倾向于方法级别的注入（使用 <code class="interfacename">EntityManager</code> 
		而不是 <code class="interfacename">EntityManagerFactory</code>），
		对于注解的使用，application context的XML配置则无需任何改变。</p>
<p>这种DAO风格的主要优点在于它仅仅依赖JPA，而无需依赖任何的Spring的类。除此之外，由于JPA的注解可被理解，注入能够被Spring容器自动应用。
从无入侵性的角度来说，这一点非常有吸引力，它对于JPA开发者来说也更自然。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="orm-jpa-exceptions"></a>12.6.4.&#160;异常转化</h3></div></div></div>
<p>然而，DAO不仅会抛出普通的 <code class="classname">PersistenceException</code> 异常（这是一个无需声明和捕获的unchecked exception），
			还会抛出诸如 <code class="classname">IllegalArgumentException</code> 和 <code class="classname">IllegalStateException</code> 之类的异常。
		这意味着，DAO的调用者只能以普通的错误来处理这些异常，除非完全依赖JPA自身的异常体系。因而，除非你将DAO的调用者绑定到具体的实现策略上去，
		否则将无法捕获特定的异常原因（诸如乐观锁异常）。这种折中平衡或许可以被接受，如果你的应用完全基于JPA或者无需进行特殊的异常处理。不过，
		Spring提供了一个允许你进行透明的异常转化的解决方案：通过使用 <code class="interfacename">@Repository</code> 注解：</p>
<pre class="code">@Repository
public class ProductDaoImpl implements ProductDao {

    <em class="lineannotation"><span class="lineannotation">// class body here...</span></em>

}</pre>
<pre class="code">&lt;beans&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- <code class="classname">Exception</code> translation bean post processor --&gt;</span></em>
  &lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</pre>
<p>后置处理器将自动地寻找所有的异常转化器（<code class="interfacename">PersistenceExceptionTranslator</code> 接口的实现），
			并通知所有标有 <code class="interfacename">@Repository</code> 注解的bean，从而能够使得被找到的异常转化器能够在抛出异常时进行相应的异常转化工作。</p>
<p>总之：DAO能够基于普通的Java持久层API和注解来实现，但同样也能享受到由Spring管理事务、IoC和透明的异常转化
			（转化成为Spring的异常体系）等好处。</p>
</div>
</div>

<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->