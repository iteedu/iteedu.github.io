<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->


<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="beans-annotation-config"></a>3.11.&#160;基于注解（Annotation-based）的配置</h2></div></div></div>
<p>在<a href="ch03s07.html#beans-factory-extension-bpp-examples-rabpp" title="3.7.1.2.&#160;RequiredAnnotationBeanPostProcessor示例">第&#160;3.7.1.2&#160;节 “<code class="classname">RequiredAnnotationBeanPostProcessor</code>示例”</a>一节中我们提到了基于注解的配置方式，使用<code class="interfacename">BeanPostProcessor</code>与注解是 Spring IoC 容器的一个普通扩展方法。例如，Spring 2.0 对必须的属性引入了<a href="ch25s03.html#metadata-annotations-required" title="25.3.1.&#160;@Required">@Required</a>注解。在 Spring 2.5中已经可以用注解的方式去驱动 Spring 的依赖注射了。更重要的是，<code class="interfacename">@Autowired</code>注解提供了与<a href="ch03s03.html#beans-factory-autowire" title="3.3.5.&#160;自动装配（autowire）协作者">第&#160;3.3.5&#160;节 “自动装配（autowire）协作者”</a>一节中描述的同样功能，并且提供了更细致的控制与更好的适应性。Spring 2.5 也支持 JSR-250 中的一些注解，例如<code class="interfacename">@Resource</code>，<code class="interfacename">@PostConstruct</code>，以及<code class="interfacename">@PreDestroy</code>。当然，要使注解可用，您必须使用 Java 5 (Tiger)或更新的版本，以使得可以访问源代码层次的注解。这些注解可以被注册为独立 bean 的定义，但它们也可以被隐式地注册，通过基于 XML 的配置方式，如下例（请注意包含 '<code class="literal">context</code>' 命名空间）：</p>
<pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       <em class="lineannotation"><span class="lineannotation">xmlns:context="http://www.springframework.org/schema/context"</span></em>
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;
               
     <em class="lineannotation"><span class="lineannotation">&lt;context:annotation-config/&gt;</span></em>
     
&lt;/beans&gt;</pre>
<p>（隐式注册 post-processors 包括了 <a href="" target="_top"><code class="classname">AutowiredAnnotationBeanPostProcessor</code></a>，<a href="" target="_top"><code class="classname">CommonAnnotationBeanPostProcessor</code></a>，<a href="" target="_top"><code class="classname">PersistenceAnnotationBeanPostProcessor</code></a>，也包括了前面提到的 <a href="" target="_top"><code class="classname">RequiredAnnotationBeanPostProcessor</code></a>。）</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="beans-autowired-annotation"></a>3.11.1.&#160;<code class="interfacename">@Autowired</code></h3></div></div></div>
<p><code class="interfacename">@Autowired</code> 注解可以用于“传统的”setter 方法，如下例：</p>
<pre class="code">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<p>这个注解也可以用于以属性为参数／多个参数的方法</p>
<pre class="code">public class MovieRecommender {

    private MovieCatalog movieCatalog;
    
    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<p><code class="interfacename">@Autowired</code>注解甚至可以用于构造器与字段：</p>
<pre class="code">public class MovieRecommender {

    @Autowired
    private MovieCatalog movieCatalog;
    
    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<p>也可以一种提供来自<code class="interfacename">ApplicationContext</code>的特殊类型的<span class="emphasis"><em>所有</em></span> beans，注解字段或者方法，例如：</p>
<pre class="code">public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<p>这同样适用于集合类型：</p>
<pre class="code">public class MovieRecommender {

    private Set&lt;MovieCatalog&gt; movieCatalogs;
    
    @Autowired
    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<p>甚至是 Maps 也可以这样注解，只要这个 Map 的 key 类型为 <code class="classname">String</code>。这个 Map 的 values 应该是已知的类型，并且 keys 应该包含符合 bean 的命名：</p>
<pre class="code">public class MovieRecommender {

    private Map&lt;String, MovieCatalog&gt; movieCatalogs;
    
    @Autowired
    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<p>在缺省情况下，当出现<span class="emphasis"><em>0</em></span>个候选的 beans时自动连接将失败；缺省行为把连接方法，构造器，字段假设为 <span class="emphasis"><em>required</em></span> 的依赖。这样的行为如下所示：</p>
<pre class="code">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired(required=false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>虽然当 <span class="emphasis"><em>一个类只有一个连接构造器时</em></span>它将被标记为 <span class="emphasis"><em>required</em></span>， 但是还是可以标记多个构造器的。在这种情况下，每一个构造器都有可能被认为是连接构造器， Spring 将会把依赖关系能够满足的构造器认为是<span class="emphasis"><em>greediest</em></span> 的构造器。</p>
</div>
<p><code class="interfacename">@Autowired</code>也能用于总所周知的“可解决的依赖”：<code class="interfacename">BeanFactory</code>接口，<code class="interfacename">ApplicationContext</code>接口，<code class="interfacename">ResourceLoader</code>接口，<code class="interfacename">ApplicationEventPublisher</code>接口，还有<code class="interfacename">MessageSource</code>接口。这些接口（还有它们的扩展，例如<code class="interfacename">ConfigurableApplicationContext</code>或者<code class="interfacename">ResourcePatternResolver</code>）将可以自动解决依赖，没有任何特殊必须的其它步骤需要。</p>
<pre class="code">public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="beans-autowired-annotation-qualifiers"></a>3.11.2.&#160;基于注解的自动连接微调</h3></div></div></div>
<p>因为通过类型的自动连接可能会有多个候选，因此经常需要在选择过程中加以控制。一种方法去完成这个控制就是使用<code class="interfacename">@Qualifier</code>注解。在最简单的情况下，您能够通过命名方式去实现这个自动连接：</p>
<pre class="code">public class MovieRecommender {

    @Autowired
    <span class="bold"><strong>@Qualifier("mainCatalog")</strong></span>
    private MovieCatalog movieCatalog;

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<p><code class="interfacename">@Qualifier</code>注解也能够被指定为构造器的参数或者方法的参数：</p>
<pre class="code">public class MovieRecommender {

    private MovieCatalog movieCatalog;
    
    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(<span class="bold"><strong>@Qualifier("mainCatalog")</strong></span> MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<p>您也可以创建您自定义的限定器注解。您只要在定义一个注解时提供<code class="interfacename">@Qualifier</code>注解就可以了：</p>
<pre class="code">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
<span class="bold"><strong>@Qualifier</strong></span>
public @interface Genre {

    String value();

}</pre>
<p>然后您就能够将这个自定义的限定器与参数用于自动连接的字段：</p>
<pre class="code">public class MovieRecommender {

    @Autowired
    <span class="bold"><strong>@Genre("Action")</strong></span>
    private MovieCatalog actionCatalog;
    
    private MovieCatalog comedyCatalog;
    
    @Autowired
    public void setComedyCatalog(<span class="bold"><strong>@Genre("Comedy")</strong></span> MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<p>下一步就是提供信息给候选的 bean 的定义。您能够添加<code class="literal">&lt;qualifier/&gt;</code>标签作为<code class="literal">&lt;bean/&gt;</code>标签的子元素，然后指定<code class="literal">'type'</code>还有<code class="literal">'value'</code>以匹配您的自定义限定器注解。类型必须匹配注解的全名，或者是一个不危险的、方便一点的名字，您也可以使用“短” 类名。参看下例：</p>
<pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        <span class="bold"><strong>&lt;qualifier type="Genre" value="Action"/&gt;</strong></span>
        <em class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></em>
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        <span class="bold"><strong>&lt;qualifier type="example.Genre" value="Comedy"/&gt;</strong></span>
        <em class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></em>
    &lt;/bean&gt;
    
    &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;
</pre>
<p>在下一节，题目是<a href="ch03s12.html" title="3.12.&#160;对受管组件的Classpath扫描">第&#160;3.12&#160;节 “对受管组件的Classpath扫描”</a>，您将看到使用XML提供给限定器元数据且基于注解的可选解决方案。特别地，请参看：<a href="ch03s12.html#beans-scanning-qualifiers" title="3.12.6.&#160;用注解提供限定符元数据">第&#160;3.12.6&#160;节 “用注解提供限定符元数据”</a>。</p>
<p>在某些情况下，有足够充分的理由去使用不带值的注解。这使得注解可以提供更多解决不同类型依赖的能力。例如，在 Internet 连接不可用时，您可以提供一个<span class="emphasis"><em>离线</em></span>的搜索目录。首先就要定义一个简单的注解：</p>
<pre class="code">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Offline {

}</pre>
<p>然后添加这个注解给字段作为自动连接：</p>
<pre class="code">public class MovieRecommender {

    @Autowired
    <span class="bold"><strong>@Offline</strong></span>
    private MovieCatalog offlineCatalog;

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<p>现在，这个 bean 的定影只组要一个限定器了：</p>
<pre class="code">&lt;bean class="example.SimpleMovieCatalog"&gt;
    <span class="bold"><strong>&lt;qualifier type="Offline"/&gt;</strong></span>
    <em class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></em>
&lt;/bean&gt;</pre>
<p>另外，也可以定制自己的限定器注解去使用命名的属性或者简单的<code class="literal">'value'</code>属性。如果自动连接时多个属性值被指定给了一个字段或者参数，那么一个 bean 的定义必须<span class="emphasis"><em>全部</em></span>匹配这些属性的值。例如，考虑如下的注解定义： </p>
<pre class="code">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MovieQualifier {

    String genre();
    
    Format format();

}</pre>
<p>在这种情况下，<code class="literal">Format</code>是一个枚举：</p>
<pre class="code">public enum Format {
    
    VHS, DVD, BLURAY
}</pre>
<p>这些字段将与自定义的限定器进行自动连接，包括了每个属性的值：<code class="literal">'genre'</code> 以及 <code class="literal">'format'</code>。</p>
<pre class="code">public class MovieRecommender {

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Action")
    private MovieCatalog actionVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Comedy")
    private MovieCatalog comedyVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.DVD, genre="Action")
    private MovieCatalog actionDvdCatalog;

    @Autowired
    @MovieQualifier(format=Format.BLURAY, genre="Comedy")
    private MovieCatalog comedyBluRayCatalog;
   
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<p>最终，这个 bean 的定义应该与限定器匹配的值。这个列子将说明bean 的<span class="emphasis"><em>元</em></span>属性可以用于替代<code class="literal">&lt;qualifier/&gt;</code>的子元素。那样的话，<code class="literal">&lt;qualifier/&gt;</code>以及它的属性将优先考虑，但是如果没有限定器的话（参看如下定义的后两个 bean ），自动连接机制将取消以<code class="literal">&lt;meta/&gt;</code>标签标记的值。</p>
<pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="MovieQualifier"&gt;
            &lt;attribute name="format" value="VHS"/&gt;
            &lt;attribute name="genre" value="Action"/&gt;
        &lt;/qualifier&gt;
        <em class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></em>
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="MovieQualifier"&gt;
            &lt;attribute name="format" value="VHS"/&gt;
            &lt;attribute name="genre" value="Comedy"/&gt;
        &lt;/qualifier&gt;
        <em class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></em>
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;meta key="format" value="DVD"/&gt;
        &lt;meta key="genre" value="Action"/&gt;
        <em class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></em>
    &lt;/bean&gt;
    
    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;meta key="format" value="BLURAY"/&gt;
        &lt;meta key="genre" value="Comedy"/&gt;
        <em class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></em>
    &lt;/bean&gt;

&lt;/beans&gt;</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="beans-custom-autowire-configurer"></a>3.11.3.&#160;<code class="classname">CustomAutowireConfigurer</code></h3></div></div></div>
<p><a href="" target="_top"><code class="classname">CustomAutowireConfigurer</code></a>是一个<code class="interfacename">BeanFactoryPostProcessor</code>，它可以使得在自动连接过程中做更多的自定义选择。特殊地，它允许您注册您自己的自定义限定器注解类型，甚至是它们没有使用 Spring 的<code class="interfacename">@Qualifier</code>注解标注它们自己。</p>
<pre class="code">&lt;bean id="customAutowireConfigurer" class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer"&gt;
    &lt;property name="customQualifierTypes"&gt;
        &lt;set&gt;
            &lt;value&gt;example.CustomQualifier&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
<p>请注意，<code class="interfacename">AutowireCandidateResolver</code>的实现将依赖于 Java 版本。如果在 Java 5 以下，限定器注解是不被支持的，因此自动连接后选将被<code class="literal">'autowire-candidate'</code>的值或者在<code class="literal">&lt;beans/&gt;</code>中元素<code class="literal">'default-autowire-candidates'</code>可用的模式所决定。如果运行在 Java 5 或者更新的版本上，<code class="interfacename">@Qualifier</code>注解或者任何自定义并在<code class="classname">CustomAutowireConfigurer</code>上注册过的注解都将正常工作。</p>
<p>忽略 Java 版本，决定“主要”的后选（当多个 beans 都配置为自动连接后选时）都是一样的：在这些后选中只要一个 bean 的<code class="literal">'primary'</code>属性定义为<code class="literal">'true'</code>即可。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="beans-resource-annotation"></a>3.11.4.&#160;<code class="interfacename">@Resource</code></h3></div></div></div>
<p>Spring 也提供了使用 JSR-250 bean 属性支持的注射方式。这是一种在 Java EE 5 与 Java 6 中普遍使用的方式（例如，在 JSF 1.2 中映射 beans 或者 JAX-WS 2.0 端点），对于Spring 托管的对象 Spring 可以以这种方式支持映射。</p>
<p><code class="interfacename">@Resource</code>有一个‘name’属性，缺省时，Spring 将这个值解释为要注射的 bean 的名字。换句话说，如果遵循<span class="emphasis"><em>by-name</em></span>的语法，如下例：</p>
<pre class="code">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    <span class="bold"><strong>@Resource(name="myMovieFinder")</strong></span>
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</pre>
<p>如果没有显式地给出名字，缺省的名字将继承于字段名或者 setter 方法名：如果是字段名，它将简化或者等价于字段名；如果是 setter 方法名，它将等价于 bean 属性名。下面这个例子使用名字 "movieFinder" 注射到它的 setter 方法：</p>
<pre class="code">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    <span class="bold"><strong>@Resource</strong></span>
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>注解提供的名字将被<code class="interfacename">BeanFactory</code>解析为 bean 名。请注意，这些名字也可能通过 JNDI 被解析（需要配置 Spring 的<a href="" target="_top"><code class="classname">SimpleJndiBeanFactory</code></a>）。不过，建议您依靠缺省行为与 Spring 的 JNDI 查找功能。</p>
</div>
<p>与<code class="interfacename">@Autowired</code>类似，<code class="interfacename">@Resource</code>可以回退为与标准 bean 类型匹配（例如，使用原始类型匹配取代特殊命名 bean）来解决著名的"resolvable dependencies"：<code class="interfacename">BeanFactory</code> 接口，<code class="interfacename">ApplicationContext</code> 接口，<code class="interfacename">ResourceLoader</code> 接口，<code class="interfacename">ApplicationEventPublisher</code> 接口以及 <code class="interfacename">MessageSource</code> 接口。请注意：这只有适用于未指定命名的<code class="interfacename">@Resource</code>！</p>
<p>下面的例子有一个<code class="literal">customerPreferenceDao</code>字段，首先要查找一个名叫 “customerPreferenceDao” 的 bean，然后回退为一个原始类型以匹配类型<code class="classname">CustomerPreferenceDao</code>。"context" 字段将基于已知解决的依赖类型<code class="interfacename">ApplicationContext</code>而被注入。</p>
<pre class="code">public class MovieRecommender {

    @Resource
    private CustomerPreferenceDao customerPreferenceDao;

    @Resource
    private ApplicationContext context;

    public MovieRecommender() {
    }

    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="beans-postconstruct-and-predestroy-annotations"></a>3.11.5.&#160;<code class="interfacename">@PostConstruct</code> 与 <code class="interfacename">@PreDestroy</code></h3></div></div></div>
<p><code class="classname">CommonAnnotationBeanPostProcessor</code> 不只是能识别<code class="interfacename">@Resource</code>注解，而且也能识别 JSR-250 <span class="emphasis"><em>lifecycle</em></span>注解。在 Spring 2.5 中，这些注解的描述请参看<a href="ch03s05.html#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&#160;初始化回调">initialization callbacks</a> 与 <a href="ch03s05.html#beans-factory-lifecycle-disposablebean" title="3.5.1.2.&#160;析构回调">destruction callbacks</a>节。<code class="classname">CommonAnnotationBeanPostProcessor</code>已经在 Spring 的<code class="interfacename">ApplicationContext</code>中注册，当一个方法带有这些注解之一时，将被在其生命周期与 Spring 生命周期接口的方法或者显式声明回调方法同一刻上调用。下面的例子里，缓存将预置于初始化与销毁阶段。</p>
<pre class="code">public class CachingMovieLister {

    @PostConstruct
    public void populateMovieCache() {
        <em class="lineannotation"><span class="lineannotation">// populates the movie cache upon initialization...</span></em>
    }
    
    @PreDestroy
    public void clearMovieCache() {
        <em class="lineannotation"><span class="lineannotation">// clears the movie cache upon destruction...</span></em>
    }
}</pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>
		关于组合不同的生命周期机制，请查看<a href="ch03s05.html#beans-factory-lifecycle-combined-effects" title="3.5.1.4.&#160;组合生命周期机制">第&#160;3.5.1.4&#160;节 “组合生命周期机制”</a>。</p>
</div>
</div>
</div>

<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->