<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->


<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="beans-factory-nature"></a>3.5.&#160;定制bean特性</h2></div></div></div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="beans-factory-lifecycle"></a>3.5.1.&#160;生命周期回调</h3></div></div></div>
<p>Spring提供了几个标志接口（marker interface），这些接口用来改变容器中bean的行为；它们包括<code class="literal">InitializingBean</code>和<code class="literal">DisposableBean</code>。实现这两个接口的bean在初始化和析构时容器会调用前者的<code class="methodname">afterPropertiesSet()</code>方法，以及后者的<code class="methodname">destroy()</code>方法。 </p>
<p>Spring在内部使用<code class="literal">BeanPostProcessor</code>实现来处理它能找到的任何标志接口并调用相应的方法。如果你需要自定义特性或者生命周期行为，你可以实现自己的 <code class="literal">BeanPostProcessor</code>。关于这方面更多的内容可以看<a href="ch03s07.html" title="3.7.&#160;容器扩展点">第&#160;3.7&#160;节 “容器扩展点”</a>。</p>
<p>下面讲述了几个生命周期标志接口。在附录中会提供相关的示意图来展示Spring如何管理bean，以及生命周期特性如何改变bean的内在特性。</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="beans-factory-lifecycle-initializingbean"></a>3.5.1.1.&#160;初始化回调</h4></div></div></div>
<p>实现<code class="literal">org.springframework.beans.factory.InitializingBean</code>接口允许容器在设置好bean的所有必要属性后，执行初始化事宜。<code class="interfacename">InitializingBean</code>接口仅指定了一个方法：</p>
<pre class="code">void afterPropertiesSet() throws Exception;</pre>
<p>通常，要避免使用<code class="interfacename">InitializingBean</code>接口并且不鼓励使用该接口，因为这样会将代码和Spring耦合起来，有一个可选的方案是，可以在Bean定义中指定一个普通的初始化方法，然后在XML配置文件中通过指定<code class="literal">init-method</code>属性来完成。如下面的定义所示：</p>
<pre class="code">&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt;</pre>
<pre class="code">public class ExampleBean {
    
    public void init() {
        <em class="lineannotation"><span class="lineannotation">// do some initialization work</span></em>
    }
}</pre>
<p>...效果与下面完全一样...</p>
<pre class="code">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;</pre>
<pre class="code">public class AnotherExampleBean implements InitializingBean {
    
    public void afterPropertiesSet() {
        <em class="lineannotation"><span class="lineannotation">// do some initialization work</span></em>
    }
}</pre>
<p>... 但是没有将代码与Spring耦合在一起。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="beans-factory-lifecycle-disposablebean"></a>3.5.1.2.&#160;析构回调</h4></div></div></div>
<p>实现<code class="interfacename">org.springframework.beans.factory.DisposableBean</code>接口的bean允许在容器销毁该bean的时候获得一次回调。<code class="interfacename">DisposableBean</code>接口也只规定了一个方法：</p>
<pre class="code">void destroy() throws Exception;</pre>
<p>通常，要避免使用<code class="interfacename">DisposableBean</code>标志接口而且不鼓励使用该接口，因为这样会将代码与Spring耦合在一起，有一个可选的方案是，在bean定义中指定一个普通的析构方法，然后在XML配置文件中通过指定<code class="literal">destroy-method</code>属性来完成。如下面的定义所示：</p>
<pre class="code">&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt;</pre>
<pre class="code">public class ExampleBean {

    public void cleanup() {
        <em class="lineannotation"><span class="lineannotation">// do some destruction work (like releasing pooled connections)</span></em>
    }
}</pre>
<p>...效果与下面完全一样...</p>
<pre class="code">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;</pre>
<pre class="code">public class AnotherExampleBean implements DisposableBean {

    public void destroy() {
        <em class="lineannotation"><span class="lineannotation">// do some destruction work (like releasing pooled connections)</span></em>
    }
}</pre>
<p>... 但是没有将代码与Spring耦合在一起。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="beans-factory-lifecycle-default-init-destroy-methods"></a>3.5.1.3.&#160;缺省的初始化和析构方法</h4></div></div></div>
<p>如果有人没有采用Spring所指定的<code class="interfacename">InitializingBean</code>和<code class="interfacename">DisposableBean</code>回调接口来编写初始化和析构方法回调，会发现自己正在编写的方法，其名称莫过于<code class="literal">init()</code>， <code class="literal">initialize()</code>，<code class="literal">dispose()</code>等等。这种生命周期回调方法的名称最好在一个项目范围内标准化，这样团队中的开发人员就可以使用同样的方法名称，并且确保了某种程度的一致性。</p>
<p>Spring容器通过配置可以实现对<span class="emphasis"><em>每个</em></span> bean初始化时的查找和销毁时的回调调用。这也就是说，一个应用的开发者可以借助于初始化的回调方法<code class="literal">init()</code> 轻松的写一个类（不必想XML配置文件那样为每个bean都配置一个<code class="literal">'init-method="init"'</code>属性）。Spring IoC容器在创建bean的时候<span class="emphasis"><em>将</em></span>调用这个方法 （这和之前描述的标准生命周期回调一致）。</p>
<p>		为了完全弄清如何使用该特性，让我们看一个例子。出于示范的目的，假设一个项目的编码规范中约定所有的初始化回调方法都被命名为<code class="literal">init()</code>而析构回调方法被命名为<code class="literal">destroy()</code>。遵循此规则写成的类如下所示：</p>
<pre class="code">public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    <em class="lineannotation"><span class="lineannotation">// this is (unsurprisingly) the initialization callback method</span></em>
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}</pre>
<pre class="code">&lt;beans <span class="bold"><strong>default-init-method="init"</strong></span>&gt;

    &lt;bean id="blogService" class="com.foo.DefaultBlogService"&gt;
        &lt;property name="blogDao" ref="blogDao" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre>
<p>注意在顶级的<code class="literal">&lt;beans/&gt;</code>元素中的<code class="literal">'default-init-method'</code>属性。这个属性的含义是Spring IoC容器在bean创建和装配的时候会将<code class="literal">'init'</code>方法作为实例化回调方法。如果类有这个方法，则会在适当的时候执行。</p>
<p>销毁回调方法配置是相同的 (XML配置)，在顶级的<code class="literal">&lt;beans/&gt;</code>元素中使用 <code class="literal">'default-destroy-method'</code> 属性。</p>
<p>使用这个功能可以把你从位每个bean指定初始化和销毁回调的繁杂工作中解救出来。为了一致性，应该强制性的为初始化和销毁回调方法采用一致的命名规则。</p>
<p>当已经存在的类的初始化方法的命名规则与惯例有差异的时候，你应该<span class="emphasis"><em>始终</em></span>使用<code class="literal">&lt;bean/&gt;</code>元素中的<code class="literal">'init-method'</code>和<code class="literal">'destroy-method'</code>属性(在XML配置中)来覆盖默认的方式。</p>
<p>最后，请注意Spring容器保证在bean的所有依赖都满足后立即执行配置的初始化回调。这意味着初始化回调在原生bean上调用，这也意味着这个时候任何诸如AOP拦截器之类的将不能被应用。一个目标bean是<span class="emphasis"><em>首先</em></span>完全创建，<span class="emphasis"><em>然后</em></span>才应用诸如AOP代理等拦截器链。注意，如果目标bean和代理是分开定义了，你的代码甚至可以绕开代理直接和原生bean通信。因此，在初始化方法上使用拦截器将产生未知的结果，因为这将目标bean和它的代理/拦截器的生命周期绑定并且留下了和初始bean直接通信这样奇怪的方式。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="beans-factory-lifecycle-combined-effects"></a>3.5.1.4.&#160;组合生命周期机制</h4></div></div></div>
<p>As of Spring 2.5, there are three options for controlling bean
        lifecycle behavior: the <a href="ch03s05.html#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&#160;初始化回调">
						<code class="interfacename">InitializingBean</code>
					</a>
        and <a href="ch03s05.html#beans-factory-lifecycle-disposablebean" title="3.5.1.2.&#160;析构回调">
						<code class="interfacename">DisposableBean</code>
					</a>
        callback interfaces; custom <code class="literal">init()</code> and
        <code class="literal">destroy()</code> methods; and the <a href="ch03s11.html#beans-postconstruct-and-predestroy-annotations" title="3.11.5.&#160;@PostConstruct 与 @PreDestroy">
						<code class="interfacename">@PostConstruct</code>
        and <code class="interfacename">@PreDestroy</code>
        annotations</a>.</p>
<p>在Spring2.5中有三种方式可以控制bean的生命周期行为：<a href="ch03s05.html#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&#160;初始化回调">
						<code class="interfacename">InitializingBean</code>
					</a>
         和<a href="ch03s05.html#beans-factory-lifecycle-disposablebean" title="3.5.1.2.&#160;析构回调">
						<code class="interfacename">DisposableBean</code>
					</a>
         回调接口;自定义<code class="literal">init()</code> 和
        <code class="literal">destroy()</code> 方法; <a href="ch03s11.html#beans-postconstruct-and-predestroy-annotations" title="3.11.5.&#160;@PostConstruct 与 @PreDestroy">
						<code class="interfacename">@PostConstruct</code>
         和<code class="interfacename">@PreDestroy</code>
        annotations</a>.</p>
<p>当组合不同的生命周期机制时 - 例如，类层次中使用了不同的生命周期机制 - 开发者必须注意这些机制的应用顺序，下面是初始化方法中的顺序：</p>
<div class="itemizedlist"><ul type="disc">
<li><p>
							<code class="interfacename">@PostConstruct</code>元注释</p></li>
<li><p>
							<code class="interfacename">InitializingBean</code>的<code class="literal">afterPropertiesSet()</code>定义</p></li>
<li><p>自定义<code class="literal">init()</code>方法配置</p></li>
</ul></div>
<p>析构方法调用顺序是相同的:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>
							<code class="interfacename">@PreDestroy</code>元注释</p></li>
<li><p>
							<code class="interfacename">DisposableBean</code>的<code class="literal">destroy()</code>定义</p></li>
<li><p>自定义<code class="literal">destroy()</code>方法</p></li>
</ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>如果bean存在多种的生命周期机制配置并且每种机制都配置为不同的方法名，
          	那所有配置的方法将会按照上面的顺利执行。然而如果配置了相同的方法名 - 例如，
          <code class="literal">init()</code>初始化方法 - 采用多种机制配置后，只会执行一次。</p>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="beans-factory-shutdown"></a>3.5.1.5.&#160;在非web应用中优雅地关闭Spring IoC容器</h4></div></div></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>在基于web的<code class="interfacename">ApplicationContext</code>实现中已有相应的代码来处理关闭web应用时如何恰当地关闭Spring IoC容器。</p>
</div>
<p>如果你正在一个非web应用的环境下使用Spring的IoC容器，例如在桌面富客户端环境下，你想让容器优雅的关闭，并调用singleton bean上的相应析构回调方法，你需要在JVM里注册一个“关闭钩子”（shutdown hook）。这一点非常容易做到，并且将会确保你的Spring IoC容器被恰当关闭，以及所有由单例持有的资源都会被释放（当然，为你的单例配置销毁回调，并正确实现销毁回调方法，依然是你的工作）。</p>
<p>为了注册“关闭钩子”，你只需要简单地调用在<code class="classname">AbstractApplicationContext</code>实现中的<code class="methodname">registerShutdownHook()</code>方法即可。也就是：</p>
<pre class="code">import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        AbstractApplicationContext ctx
            = new ClassPathXmlApplicationContext(new String []{"beans.xml"});

        <em class="lineannotation"><span class="lineannotation">// add a shutdown hook for the above context... </span></em>
        ctx.registerShutdownHook();

        <em class="lineannotation"><span class="lineannotation">// app runs here...</span></em>
					<em class="lineannotation"><span class="lineannotation">// main method exits, hook is called prior to the app shutting down...</span></em>
    }
}</pre>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="beans-factory-aware"></a>3.5.2.&#160;了解自己</h3></div></div></div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="beans-factory-aware-beanfactoryaware"></a>3.5.2.1.&#160;
					<code class="interfacename">BeanFactoryAware</code>
				</h4></div></div></div>
<p>对于实现了<code class="literal">org.springframework.beans.factory.BeanFactoryAware</code>接口的类，当它被BeanFactory创建后，它会拥有一个指向创建它的BeanFactory的引用。</p>
<pre class="code">public interface BeanFactoryAware {

    void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}</pre>
<p>这样bean可以以编程的方式操控创建它们的<code class="interfacename">BeanFactory</code>，当然我们可以将引用的BeanFactory造型（cast）为已知的子类型来获得更多的功能。它主要用于通过编程来取得BeanFactory所管理的其他bean。虽然在有些场景下这个功能很有用，但是一般来说应该尽量避免使用，因为这样将使代码与Spring耦合在一起，而且也有违反转控制的原则（协作者应该作为属性提供给bean）。</p>
<p>与<code class="interfacename">BeanFactoryAware</code>等效的另一种选择是使用<code class="classname">org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean</code>。不过该方法依然没有降低与Spring的耦合，但是它并没有像<code class="interfacename">BeanFactoryAware</code>那样，违反IoC原则。）</p>
<p>
					<code class="classname">ObjectFactoryCreatingFactoryBean</code>是<a href="ch03s07.html#beans-factory-extension-factorybean" title="3.7.3.&#160;使用FactoryBean定制实例化逻辑">
						<code class="interfacename">FactoryBean</code>
					</a>的一个实现，它返回一个指向工厂对象的引用，该对象将执行bean的查找。<code class="classname">ObjectFactoryCreatingFactoryBean</code>类实现了<code class="interfacename">BeanFactoryAware</code>接口；被实际注入到客户端bean的是<code class="interfacename">ObjectFactory</code>接口的一个实例。这是Spring提供的一个接口（因而依旧没有完全与Spring解耦），客户端可以使用<code class="interfacename">ObjectFactory</code>的<code class="methodname">getObject()</code>方法来查找bean（在其背后，<code class="interfacename">ObjectFactory</code>实例只是简单的将调用委派给<code class="interfacename">BeanFactory</code>，让其根据bean的名称执行实际的查找）。你要做的全部事情就是给<code class="classname">ObjectFactoryCreatingFactoryBean</code>提供待查找bean的名字。让我们看一个例子：</p>
<pre class="code">package x.y;

public class NewsFeed {
    
    private String news;

    public void setNews(String news) {
        this.news = news;
    }

    public String getNews() {
        return this.toString() + ": '" + news + "'";
    }
}</pre>
<pre class="code">package x.y;

import org.springframework.beans.factory.ObjectFactory;

public class NewsFeedManager {

    private ObjectFactory factory;

    public void setFactory(ObjectFactory factory) {
        this.factory = factory;
    }

    public void printNews() {
        // here is where the lookup is performed; note that there is no
        // need to hard code the name of the bean that is being looked up...
        NewsFeed news = (NewsFeed) factory.getObject();
        System.out.println(news.getNews());
    }
}</pre>
<p>下述是XML配置：</p>
<pre class="code">&lt;beans&gt;
    &lt;bean id="newsFeedManager" class="x.y.NewsFeedManager"&gt;
        &lt;property name="factory"&gt;
            &lt;bean
class="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"&gt;
                &lt;property name="targetBeanName"&gt;
                    &lt;idref local="newsFeed" /&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="newsFeed" class="x.y.NewsFeed" scope="prototype"&gt;
        &lt;property name="news" value="... that's fit to print!" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre>
<p>这里有一个测试用的小程序：在<code class="classname">NewsFeedManager</code>的<code class="methodname">printNews()</code>方法里，每次针对被注入的<code class="interfacename">ObjectFactory</code>的调用，实际上返回的是一个新的（prototype）<code class="literal">newsFeed</code> bean实例。</p>
<pre class="code">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import x.y.NewsFeedManager;

public class Main {

    public static void main(String[] args) throws Exception {

        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        NewsFeedManager manager = (NewsFeedManager) ctx.getBean("newsFeedManager");
        manager.printNews();
        manager.printNews();
    }
}</pre>
<p>上述程序的执行输出如下所示（当然，返回结果会根据你机器的不同而不同）</p>
<pre class="code">x.y.NewsFeed@1292d26: '... that's fit to print!'
x.y.NewsFeed@5329c5: '... that's fit to print!'</pre>
<p>在Spring2.5中，可以利用<code class="interfacename">BeanFactory</code>的自动装配作为实现 <code class="interfacename">BeanFactoryAware</code>接口的可选方式。
        "传统"的<code class="literal">constructor</code>和<code class="literal">byType</code> 自动装配模式（在<a href="ch03s03.html#beans-factory-autowire" title="3.3.5.&#160;自动装配（autowire）协作者">第&#160;3.3.5&#160;节 “自动装配（autowire）协作者”</a>中有描述）对无论是构造器参数或setter方法都能提供 <code class="interfacename">BeanFactory</code>类型的 依赖。这有更多的灵活性（包括自动装配属性和多参数方法）。如果使用新的基于元注释的自动装配特性，只要属性、
        构造器、方法包含有<code class="interfacename">@Autowired</code>元注释时，<code class="interfacename">BeanFactory</code>将会自动装配到对应的属性、构造器、方法中。请参阅<a href="ch03s11.html#beans-autowired-annotation" title="3.11.1.&#160;@Autowired">第&#160;3.11.1&#160;节 “<code class="interfacename">@Autowired</code>”</a>。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="beans-factory-aware-beannameaware"></a>3.5.2.2.&#160;
					<code class="interfacename">BeanNameAware</code>
				</h4></div></div></div>
<p>如果一个bean实现了<code class="interfacename">org.springframework.beans.factory.BeanNameAware</code>接口，并且部署入<code class="interfacename">BeanFactory</code>，
        <code class="interfacename">BeanFactory</code>将通过（BeanNameAware）接口来通知这个bean部署在其下的bean来调用这个bean。这个回调方法应该在bean的所有一般属性被设置后调用，但应该在初始化回调之前，如<code class="interfacename">InitializingBean</code>的<span class="emphasis"><em>afterPropertiesSet</em></span>方法或者自定义的初始化方法。</p>
</div>
</div>
</div>

<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->