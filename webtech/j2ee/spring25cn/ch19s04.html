<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->


<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="jms-receiving"></a>19.4.&#160;接收消息</h2></div></div></div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="jms-receiving-sync"></a>19.4.1.&#160;同步接收</h3></div></div></div>
<p>虽然JMS一般都和异步处理相关，但它也可以同步的方式使用消息。可重载的 <code class="methodname">receive(..)</code> 方法提供了这种功能。在同步接收中，接收线程被阻塞直至获得一个消息，有可能出现线程被无限阻塞的危险情况。属性 <span class="property">receiveTimeout</span> 指定了接收器可等待消息的延时时间。
        </p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="jms-asynchronousMessageReception"></a>19.4.2.&#160;异步接收 - 消息驱动的POJO</h3></div></div></div>
<p>类似于EJB世界里流行的消息驱动Bean（MDB），消息驱动POJO（MDP）作为JMS消息的接收器。MDP的一个约束（但也请看下面的有关 <code class="interfacename">javax.jms.MessageListener</code> 类的讨论）是它必须实现 <code class="interfacename">javax.jms.MessageListener</code> 接口。另外当你的POJO将以多线程的方式接收消息时必须确保你的代码是线程-安全的。
  		</p>
<p>以下是MDP的一个简单实现:</p>
<pre class="code">import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

public class ExampleListener implements MessageListener {

    public void onMessage(Message message) {
        if (message instanceof TextMessage) {
            try {
                System.out.println(((TextMessage) message).getText());
            }
            catch (JMSException ex) {
                throw new RuntimeException(ex);
            }
        }
        else {
            throw new IllegalArgumentException("Message must be of type TextMessage");
        }
    }
}</pre>
<p>一旦你实现了 <code class="interfacename">MessageListener</code> 后就可以创建一个消息侦听容器。
</p>
<p>请看下面例子是如何定义和配置一个随Sping发行的消息侦听容器的（这个例子用 <code class="classname">DefaultMessageListenerContainer</code>）
</p>
<pre class="code"><em class="lineannotation"><span class="lineannotation">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span></em>
&lt;bean id="messageListener" class="jmsexample.ExampleListener" /&gt;

<em class="lineannotation"><span class="lineannotation">&lt;!-- and this is the message listener container --&gt;</span></em>
&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    <span class="bold"><strong>&lt;property name="messageListener" ref="messageListener" /&gt;</strong></span>
&lt;/bean&gt;</pre>
<p>关于各个消息侦听容器实现的特色请参阅相关的Spring Javadoc文档。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="jms-receiving-async-session-aware-message-listener"></a>19.4.3.&#160;<code class="interfacename">SessionAwareMessageListener</code>接口</h3></div></div></div>
<p><code class="interfacename">SessionAwareMessageListener</code> 接口是一个Spring专门用来提供类似于JMS <code class="interfacename">MessageListener</code> 的接口，也提供了从接收 <code class="interfacename">Message</code> 来访问JMS <code class="interfacename">Session</code> 的消息处理方法。
</p>
<pre class="code">package org.springframework.jms.listener;

public interface SessionAwareMessageListener {

    void onMessage(Message message, Session session) <span class="bold"><strong>throws JMSException</strong></span>;
}</pre>
<p>如果你希望你的MDP可以响应所有接收到的消息（使用 <code class="literal">onMessage(Message, Session)</code> 方法提供的 <code class="interfacename">Session</code>）那么你可以选择让你的MDP实现这个接口（优先于标准的JMS <code class="interfacename">MessageListener</code> 接口)。所有随Spring发行的支持MDP的消息侦听容器都支持 <code class="interfacename">MessageListener</code> 或 <code class="interfacename">SessionAwareMessageListener</code> 接口的实现。要注意的是实现了 <code class="interfacename">SessionAwareMessageListener</code> 接口的类通过接口和Spring有了耦合。是否选择使用它完全取决于开发者或架构师。
        </p>
<p>请注意 <code class="interfacename">SessionAwareMessageListener</code> 接口的 <code class="literal">'onMessage(..)'</code> 方法会抛出 <code class="classname">JMSException</code>异常。和标准JMS <code class="interfacename">MessageListener</code> 接口相反，当使用 <code class="interfacename">SessionAwareMessageListener</code> 接口时，客户端代码负责处理任何抛出的异常。
        </p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="jms-receiving-async-message-listener-adapter"></a>19.4.4.&#160;<code class="classname">MessageListenerAdapter</code></h3></div></div></div>
<p><code class="classname">MessageListenerAdapter</code> 类是Spring的异步支持消息类中的不变类（final class）：简而言之，它允许你几乎将 <span class="emphasis"><em>任意</em></span> 一个类做为MDP显露出来（当然有某些限制）。
  	    </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>如果你使用JMS 1.0.2 API，你将使用和 <code class="classname">MessageListenerAdapter</code> 一样功能的类 <code class="classname">MessageListenerAdapter102</code>。
  	        </p>
</div>
<p>考虑如下接口定义。注意虽然这个接口既不是从 <code class="interfacename">MessageListener</code> 也不是从 <code class="interfacename">SessionAwareMessageListener</code> 继承来得，但通过 <code class="classname">MessageListenerAdapter</code> 类依然可以当作一个MDP来使用。同时也请注意各种消息处理方法是如何根据他们可以接收并处理消息的内容来进行强类型匹配的。
        </p>
<pre class="code">public interface MessageDelegate {

    void handleMessage(String message);

    void handleMessage(Map message);

    void handleMessage(byte[] message);

    void handleMessage(Serializable message);
}</pre>
<pre class="code">public class DefaultMessageDelegate implements MessageDelegate {
    <em class="lineannotation"><span class="lineannotation">// implementation elided for clarity...</span></em>
}</pre>
<p>特别请注意，上面的 <code class="interfacename">MessageDelegate</code> 接口（上文中 <code class="classname">DefaultMessageDelegate</code> 类）的实现完全 <span class="emphasis"><em>不</em></span> 依赖于JMS。它是一个真正的POJO，我们可以通过如下配置把它设置成MDP。
        </p>
<pre class="code"><em class="lineannotation"><span class="lineannotation">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span></em>
<span class="bold"><strong>&lt;bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="jmsexample.DefaultMessageDelegate"/&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</strong></span>

<em class="lineannotation"><span class="lineannotation">&lt;!-- and this is the message listener container... --&gt;</span></em>
&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    <span class="bold"><strong>&lt;property name="messageListener" ref="messageListener" /&gt;</strong></span>
&lt;/bean&gt;</pre>
<p>下面是另外一个只能处理接收JMS <code class="interfacename">TextMessage</code> 消息的MDP示例。注意消息处理方法是如何实际调用 <code class="literal">'receive'</code> （在 <code class="classname">MessageListenerAdapter</code> 中默认的消息处理方法的名字是 <code class="literal">'handleMessage'</code>）的，但是它是可配置的（你下面就将看到）。注意 <code class="literal">'receive(..)'</code> 方法是如何使用强制类型来只接收和处理JMS <code class="interfacename">TextMessage</code>消息的。
        </p>
<pre class="code">public interface TextMessageDelegate {

    void receive(TextMessage message);
}</pre>
<pre class="code">public class DefaultTextMessageDelegate implements TextMessageDelegate {
    <em class="lineannotation"><span class="lineannotation">// implementation elided for clarity...</span></em>
}</pre>
<p>辅助的 <code class="classname">MessageListenerAdapter</code> 类配置文件类似如下：
        </p>
<pre class="code">&lt;bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="jmsexample.DefaultTextMessageDelegate"/&gt;
    &lt;/constructor-arg&gt;
    &lt;property name="defaultListenerMethod" value="receive"/&gt;
    <em class="lineannotation"><span class="lineannotation">&lt;!-- we <span class="bold"><strong>don't</strong></span> want automatic message context extraction --&gt;</span></em>
    &lt;property name="messageConverter"&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
<p>请注意，如果上面的 <code class="literal">'messageListener'</code> 收到一个不是 <code class="interfacename">TextMessage</code> 类型的JMS <code class="interfacename">Message</code>，将会产生一个 <code class="classname">IllegalStateException</code> 异常（随之产生的其他异常只被捕获而不处理）。
        </p>
<p><code class="classname">MessageListenerAdapter</code> 还有一个功能就是如果处理方法返回一个非空值，它将自动返回一个响应 <code class="interfacename">消息</code>。
        </p>
<p>请看下面的接口及其实现：</p>
<pre class="code">public interface ResponsiveTextMessageDelegate {

    <em class="lineannotation"><span class="lineannotation"><span class="bold"><strong>// notice the return type...</strong></span></span></em>
    String receive(TextMessage message);
}</pre>
<pre class="code">public class DefaultResponsiveTextMessageDelegate implements ResponsiveTextMessageDelegate {
    <em class="lineannotation"><span class="lineannotation">// implementation elided for clarity...</span></em>
}</pre>
<p>如果上面的 <code class="classname">DefaultResponsiveTextMessageDelegate</code> 和 <code class="classname">MessageListenerAdapter</code> 联合使用，那么任意从执行 <code class="literal">'receive(..)'</code> 方法返回的非空值都将（缺省情况下）转换成一个 <code class="interfacename">TextMessage</code>。这个返回的 <code class="interfacename">TextMessage</code> 将被发送到原来的 <code class="interfacename">Message</code> 中JMS Reply-To属性定义的 <code class="interfacename">目的地</code>（如果存在），或者是 <code class="classname">MessageListenerAdapter</code> 设置（如果配置了）的缺省 <code class="interfacename">目的地</code>；如果没有定义 <code class="interfacename">目的地</code>，那么将产生一个 <code class="classname">InvalidDestinationException</code> 异常（此异常将不会只被捕获而不处理，它 <span class="emphasis"><em>将</em></span>沿着调用堆栈上传）。
        </p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="jms-tx-participation"></a>19.4.5.&#160;事务中的消息处理</h3></div></div></div>
<p>在消息监听器的调用中使用事务只需要重新配置监听器容器</p>
<p>通过监听器容器定义中的 <code class="literal">sessionTransacted</code> 标记可以轻松的激活本地资源事务。每次消息监听器的调用都在激活的JMS事务中执行，执行失败时，消息接收将发生回滚。这个本地事务还将包含响应信息的发送（通过 <code class="interfacename">SessionAwareMessageListener</code>），但其它资源的操作（例如访问数据库）是独立的。经常会发生类似于数据库处理已提交但消息处理提交失败的情况，因此需要在监听器的实现中进行重复消息的检测。
		</p>
<pre class="code">&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    &lt;property name="messageListener" ref="messageListener"/&gt;
    <span class="bold"><strong>&lt;property name="sessionTransacted" value="true"/&gt;</strong></span>
&lt;/bean&gt;</pre>
<p>当参与外部管理的事务时，你需要使用支持外来事务的监听器容器：通常是 <code class="classname">DefaultMessageListenerContainer</code> 来配置事务管理器。
			</p>
<p>参与XA事务时，消息监听器容器需要配置 <code class="classname">JtaTransactionManager</code>（默认会委托给J2EE服务器事务子系统）。注意以下JMS ConnectionFactory需要具有XA能力并注册JTA事务协调器！（参考你所使用的J2EE服务器中JNDI资源的配置。）这样，消息接收就像数据库访问一样作为同一个事务的一部分（具有统一提交的语义，仅仅增加了XA事务日志的额外开销）。
			</p>
<pre class="code">&lt;bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;
</pre>
<p>然后你只需要把它添加到早先配置好的容器中。这个容器将处理剩下的事情。</p>
<pre class="code">&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    &lt;property name="messageListener" ref="messageListener"/&gt;
    <span class="bold"><strong>&lt;property name="transactionManager" ref="transactionManager"/&gt;</strong></span>
&lt;/bean&gt;</pre>
</div>
</div>

<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->