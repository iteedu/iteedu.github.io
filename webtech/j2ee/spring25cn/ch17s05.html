<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->


<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="remoting-web-services"></a>17.5.&#160;Web Services</h2></div></div></div>
<p>Spring为标准Java web服务API提供了全面的支持:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>使用JAX-RPC暴露web服务</p></li>
<li><p>使用JAX-RPC访问web服务</p></li>
<li><p>使用JAX-WS暴露web服务</p></li>
<li><p>使用JAX-WS访问web服务</p></li>
</ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>为什么有2个标准的Java web服务APIs?</p>
<p>JAX-RPC 1.1 在J2EE 1.4 中是标准的web服务API。正像其名称所示，它关注于RPC绑定而且在最近几年越来越不流行。最终被Java EE 5中的JAX-WS 2.0所取代，JAX-WS 2.0不但在绑定方面更灵活，而且也是完全基于annotation的。JAX-WS 2.1也被包含在Java 6中(更详细的说是在Sun JDK 1.6.0_04和更高版本中，低版本的Sun JDK 1.6.0包含JAX-WS 2.0)，它与JDK内置的HTTP服务器集成。</p>
<p>Spring 同时支持两个标准Java web服务API。选择谁主要看运行平台：在JDK 1.4 / J2EE 1.4上，唯一的选择是JAX-RPC。在Java EE 5 / Java 6上显然应该选JAX-WS。运行Java 5的J2EE 1.4环境上，你可以选择插入一个JAX-WS provider；请查看你的J2EE服务器文档。</p>
</div>
<p>除了在Spring Core中支持JAX-RPC and JAX-WS，Spring portfolio也提供了一种特性<a href="" target="_top">Spring Web Services</a>，一个为优先授权和文档驱动的web服务所提供的方案 - 非常建议用来创建高级并具有前瞻性的web服务。<a href="" target="_top">XFire</a>是最后但不是唯一的Spring内置支持可以让你将Spring管理的bean暴露为web服务的方式。</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="remoting-web-services-jaxrpc-export"></a>17.5.1.&#160;使用JAX-RPC暴露基于servlet的web服务</h3></div></div></div>
<p>Spring为JAX-RPC servlet的端点实现提供了一个方便的基类 - <code class="classname">ServletEndpointSupport</code>. 未来暴露我们的 <code class="interfacename">AccountService</code>我们扩展Spring的<code class="classname">ServletEndpointSupport</code>类并在这里实现了我们的业务逻辑，通常将调用交给业务层。</p>
<pre class="code"><em class="lineannotation"><span class="lineannotation">/**
 * JAX-RPC compliant RemoteAccountService implementation that simply delegates
 * to the AccountService implementation in the root web application context.
 *
 * This wrapper class is necessary because JAX-RPC requires working with dedicated
 * endpoint classes. If an existing service needs to be exported, a wrapper that
 * extends ServletEndpointSupport for simple application context access is
 * the simplest JAX-RPC compliant way.
 *
 * This is the class registered with the server-side JAX-RPC implementation.
 * In the case of Axis, this happens in "server-config.wsdd" respectively via
 * deployment calls. The web service engine manages the lifecycle of instances
 * of this class: A Spring application context can just be accessed here.
 */</span></em>import org.springframework.remoting.jaxrpc.ServletEndpointSupport;

public class AccountServiceEndpoint extends ServletEndpointSupport implements RemoteAccountService {
    
    private AccountService biz;
	
    protected void onInit() {
        this.biz = (AccountService) getWebApplicationContext().getBean("accountService");
    }

    public void insertAccount(Account acc) throws RemoteException {
        biz.insertAccount(acc);
    }
  
    public Account[] getAccounts(String name) throws RemoteException {
        return biz.getAccounts(name);
    }
}</pre>
<p>AccountServletEndpoint需要在Spring中同一个上下文的web应用里运行，以获得对Spring的访问能力。如果使用Axis，把<code class="classname">AxisServlet</code>定义复制到你的<code class="filename">'web.xml'</code>中，并且在<code class="filename">'server-config.wsdd'</code>中设置端点（或使用发布工具）。参看JPetStore这个例子中<code class="interfacename">OrderService</code>是如何用Axis发布成一个Web服务的。
			</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="remoting-web-services-jaxrpc-access"></a>17.5.2.&#160;使用JAX-RPC访问web服务</h3></div></div></div>
<p>Spring提供了两个工厂bean用来创建Web服务代理，<code class="classname">LocalJaxRpcServiceFactoryBean</code> 和 <code class="classname">JaxRpcPortProxyFactoryBean</code>。前者只返回一个JAX-RPC服务类供我们使用。后者是一个全功能的版本，可以返回一个实现我们业务服务接口的代理。本例中，我们使用后者来为前面段落中暴露的<code class="interfacename">AccountService</code>端点创建一个代理。你将看到Spring对Web服务提供了极好的支持，只需要很少的代码 - 大多数都是通过类似下面的Spring配置文件：
			</p>
<pre class="code">&lt;bean id="accountWebService" class="org.springframework.remoting.jaxrpc.JaxRpcPortProxyFactoryBean"&gt;
    &lt;property name="serviceInterface" value="example.RemoteAccountService"/&gt;
    &lt;property name="wsdlDocumentUrl" value="http://localhost:8080/account/services/accountService?WSDL"/&gt;
    &lt;property name="namespaceUri" value="http://localhost:8080/account/services/accountService"/&gt;
    &lt;property name="serviceName" value="AccountService"/&gt;
    &lt;property name="portName" value="AccountPort"/&gt;
&lt;/bean&gt;</pre>
<p><code class="literal">serviceInterface</code>是我们客户端将使用的远程业务接口。
      <code class="literal">wsdlDocumentUrl</code>是WSDL文件的URL. Spring需要用它作为启动点来创建JAX-RPC服务。
      <code class="literal">namespaceUri</code>对应.wsdl文件中的targetNamespace。
      <code class="literal">serviceName</code> 对应.wsdl文件中的服务名。
      <code class="literal">portName</code> 对应.wsdl文件中的端口号。
      </p>
<p>现在我们可以很方便的访问web服务，因为我们有一个可以将它暴露为<code class="literal">RemoteAccountService</code>接口的bean工厂。我们可以在Spring中这样使用：</p>
<pre class="code">&lt;bean id="client" class="example.AccountClientImpl"&gt;
    ...
    &lt;property name="service" ref="accountWebService"/&gt;
&lt;/bean&gt;</pre>
<p>从客户端代码上看，除了它抛出<code class="exceptionname">RemoteException</code>，我们可以把这个web服务当成一个普通的类进行访，。</p>
<pre class="code">public class AccountClientImpl {

    private RemoteAccountService service;
    
    public void setService(RemoteAccountService service) {
        this.service = service;
    }
    
    public void foo() {
        try {
            service.insertAccount(...);
        }
        catch (RemoteException ex) {
            <em class="lineannotation"><span class="lineannotation">// ouch</span></em>
        }
    }
}
</pre>
<p>我们可以不检查受控异常<code class="exceptionname">RemoteException</code>，因为Spring将它自动转换成相应的非受控异常<code class="exceptionname">RemoteException</code>。这也需要我们提供一个非RMI的接口。现在配置文件如下：</p>
<pre class="code">&lt;bean id="accountWebService" class="org.springframework.remoting.jaxrpc.JaxRpcPortProxyFactoryBean"&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
    &lt;property name="portInterface" value="example.RemoteAccountService"/&gt;
&lt;/bean&gt;</pre>
<p>我们的<code class="literal">serviceInterface</code>变成了非RMI接口。我们的RMI接口现在使用<code class="literal">portInterface</code>属性来定义。我们的客户端代码可以避免处理异常<code class="exceptionname">java.rmi.RemoteException</code>:</p>
<pre class="code">public class AccountClientImpl {

    private AccountService service;
    
    public void setService(AccountService service) {
        this.service = service;
    }
    
    public void foo() {
        service.insertAccount(...);
    }
}</pre>
<p>请注意你也可以去掉"portInterface"部分并指定一个普通业务接口作为"serviceInterface"。这样<code class="classname">JaxRpcPortProxyFactoryBean</code>将自动切换到JAX-RPC "动态调用接口", 不使用固定端口存根来进行动态调用。这样做的好处是你甚至不需要使用一个RMI相关的Java接口（比如在非Java的目标web服务中）；你只需要一个匹配的业务接口。查看<code class="classname">JaxRpcPortProxyFactoryBean</code>的javadoc来了解运行时实行的细节。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="remoting-web-services-jaxrpc-mapping-registration"></a>17.5.3.&#160;注册JAX-RPC Bean映射</h3></div></div></div>
<p>T为了传递类似<code class="classname">Account</code>等复杂对象，我们必须在客户端注册bean映射。</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>在服务器端通常在<code class="filename">'server-config.wsdd'</code>中使用Axis进行bean映射注册。</p>
</div>
<p>我们将使用Axis在客户端注册bean映射。为此，我们需要通过程序注册这个bean映射:</p>
<pre class="code">public class AxisPortProxyFactoryBean extends JaxRpcPortProxyFactoryBean {

    protected void postProcessJaxRpcService(Service service) {
        TypeMappingRegistry registry = service.getTypeMappingRegistry();
        TypeMapping mapping = registry.createTypeMapping();
        registerBeanMapping(mapping, Account.class, "Account");
        registry.register("http://schemas.xmlsoap.org/soap/encoding/", mapping);
    }

    protected void registerBeanMapping(TypeMapping mapping, Class type, String name) {
        QName qName = new QName("http://localhost:8080/account/services/accountService", name);
        mapping.register(type, qName,
                new BeanSerializerFactory(type, qName),
                new BeanDeserializerFactory(type, qName));
    }
}</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="remoting-web-services-jaxrpc-handler-registration"></a>17.5.4.&#160;注册自己的JAX-RPC 处理器</h3></div></div></div>
<p>本节中，我们将注册自己的<code class="interfacename">javax.rpc.xml.handler.Handler</code> 到Web服务代理，这样我们可以在SOAP消息被发送前执行定制的代码。<code class="interfacename">Handler</code>是一个回调接口。<code class="filename">jaxrpc.jar</code>中有个方便的基类<code class="classname">javax.rpc.xml.handler.GenericHandler</code>供我们继承使用：</p>
<pre class="code">public class AccountHandler extends GenericHandler {

    public QName[] getHeaders() {
        return null;
    }

    public boolean handleRequest(MessageContext context) {
        SOAPMessageContext smc = (SOAPMessageContext) context;
        SOAPMessage msg = smc.getMessage();
        try {
            SOAPEnvelope envelope = msg.getSOAPPart().getEnvelope();
            SOAPHeader header = envelope.getHeader();
            ...
        }
        catch (SOAPException ex) {
            throw new JAXRPCException(ex);
        }
        return true;
    }
}</pre>
<p>我们现在要做的就是把AccountHandler注册到JAX-RPC服务，这样它可以在消息被发送前调用 <code class="methodname">handleRequest(..)</code>。Spring目前对注册处理方法还不提供声明式支持，所以我们必须使用编程方式。但是Spring中这很容易实现，我们只需覆写专门为此设计的 <code class="methodname">postProcessJaxRpcService(..)</code> 方法：</p>
<pre class="code">public class AccountHandlerJaxRpcPortProxyFactoryBean extends JaxRpcPortProxyFactoryBean {

    protected void postProcessJaxRpcService(Service service) {
        QName port = new QName(this.getNamespaceUri(), this.getPortName());
        List list = service.getHandlerRegistry().getHandlerChain(port);
        list.add(new HandlerInfo(AccountHandler.class, null, null));
        logger.info("Registered JAX-RPC AccountHandler on port " + port);
    }
}</pre>
<p>最后，我们要记得更改Spring配置文件来使用我们的工厂bean:</p>
<pre class="code">&lt;bean id="accountWebService" class="example.AccountHandlerJaxRpcPortProxyFactoryBean"&gt;
    ...
&lt;/bean&gt;</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="remoting-web-services-jaxws-export-servlet"></a>17.5.5.&#160;使用JAX-WS暴露基于servlet的web服务</h3></div></div></div>
<p>Spring为JAX-WS servlet端点实现提供了一个方便的基类 - <code class="classname">SpringBeanAutowiringSupport</code>。要暴露我们的<code class="interfacename">AccountService</code>接口，我们可以扩展Spring的<code class="classname">SpringBeanAutowiringSupport</code>类并实现我们的业务逻辑，通常把调用交给业务层。我们将简单的使用Spring 2.5的<code class="literal">@Autowired</code>注解来声明依赖于Spring管理的bean。</p>
<pre class="code"><em class="lineannotation"><span class="lineannotation">/**
 * JAX-WS compliant AccountService implementation that simply delegates
 * to the AccountService implementation in the root web application context.
 *
 * This wrapper class is necessary because JAX-WS requires working with dedicated
 * endpoint classes. If an existing service needs to be exported, a wrapper that
 * extends SpringBeanAutowiringSupport for simple Spring bean autowiring (through
 * the @Autowired annotation) is the simplest JAX-WS compliant way.
 *
 * This is the class registered with the server-side JAX-WS implementation.
 * In the case of a Java EE 5 server, this would simply be defined as a servlet
 * in web.xml, with the server detecting that this is a JAX-WS endpoint and reacting
 * accordingly. The servlet name usually needs to match the specified WS service name.
 *
 * The web service engine manages the lifecycle of instances of this class.
 * Spring bean references will just be wired in here.
 */</span></em>import org.springframework.web.context.support.SpringBeanAutowiringSupport;

@WebService(serviceName="AccountService")
public class AccountServiceEndpoint extends SpringBeanAutowiringSupport {

    @Autowired
    private AccountService biz;

    @WebMethod
    public void insertAccount(Account acc) {
       biz.insertAccount(acc);
    }

    @WebMethod
    public Account[] getAccounts(String name) {
       return biz.getAccounts(name);
    }
}</pre>
<p>为了能够让Spring上下文使用Spring设施，我们的<code class="classname">AccountServletEndpoint</code>类需要运行在同一个web应用中。在Java EE 5环境中这是默认的情况，它使用JAX-WS servlet端点安装标准契约。详情请参阅Java EE 5 web服务教程。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="remoting-web-services-jaxws-export-standalone"></a>17.5.6.&#160;使用JAX-WS暴露单独web服务</h3></div></div></div>
<p>Sun JDK 1.6提供的内置JAX-WS provider 使用内置的HTTP服务器来暴露web服务。Spring的<code class="classname">SimpleJaxWsServiceExporter</code>类检测所有在Spring应用上下文中配置的l<code class="literal">@WebService</code> 注解bean，然后通过默认的JAX-WS服务器（JDK 1.6 HTTP服务器）来暴露它们。</p>
<p>在这种场景下，端点实例将被作为Spring bean来定义和管理。它们将使用JAX-WS来注册，但其生命周期将一直跟随Spring应用上下文。这意味着Spring的显示依赖注入可用于端点实例。当然通过<code class="literal">@Autowired</code>来进行注解驱动的注入也可以正常工作。</p>
<pre class="code">&lt;bean class="org.springframework.remoting.jaxws.SimpleJaxWsServiceExporter"&gt;
    &lt;property name="baseAddress" value="http://localhost:9999/"/&gt;
&lt;/bean&gt;

&lt;bean id="accountServiceEndpoint" class="example.AccountServiceEndpoint"&gt;
    ...
&lt;/bean&gt;

...</pre>
<p><code class="classname">AccountServiceEndpoint</code>类可能源自Spring的 <code class="classname">SpringBeanAutowiringSupport</code>类，也可能不是。因为这里的端点是由Spring完全管理的bean。这意味着端点实现可能像下面这样没有任何父类定义 - 而且Spring的<code class="literal">@Autowired</code>配置注解仍然能够使用：</p>
<pre class="code">@WebService(serviceName="AccountService")
public class AccountServiceEndpoint {

    @Autowired
    private AccountService biz;

    @WebMethod
    public void insertAccount(Account acc) {
       biz.insertAccount(acc);
    }

    @WebMethod
    public Account[] getAccounts(String name) {
       return biz.getAccounts(name);
    }
}</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="remoting-web-services-jaxws-export-ri"></a>17.5.7.&#160;使用Spring支持的JAX-WS RI来暴露服务</h3></div></div></div>
<p>Sun的JAX-WS RI被作为GlassFish项目的一部分来开发,它使用了Spring支持来作为JAX-WS Commons项目的一部分。这允许把JAX-WS端点作为Spring管理的bean来定义。这与前面章节讨论的单独模式类似 - 但这次是在Servlet环境中。<span class="emphasis"><em>注意这在Java EE 5环境中是不可迁移的，建议在没有EE的web应用环境如Tomcat中嵌入JAX-WS RI。</em></span></p>
<p>与标准的暴露基于servlet的端点方式不同之处在于端点实例的生命周期将被Spring管理。这里在<code class="literal">web.xml</code>将只有一个JAX-WS servlet定义。在标准的Java EE 5风格中(如上所示)，你将对每个服务端点定义一个servlet，每个服务端点都代理到Spring bean (通过使用<code class="literal">@Autowired</code>，如上所示)。</p>
<p>关于安装和使用详情请查阅<a href="" target="_top">https://jax-ws-commons.dev.java.net/spring/</a>。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="remoting-web-services-jaxws-access"></a>17.5.8.&#160;使用JAX-WS访问web服务</h3></div></div></div>
<p>类似JAX-RPC支持，Spring提供了2个工厂bean来创建JAX-WS web服务代理，它们是<code class="classname">LocalJaxWsServiceFactoryBean</code>和<code class="classname">JaxWsPortProxyFactoryBean</code>。前一个只能返回一个JAX-WS服务对象来让我们使用。后面的是可以返回我们业务服务接口的代理实现的完整版本。这个例子中我们使用后者来为<code class="interfacename">AccountService</code>端点再创建一个代理：</p>
<pre class="code">&lt;bean id="accountWebService" class="org.springframework.remoting.jaxws.JaxWsPortProxyFactoryBean"&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
    &lt;property name="wsdlDocumentUrl" value="http://localhost:8080/account/services/accountService?WSDL"/&gt;
    &lt;property name="namespaceUri" value="http://localhost:8080/account/services/accountService"/&gt;
    &lt;property name="serviceName" value="AccountService"/&gt;
    &lt;property name="portName" value="AccountPort"/&gt;
&lt;/bean&gt;</pre>
<p><code class="literal">serviceInterface</code>是我们客户端将使用的远程业务接口。
      <code class="literal">wsdlDocumentUrl</code>是WSDL文件的URL. Spring需要用它作为启动点来创建JAX-RPC服务。
      <code class="literal">namespaceUri</code>对应.wsdl文件中的targetNamespace。
      <code class="literal">serviceName</code> 对应.wsdl文件中的服务名。
      <code class="literal">portName</code> 对应.wsdl文件中的端口号。
      </p>
<p>现在我们可以很方便的访问web服务，因为我们有一个可以将它暴露为<code class="literal">AccountService</code>接口的bean工厂。我们可以在Spring中这样使用：</p>
<pre class="code">&lt;bean id="client" class="example.AccountClientImpl"&gt;
    ...
    &lt;property name="service" ref="accountWebService"/&gt;
&lt;/bean&gt;</pre>
<p>从客户端代码上我们可以把这个web服务当成一个普通的类进行访问：</p>
<pre class="code">public class AccountClientImpl {

    private AccountService service;

    public void setService(AccountService service) {
        this.service = service;
    }

    public void foo() {
        service.insertAccount(...);
    }
}</pre>
<p><span class="emphasis"><em>注意:</em></span> 上面被稍微简化了，因为JAX-WS需要端点接口及实现类来使用<code class="literal">@WebService</code>, <code class="literal">@SOAPBinding</code>等注解。 这意味着你不能简单的使用普通的Java接口和实现来作为JAX-WS端点，你需要首先对它们进行相应的注解。这些需求详情请查阅JAX-WS文档。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="remoting-web-services-xfire"></a>17.5.9.&#160;使用XFire来暴露Web服务</h3></div></div></div>
<p>XFire是一个Codehaus提供的轻量级SOAP库。暴露XFire是通过XFire自带的context，这个context将和RemoteExporter风格的bean相结合，后者需要被加入到在你的<code class="interfacename">WebApplicationContext</code>中。对于所有让你来暴露服务的方法，你需要创建一个<code class="classname">DispatcherServlet</code>类并有相应的<code class="interfacename">WebApplicationContext</code>来封装你将要暴露的服务：</p>
<pre class="code">&lt;servlet&gt;
    &lt;servlet-name&gt;xfire&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;</pre>
<p>你还必须链接XFire配置。这是通过增加一个context文件到由<code class="classname">ContextLoaderListener</code>（或者<code class="classname">ContextLoaderServlet</code>）加载的 <code class="literal">contextConfigLocations</code> 参数中。</p>
<pre class="code">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:org/codehaus/xfire/spring/xfire.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</pre>
<p>在你加入一个Servlet映射后（映射<code class="literal">/*</code>到上面定义的XFire Servlet），你只需要增加一个额外的bean来使用XFire暴露服务。例如，在 <code class="filename">'xfire-servlet.xml'</code> 中增加如下配置：</p>
<pre class="code">&lt;beans&gt;

    &lt;bean name="/Echo" class="org.codehaus.xfire.spring.remoting.XFireExporter"&gt;
        &lt;property name="serviceInterface" value="org.codehaus.xfire.spring.Echo"/&gt;
        &lt;property name="serviceBean"&gt;
    	       &lt;bean class="org.codehaus.xfire.spring.EchoImpl"/&gt;
        &lt;/property&gt;
        <em class="lineannotation"><span class="lineannotation">&lt;!-- the XFire bean is defined in the <code class="filename">xfire.xml</code> file --&gt;</span></em>
        &lt;property name="xfire" ref="xfire"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre>
<p>XFire处理了其他的事情。它检查你的服务接口并产生一个WSDL文件。这里的部分文档来自XFire网站，要了解更多有关XFire Spring的集成请访问 <a href="" target="_top">docs.codehaus.org/display/XFIRE/Spring</a>。</p>
</div>
</div>

<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->