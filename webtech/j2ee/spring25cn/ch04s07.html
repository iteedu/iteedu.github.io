<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->


<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="resources-app-ctx"></a>4.7.&#160;Application context 和<code class="interfacename">Resource</code> 路径</h2></div></div></div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="resources-app-ctx-construction"></a>4.7.1.&#160;构造application context</h3></div></div></div>
<p>application context构造器通常使用字符串或字符串数组作为资源(比如组成context定义 的XML文件)的定位路径。</p>
<p>当这样的定位路径没有前缀时，指定的 <code class="interfacename">Resource</code> 类型会通过这个路径来被创建并被用来载入bean的定义，这都取决于你所指定的application context。例如，如果你使用下面的代码来创建<code class="classname">ClassPathXmlApplicationContext</code> ：</p>
<pre class="code">ApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");</pre>
<p>这些Bean的定义会通过classpath载入并使用<code class="classname">ClassPathResource</code>。而如果你象下面这么创建<code class="classname">FileSystemXmlApplicationContext</code>：</p>
<pre class="code">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/appContext.xml");</pre>
<p>这些Bean的定义会通过文件系统从相对于当前工作目录中被载入。</p>
<p>请注意如果定位路径使用classpath前缀或标准的URL前缀，那它就会覆盖默认的<code class="interfacename">Resource</code>
类型。因此下面的<code class="classname">FileSystemXmlApplicationContext</code>...
			</p>
<pre class="code">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");</pre>
<p>...实际上会通过classpath载入其bean定义。然而它仍是个<code class="classname">FileSystemXmlApplicationContext</code>。
如果后面它被当作<code class="interfacename">ResourceLoader</code> 来使用，那么任何没有使用前缀的路径依然会被当作一个文件系统路径。
			</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="resources-app-ctx-classpathxml"></a>4.7.1.1.&#160;创建 <code class="classname">ClassPathXmlApplicationContext</code> 实例 - 简介</h4></div></div></div>
<p>
					<code class="classname">ClassPathXmlApplicationContext</code> 提供了多种构造方法以便于初始化。但其核心是，如果我们仅仅提供由XML文件名组成的字符串数组(没有完整路径信息)，	而且<span class="emphasis"><em>还</em></span>提供了<code class="classname">Class</code>；那么该<code class="classname">ClassPathXmlApplicationContext</code>就
会从给定的类中抽取路径信息。
				</p>
<p>希望通过一个示例把这些阐述清楚。假设有这样的目录结构：
				</p>
<pre class="code">com/
  foo/
    services.xml
    daos.xml
    MessengerService.class</pre>
<p>由 <code class="literal">'services.xml'</code> 和 <code class="literal">'daos.xml'</code> 中定义的bean组成的
				<code class="classname">ClassPathXmlApplicationContext</code> 实例会象这样地来实例化...
				</p>
<pre class="code">ApplicationContext ctx = new ClassPathXmlApplicationContext(
    new String[] {"services.xml", "daos.xml"}, MessengerService.class);</pre>
<p>欲了解 <code class="classname">ClassPathXmlApplicationContext</code> 多种构造方法的细节，请参考它的Javadocs。</p>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="resources-app-ctx-wildcards-in-resource-paths"></a>4.7.2.&#160;Application context构造器中资源路径的通配符</h3></div></div></div>
<p>Application context构造器中资源路径的值可以是简单的路径(就像上面的那样)，即一对一映射到一个目标资源；
			或者可以包含特殊的"classpath*:"前缀和Ant风格的正则表达式(用Spring的 <code class="classname">PathMatcher</code> 工具来匹配)。
			后面的二者都可以使用通配符。</p>
<p>该机制的一个用处就是做组件类型的应用组装。所有的组件都可以用通用的定位路径“发布”context定义片断，
				这样当使用相同的 <code class="literal">classpath*:</code> 前缀创建最终的application context时，所有的组件片断都会被自动装入。
			</p>
<p>请注意，这个通配符只在application context构造器的资源路径中
			(或直接在类的层次中使用 <code class="classname">PathMatcher</code> 工具时)有效，
			它会在构造时进行解析。这与 <code class="interfacename">Resource</code>
			类型本身没有关联。因为同一时刻只能指向一个资源，所以不能使用
				<code class="literal">classpath*:</code> 前缀来构造实际的<code class="interfacename">Resource</code>。
			</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="resources-app-ctx-ant-patterns-in-paths"></a>4.7.2.1.&#160;Ant风格的pattern</h4></div></div></div>
<p>在包含Ant风格的pattern时，例如：</p>
<pre class="code">     /WEB-INF/*-context.xml
     com/mycompany/**/applicationContext.xml
     file:C:/some/path/*-context.xml
     classpath:com/mycompany/**/applicationContext.xml</pre>
<p>解析器会进行一个预先定义的复杂的过程去试图解析通配符。
        它根据路径中最后一个非通配符片断产生一个Resource并从中获得一个URL。
        如果这个URL不是一个"jar:" URL或特定容器的变量(例如WebLogic中的
        "<code class="literal">zip:</code>"，WebSphere中的"<code class="literal">wsjar</code>"等等)，
        那么可以从中获得一个<code class="methodname">java.io.File</code>，
        并用它从文件系统中解析通配符。如果是一个jar URL，解析器可以从中取得一个
        <code class="classname">java.net.JarURLConnection</code>，或者手工解析该jar URL，
        随后遍历jar文件以解析通配符。</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h5 class="title">
<a name="resources-app-ctx-portability"></a>4.7.2.1.1.&#160;潜在的可移植性</h5></div></div></div>
<p>如果给定的路径已经是一个文件URL(可以是显式的或者是隐式的)，
          由于基本的ResourceLoader是针对文件系统的，那么通配符一定能够移植。</p>
<p>如果给定的路径是一个classpath的位置，那么解析器必须通过一个
          <code class="methodname">Classloader.getResource()</code> 调用获得最后一个
          非通配符路径片断的URL。因为这仅仅是一个路径的节点(不是最终的文件)，
          所以它并未确切定义(在 <code class="classname">ClassLoader</code> Javadocs里)
          此处究竟会返回什么类型的URL。一般情况下，当classpath资源解析为一个文件系统位置时，
          返回一个代表目录的 <code class="classname">java.io.File</code>；当解析为jar位置时，
          返回某类jar URL。当然，这个操作涉及到可移植性。</p>
<p>如果从最后一个非通配符片断中获得一个jar URL，那么解析器一定能从中取得一个
          <code class="classname">java.net.JarURLConnection</code>，或者手动解析jar URL以遍历jar文件，
          从而解析通配符。这一操作在大多数环境中能正常工作，不过也有例外，
          因此我们强烈建议特定环境中的jar资源通配符解析应在正式使用前要经过彻底测试。</p>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="resources-classpath-wildcards"></a>4.7.2.2.&#160;<code class="literal">classpath*:</code> 前缀</h4></div></div></div>
<p>当构造基于XML的application context时，路径字符串可能使用特殊的 <code class="literal">classpath*:</code> 前缀：</p>
<pre class="code">ApplicationContext ctx =
    new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");</pre>
<p>此前缀表示所有与给定名称匹配的classpath资源都应该被获取(其中，这经常会在调用 <code class="methodname">ClassLoader.getResources(...)</code>) 时发生)，并接着将那些资源全并成最终的application context定义。</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Classpath*: 的可移植性</h3>
<p>带通配符的classpath依赖于底层classloader的 <code class="literal">getResources()</code> 方法。
          现在大多数的应用服务器提供自己的classloader实现，它们在处理jar文件时的行为也许会有所不同。
          要测试 <code class="literal">classpath*:</code> 是否有效，可以简单地用classloader从classpath中的jar文件里加载一个文件：
          <code class="literal">getClass().getClassLoader().getResources("&lt;someFileInsideTheJar&gt;")</code>。
          针对两个不同位置但有相同名字的文件来运行测试。如果结果不对，那么就查看一下应用服务器的文档，
          特别是那些可能影响classloader行为的设置。</p>
</div>
<p>"<code class="literal">classpath*:</code>"前缀也能在位置路径的其他部分结合<code class="literal">PathMatcher</code> 
        pattern一起使用，例如"<code class="literal">classpath*:META-INF/*-beans.xml</code>"。在这里，
        解析策略很简单：对最后一个非通配符路径片断使用一个ClassLoader.getResources()调用，
        从类加载层次中获得所有满足的资源，随后针对子路径的通配符，
        将同一个PathMatcher解析策略运用于每个资源之上。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="resources-wildcards-in-path-other-stuff"></a>4.7.2.3.&#160;其他关于通配符的说明</h4></div></div></div>
<p>请注意如果目标文件不是在文件系统中，那么"<code class="literal">classpath*:</code>"
        在结合Ant风格的pattern时必须在pattern开始前包含至少一个根路径才能保证其正确性。
        像"<code class="literal">classpath*:*.xml</code>"这样的pattern不能从jar文件的根目录取得文件，
        而只能从这个根目录的子目录中获得文件。这个问题源自JDK中 <code class="methodname">ClassLoader.getResources()</code>
        方法的一个局限性，即该方法在传入空String(指示要搜索的潜在根目录)时只返回文件系统位置。</p>
<p>如果搜索的根包在多个类路径位置上，带"<code class="literal">classpath:</code>"的Ant风格pattern
		资源不能保证一定可以找到匹配的资源。这是因为像</p>
<pre class="code">    com/mycompany/package1/service-context.xml</pre>
<p>这样的资源只可能在一个位置，但如果要解析的是如下路径</p>
<pre class="code">    classpath:com/mycompany/**/service-context.xml</pre>
<p>解析器会排除<code class="methodname">getResource("com/mycompany")</code>;返回的(第一个)URL。
        如果这个基础包节点存在于多个classloader位置，最终要找的资源未必会被发现。
        因此在这种情况中最好在这个Ant风格的pattern中使用"<code class="literal">classpath*:</code>"，
        这样就会搜索包含根包在内所有类路径。</p>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="resources-filesystemresource-caveats"></a>4.7.3.&#160;<code class="classname">FileSystemResource</code> 说明</h3></div></div></div>
<p>一个并没有与 <code class="classname">FileSystemApplicationContext</code> 绑定的
				<code class="classname">FileSystemResource</code>(也就是说<code class="classname">FileSystemApplicationContext</code> 并不是真正的<code class="interfacename">ResourceLoader</code>)，会象你期望的那样分辨绝对和相对路径。
				相对路径是相对于当前的工作目录，而绝对路径是相对与文件系统的根目录。
			</p>
<p>为了向前兼容的目的，当 <code class="classname">FileSystemApplicationContext</code> 是个
				<code class="literal">ResourceLoader</code> 时它会发生变化。<code class="classname">FileSystemApplicationContext</code>
				会简单地让所有绑定的 <code class="classname">FileSystemResource</code> 实例把绝对路径都当成相对路径，
				而不管它们是否以反斜杠开头。也就是说，下面的含义是相同的：
			</p>
<pre class="code">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/context.xml");</pre>
<pre class="code">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("/conf/context.xml");</pre>
<p>下面的也一样：(虽然把它们区分开来也很有意义，但其中的一个是相对路径而另一个则是绝对路径)。
			</p>
<pre class="code">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("some/resource/path/myTemplate.txt");</pre>
<pre class="code">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("/some/resource/path/myTemplate.txt");</pre>
<p>实际上如果的确需要使用绝对路径，那你最好就不要使用 <code class="classname">FileSystemResource</code> 或 <code class="classname">FileSystemXmlApplicationContext</code>来确定绝对路径。我们可以通过使用 <code class="literal">file:</code> URL前缀来强制使用<code class="classname">UrlResource</code>。
			</p>
<pre class="code"><em class="lineannotation"><span class="lineannotation">// actual context type doesn't matter, the <code class="interfacename">Resource</code> will always be <code class="classname">UrlResource</code></span></em>
ctx.getResource("file:/some/resource/path/myTemplate.txt");</pre>
<pre class="code"><em class="lineannotation"><span class="lineannotation">// force this FileSystemXmlApplicationContext to load it's definition via a <code class="classname">UrlResource</code></span></em>
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("file:/conf/context.xml");</pre>
</div>
</div>

<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->