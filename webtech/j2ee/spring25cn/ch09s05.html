<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->


<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="transaction-declarative"></a>9.5.&#160;声明式事务管理</h2></div></div></div>
<p class="remark"><i><span class="remark">大多数Spring用户选择声明式事务管理。这是对应用代码影响最小的选择，因此也最符合 <span class="emphasis"><em>非侵入式</em></span> 轻量级容器的理念。</span></i></p>
<p>Spring的声明式事务管理是通过Spring AOP实现的，因为事务方面的代码与Spring绑定并以一种样板式风格使用，
   不过尽管如此，你一般并不需要理解AOP概念就可以有效地使用Spirng的声明式事务管理。</p>
<p>从考虑EJB CMT和Spring声明式事务管理的相似以及不同之处出发是很有益的。它们的基本方法是相似的：
		都可以指定事务管理到单独的方法；如果需要可以在事务上下文调用 <code class="methodname">setRollbackOnly()</code> 方法。不同之处在于：</p>
<div class="itemizedlist"><ul type="disc">
<li><p>不像EJB CMT绑定在JTA上，Spring声明式事务管理可以在任何环境下使用。只需更改配置文件，
	它就可以和JDBC、JDO、Hibernate或其他的事务机制一起工作。</p></li>
<li><p>Spring的声明式事务管理可以被应用到任何类（以及那个类的实例）上，不仅仅是像EJB那样的特殊类。</p></li>
<li><p>Spring提供了声明式的	<a href="ch09s05.html#transaction-declarative-rolling-back" title="9.5.3.&#160;回滚"><span class="emphasis"><em>回滚规则</em></span></a>：EJB没有对应的特性，我们将在下面讨论。回滚可以声明式的控制，不仅仅是编程式的。</p></li>
<li><p>Spring允许你通过AOP定制事务行为。例如，如果需要，你可以在事务回滚中插入定制的行为。
				你也可以增加任意的通知，就象事务通知一样。使用EJB CMT，除了使用<code class="literal">setRollbackOnly()</code>，你没有办法能够影响容器的事务管理。</p></li>
<li><p>Spring不提供高端应用服务器提供的跨越远程调用的事务上下文传播。如果你需要这些特性，我们推荐你使用EJB。
				然而，不要轻易使用这些特性。因为通常我们并不希望事务跨越远程调用。</p></li>
</ul></div>
<div class="sidebar">
<p class="title"><b><code class="classname">TransactionProxyFactoryBean</code>在哪儿？</b></p>
<p>Spring2.0及以后的版本中声明式事务的配置与之前的版本有相当大的不同。主要差异在于不再需要配置<code class="classname">TransactionProxyFactoryBean</code>了。</p>
<p>Spring2.0之前的旧版本风格的配置仍然是有效的；你可以简单地认为新的<code class="literal">&lt;tx:tags/&gt;</code>替你定义了<code class="classname">TransactionProxyFactoryBean</code>。</p>
</div>
<p>回滚规则的概念比较重要：它使我们能够指定什么样的异常（和throwable）将导致自动回滚。
我们在配置文件中声明式地指定，无须在Java代码中。同时，我们仍旧可以通过调用 <code class="interfacename">TransactionStatus</code> 的
 <code class="methodname">setRollbackOnly()</code> 方法编程式地回滚当前事务。通常，我们定义一条规则，
 声明 <code class="exceptionname">MyApplicationException</code> 必须总是导致事务回滚。
 这种方式带来了显著的好处，它使你的业务对象不必依赖于事务设施。典型的例子是你不必在代码中导入Spring API，事务等。</p>
<p>对EJB来说，默认的行为是EJB容器在遇到 <span class="emphasis"><em>系统异常</em></span>（通常指运行时异常）时自动回滚当前事务。
	EJB CMT遇到 <span class="emphasis"><em>应用异常</em></span>（例如，除了 <code class="exceptionname">java.rmi.RemoteException</code> 外别的checked exception）时并不会自动回滚。
	默认式Spring处理声明式事务管理的规则遵守EJB习惯（只在遇到unchecked exceptions时自动回滚），但通常定制这条规则会更有用。</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="tx-decl-explained"></a>9.5.1.&#160;理解Spring的声明式事务管理实现</h3></div></div></div>
<p>本节的目的是消除与使用声明式事务管理有关的神秘性。简单点儿总是好的，这份参考文档只是告诉你给你的类加上<code class="interfacename">@Transactional</code>注解，在配置文件中添加（<code class="literal">'&lt;tx:annotation-driven/&gt;'</code>）行，然后期望你理解整个过程是怎么工作的。此节讲述Spring的声明式事务管理内部的工作机制，以帮助你在面对事务相关的问题时不至于误入迷途，回朔到上游平静的水域。</p>
<p>在理解Spring的声明式事务管理方面最重要的概念是：Spring的事务管理是通过AOP<span class="emphasis"><em>代理</em></span>实现的。
	 其中的事务通知由<span class="emphasis"><em>元数据</em></span>（目前基于XML或注解）驱动。
	 代理对象与事务元数据结合产生了一个AOP代理，它使用一个<code class="classname">PlatformTransactionManager</code>
	 实现品配合<code class="classname">TransactionInterceptor</code>，在<span class="emphasis"><em>方法调用</em></span>前后实施事务。</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>尽管使用Spring声明式事务管理不需要AOP（尤其是Spring AOP）的知识，但了解这些是很有帮助的。你可以在 <a href="ch06.html" title="第&#160;6&#160;章&#160;使用Spring进行面向切面编程（AOP）">第&#160;6&#160;章 <i>使用Spring进行面向切面编程（AOP）</i></a> 章找到关于Spring AOP的全部内容。</p>
</div>
<p>概念上来说，在事务代理上调用方法的工作过程看起来像这样：</p>
<p>
				</p>
<div class="mediaobject" align="center"><img src="images/tx.png" align="middle"></div>
<p>
			</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="transaction-declarative-first-example"></a>9.5.2.&#160;第一个例子</h3></div></div></div>
<p>请看下面的接口和它的实现。这个例子的意图是介绍概念，使用 <code class="classname">Foo</code> 和 <code class="classname">Bar</code> 
	 这样的名字只是为了让你关注于事务的用法，而不是领域模型。</p>
<pre class="code"><em class="lineannotation"><span class="lineannotation">// 我们想做成事务性的服务接口</span></em>

package x.y.service;

public interface FooService {

  Foo getFoo(String fooName);

  Foo getFoo(String fooName, String barName);

  void insertFoo(Foo foo);

  void updateFoo(Foo foo);

}</pre>
<pre class="code"><em class="lineannotation"><span class="lineannotation">// 上述接口的一个实现</span></em>

package x.y.service;

public class DefaultFooService implements FooService {

  public Foo getFoo(String fooName) {
    throw new UnsupportedOperationException();
  }

  public Foo getFoo(String fooName, String barName) {
    throw new UnsupportedOperationException();
  }

  public void insertFoo(Foo foo) {
    throw new UnsupportedOperationException();
  }

  public void updateFoo(Foo foo) {
    throw new UnsupportedOperationException();
  }

}</pre>
<p>
	 	<span class="emphasis"><em>（对该例的目的来说，上例中实现类（<code class="classname">DefaultFooService</code>）的每个方法在其方法体中抛出
		<code class="exceptionname">UnsupportedOperationException</code> 的做法是恰当的，我们可以看到，事务被创建出来，
		响应 <code class="exceptionname">UnsupportedOperationException</code> 的抛出，然后回滚。）</em></span>
	</p>
<p>我们假定，<code class="interfacename">FooService</code>的前两个方法（<code class="literal">getFoo(String)</code>
	和<code class="literal">getFoo(String, String)</code>）必须执行在只读事务上下文中，其他的方法（<code class="literal">insertFoo(Foo)</code>和
	<code class="literal">updateFoo(Foo)</code>）必须执行在可读写事务上下文中。不要想着一次理解下面的配置，所有内容都会在后面的章节详细讨论。</p>
<pre class="code"><em class="lineannotation"><span class="lineannotation">&lt;!-- from the file <code class="literal">'context.xml'</code> --&gt;</span></em>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:aop="http://www.springframework.org/schema/aop"
     <em class="lineannotation"><span class="lineannotation"><span class="bold"><strong>xmlns:tx="http://www.springframework.org/schema/tx"</strong></span></span></em>
     xsi:schemaLocation="
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
     <em class="lineannotation"><span class="lineannotation"><span class="bold"><strong>http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</strong></span></span></em>
     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;
  
  <em class="lineannotation"><span class="lineannotation">&lt;!-- this is the service object that we want to make transactional --&gt;</span></em>
  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- the transactional advice (what 'happens'; see the <code class="literal">&lt;aop:advisor/&gt;</code> bean below) --&gt;</span></em>
  &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
  <em class="lineannotation"><span class="lineannotation">&lt;!-- the transactional semantics... --&gt;</span></em>
  &lt;tx:attributes&gt;
    <em class="lineannotation"><span class="lineannotation">&lt;!-- all methods starting with <code class="literal">'get'</code> are read-only --&gt;</span></em>
    &lt;tx:method name="get*" read-only="true"/&gt;
    <em class="lineannotation"><span class="lineannotation">&lt;!-- other methods use the default transaction settings (see below) --&gt;</span></em>
    &lt;tx:method name="*"/&gt;
  &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;
  
  <em class="lineannotation"><span class="lineannotation">&lt;!-- ensure that the above transactional advice runs for any execution
    of an operation defined by the <code class="interfacename">FooService</code> interface --&gt;</span></em>
  &lt;aop:config&gt;
  &lt;aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/&gt;
  &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/&gt;
  &lt;/aop:config&gt;
  
  <em class="lineannotation"><span class="lineannotation">&lt;!-- don't forget the <code class="interfacename">DataSource</code> --&gt;</span></em>
  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
  &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
  &lt;property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/&gt;
  &lt;property name="username" value="scott"/&gt;
  &lt;property name="password" value="tiger"/&gt;
  &lt;/bean&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- similarly, don't forget the <code class="interfacename">PlatformTransactionManager</code> --&gt;</span></em>
  &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
  &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
  
  <em class="lineannotation"><span class="lineannotation">&lt;!-- other <code class="literal">&lt;bean/&gt;</code> definitions here --&gt;</span></em>

&lt;/beans&gt;</pre>
<p>
				我们来分析一下上面的配置。我们要把一个服务对象（<code class="literal">'fooService'</code> bean）做成事务性的。
				我们想施加的事务语义封装在<code class="literal">&lt;tx:advice/&gt;</code>定义中。<code class="literal">&lt;tx:advice/&gt;</code>
				“<span class="quote"><span class="emphasis"><em>把所有以 <code class="literal">'get'</code> 开头的方法看做执行在只读事务上下文中，
				其余的方法执行在默认语义的事务上下文中</em></span></span>”。
				其中的 <code class="literal">'transaction-manager'</code> 属性被设置为一个指向
				<code class="interfacename">PlatformTransactionManager</code> bean的名字（这里指 <code class="literal">'txManager'</code>），
				该bean将会真正管理事务。</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">提示</h3>
<p>事实上，如果 <code class="interfacename">PlatformTransactionManager</code> bean的名字是 
				<code class="literal">'transactionManager'</code> 的话，你的事务通知（<code class="literal">&lt;tx:advice/&gt;</code>）中的 
				<code class="literal">'transaction-manager'</code> 属性可以忽略。否则你则需要像上例那样明确指定。</p>
</div>
<p>配置中最后一段是 <code class="literal">&lt;aop:config/&gt;</code> 的定义，
	  它确保由 <code class="literal">'txAdvice'</code> bean定义的事务通知在应用中合适的点被执行。
	  首先我们定义了 一个切面，它匹配 <code class="interfacename">FooService</code> 接口定义的所有操作，
	  我们把该切面叫做 <code class="literal">'fooServiceOperation'</code>。然后我们用一个通知器（advisor）把这个切面与 <code class="literal">'txAdvice'</code> 绑定在一起，
	  表示当 <code class="literal">'fooServiceOperation'</code> 执行时，<code class="literal">'txAdvice'</code> 定义的通知逻辑将被执行。</p>
<p><code class="literal">&lt;aop:pointcut/&gt;</code> 元素定义是AspectJ的切面表示法，可参考Spring 2.0 <a href="ch06.html" title="第&#160;6&#160;章&#160;使用Spring进行面向切面编程（AOP）">第&#160;6&#160;章 <i>使用Spring进行面向切面编程（AOP）</i></a>章获得更详细的内容。</p>
<p>一个普遍性的需求是让整个服务层成为事务性的。满足该需求的最好方式是让切面表达式匹配服务层的所有操作方法。例如：</p>
<pre class="code">&lt;aop:config&gt;
  &lt;aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/&gt;
  &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/&gt;
  &lt;/aop:config&gt;</pre>
<p>
			<span class="emphasis"><em>（这个例子中假定你所有的服务接口定义在 <code class="literal">'x.y.service'</code> 包中。你同样可以参考 <a href="ch06.html" title="第&#160;6&#160;章&#160;使用Spring进行面向切面编程（AOP）">第&#160;6&#160;章 <i>使用Spring进行面向切面编程（AOP）</i></a> 章获得更详细内容。）</em></span>
			</p>
<p>现在，既然我们已经分析了整个配置，你可能会问了，“<span class="quote"><span class="emphasis"><em>好吧，但是所有这些配置做了什么？</em></span></span>”。</p>
<p>上面的配置将为<code class="literal">'fooService'</code> bean创建一个代理对象，这个代理对象被装配了事务通知，所以当它的相应方法被调用时，一个事务将被启动、挂起、被标记为只读，或者其它（根据该方法所配置的事务语义）。我们来看看下面的例子，测试一下上面的配置。</p>
<pre class="code">public final class Boot {

  public static void main(final String[] args) throws Exception {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml", Boot.class);
    FooService fooService = (FooService) ctx.getBean("fooService");
    fooService.insertFoo (new Foo());
  }
}</pre>
<p>运行上面程序的输出结果看起来像这样（注意为了清楚起见，Log4J的消息和从 <code class="classname">DefaultFooService</code> 的 <code class="methodname">insertFoo(..)</code> 方法抛出的 <code class="exceptionname">UnsupportedOperationException</code> 异常堆栈信息被省略了）。</p>
<pre class="code">
				<em class="lineannotation"><span class="lineannotation">&lt;!-- Spring容器开始启动... --&gt;
				</span></em>
[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy
        for bean 'fooService' with 0 common interceptors and 1 specific interceptors
    <em class="lineannotation"><span class="lineannotation">&lt;!-- the <code class="classname">DefaultFooService</code> is actually proxied --&gt;
    </span></em>
[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]

    <em class="lineannotation"><span class="lineannotation">&lt;!-- ... the <code class="literal">insertFoo(..)</code> method is now being invoked on the proxy --&gt;
    </span></em>

[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo
    <em class="lineannotation"><span class="lineannotation">&lt;!-- the transactional advice kicks in here... --&gt;
    </span></em>
[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]
[DataSourceTransactionManager] - Acquired Connection
        [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction

    <em class="lineannotation"><span class="lineannotation">&lt;!-- the <code class="literal">insertFoo(..)</code> method from <code class="classname">DefaultFooService</code> throws an exception... --&gt;
    </span></em>
[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should
        rollback on java.lang.UnsupportedOperationException
[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo
        due to throwable [java.lang.UnsupportedOperationException]

   <em class="lineannotation"><span class="lineannotation">&lt;!-- and the transaction is rolled back (by default, <code class="exceptionname">RuntimeException</code> instances cause rollback) --&gt;
   </span></em>
[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection
        [org.apache.commons.dbcp.PoolableConnection@a53de4]
[DataSourceTransactionManager] - Releasing JDBC Connection after transaction
[DataSourceUtils] - Returning JDBC Connection to DataSource

Exception in thread "main" java.lang.UnsupportedOperationException
	at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)
   <em class="lineannotation"><span class="lineannotation">&lt;!-- AOP infrastructure stack trace elements removed for clarity --&gt;
   </span></em>
	at $Proxy0.insertFoo(Unknown Source)
	at Boot.main(Boot.java:11)</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="transaction-declarative-rolling-back"></a>9.5.3.&#160;回滚</h3></div></div></div>
<p>
            在前面的章节里，概述了如何在你的应用中用声明的风格为类（特别是服务层的类）指定事务配置。
			这一章将描述如何使用一个简单的声明式配置来控制事务的回滚。</p>
<p>
             我们推荐做法是在Spring框架的事务架构里指出当context的事务里的代码抛出 
			<code class="exceptionname">Exception</code> 时事务进行回滚。Spring框架的事务基础架构代码将从调用的堆栈里捕获到任何未处理的 
			<code class="exceptionname">Exception</code>，并将标识事务将回滚。
            </p>
<p>
            然而，请注意Spring框架的事务基础架构代码将默认地 <span class="emphasis"><em>只</em></span> 在抛出运行时和unchecked exceptions时才标识事务回滚。
            也就是说，当抛出一个 <code class="exceptionname">RuntimeException</code> 或其子类例的实例时。（<code class="literal">Errors</code> 也一样 - 默认地 - 标识事务回滚。）从事务方法中抛出的Checked exceptions将 <span class="emphasis"><em>不</em></span> 被标识进行事务回滚。
            </p>
<p>可以配置哪些 <code class="exceptionname">Exception</code>类型将被标识进行事务回滚。
	      下面的XML配置片断里示范了如何配置一个用于回滚的checked、应用程序特定的 <code class="exceptionname">Exception</code> 类型。 </p>
<pre class="code">&lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
  &lt;tx:attributes&gt;
  &lt;tx:method name="get*" read-only="true" <em class="lineannotation"><span class="lineannotation"><span class="bold"><strong>rollback-for="NoProductInStockException"</strong></span></span></em>/&gt;
  &lt;tx:method name="*"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</pre>
<p>有时候你<span class="emphasis"><em>不</em></span>想在异常抛出的时候回滚事务，就可以使用“不回滚规则”。
				在下面的例子中，我们告诉Spring 框架即使遇到没有经过处理的<code class="exceptionname">InstrumentNotFoundException</code>异常，也不要回滚事务。</p>
<pre class="code">&lt;tx:advice id="txAdvice"&gt;
  &lt;tx:attributes&gt;
  &lt;tx:method name="updateStock" <em class="lineannotation"><span class="lineannotation"><span class="bold"><strong>no-rollback-for="InstrumentNotFoundException"</strong></span></span></em>/&gt;
  &lt;tx:method name="*"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</pre>
<p>当Spring框架捕获到一个异常后会检查配置回滚规则来决定是不是要回滚事务，这时候会遵循<span class="emphasis"><em>最匹配</em></span>的规则。
			所以在下面这种配置中，除了<code class="exceptionname">InstrumentNotFoundException</code>这种类型的异常不会导致事务回滚以外，其他任何类型的异常都会。</p>
<pre class="code">&lt;tx:advice id="txAdvice"&gt;
  &lt;tx:attributes&gt;
  &lt;tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</pre>
<p>
            第二种方法是通过 <span class="emphasis"><em>编程式</em></span> 方式来指定回滚事务。
            虽然写法非常的简单，但是这个方法是高侵入性的，并且使你的代码与Spring框架的事务架构高度耦合。
            下面的代码片断里示范了Spring框架管理事务的编程式回滚：
            </p>
<pre class="code">public void resolvePosition() {
  try {
    <em class="lineannotation"><span class="lineannotation">// some business logic...</span></em>
  } catch (NoProductInStockException ex) {
    <em class="lineannotation"><span class="lineannotation">// trigger rollback programmatically</span></em>
    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
  }
}</pre>
<p>
            强烈推荐你尽可能地使用声明式事务回滚方法。
            编程式方法的回滚对你来说是可见，如果你需要它你就可以使用，但是使用它就直接违反了在你的应用中使用一个纯基于POJO的模型。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="transaction-declarative-diff-tx"></a>9.5.4.&#160;为不同的bean配置不同的事务语义</h3></div></div></div>
<p>现在让我们考虑一下这样的场景，假设你有许多服务对象，你想为他们分别设置 <span class="emphasis"><em>完全不同</em></span> 的事务语义。
			在Spring中，你可以通过分别定义特定的 <code class="literal">&lt;aop:advisor/&gt;</code> 元素，
			让每个advisor采用不同的 <code class="literal">'pointcut'</code> 和 <code class="literal">'advice-ref'</code> 属性，来达到目的。</p>
<p>让我们假定你所有的服务层类定义在以 <code class="literal">'x.y.service'</code> 为根的包内。
			为了让service包（或子包）下所有名字以 <code class="literal">'Service'</code> 结尾的类的对象拥有默认的事务语义，你可以做如下的配置：</p>
<pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xsi:schemaLocation="
  http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
  http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
  http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;aop:config&gt;

    &lt;aop:pointcut id="serviceOperation"
          expression="<em class="lineannotation"><span class="lineannotation">execution(* x.y.service..*Service.*(..))</span></em>"/&gt;

    &lt;aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/&gt;

  &lt;/aop:config&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- these two beans will be transactional... --&gt;</span></em>
  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;
  &lt;bean id="barService" class="x.y.service.extras.SimpleBarService"/&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- ... and these two beans won't --&gt;</span></em>
  &lt;bean id="anotherService" class="org.xyz.SomeService"/&gt; <em class="lineannotation"><span class="lineannotation">&lt;!-- (not in the right package) --&gt;</span></em>
  &lt;bean id="barManager" class="x.y.service.SimpleBarManager"/&gt; <em class="lineannotation"><span class="lineannotation">&lt;!-- (doesn't end in 'Service') --&gt;</span></em>

  &lt;tx:advice id="txAdvice"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="get*" read-only="true"/&gt;
      &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- other transaction infrastructure beans such as a <code class="interfacename">PlatformTransactionManager</code> omitted... --&gt;</span></em>

&lt;/beans&gt;</pre>
<p>
        下面的配置示例演示了两个拥有完全不同的事务配置的bean。
        </p>
<pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xsi:schemaLocation="
  http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
  http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
  http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;aop:config&gt;

    &lt;aop:pointcut id="defaultServiceOperation"
          expression="<em class="lineannotation"><span class="lineannotation">execution(* x.y.service.*Service.*(..))</span></em>"/&gt;

    &lt;aop:pointcut id="noTxServiceOperation"
          expression="<em class="lineannotation"><span class="lineannotation">execution(* x.y.service.ddl.DefaultDdlManager.*(..))</span></em>"/&gt;

    &lt;aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/&gt;

    &lt;aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/&gt;

  &lt;/aop:config&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- this bean will be transactional (see the <code class="literal">'defaultServiceOperation'</code> pointcut) --&gt;</span></em>
  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt;</span></em>
  &lt;bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/&gt;

  &lt;tx:advice id="defaultTxAdvice"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="get*" read-only="true"/&gt;
      &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  &lt;tx:advice id="noTxAdvice"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="*" propagation="NEVER"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- other transaction infrastructure beans such as a <code class="interfacename">PlatformTransactionManager</code> omitted... --&gt;</span></em>

&lt;/beans&gt;</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="transaction-declarative-txadvice-settings"></a>9.5.5.&#160;<code class="literal">&lt;tx:advice/&gt;</code> 有关的设置</h3></div></div></div>
<p>
			这一节里将描述通过 <code class="literal">&lt;tx:advice/&gt;</code> 标签来指定不同的事务性设置。默认的 <code class="literal">&lt;tx:advice/&gt;</code> 设置如下：
            </p>
<p>
        </p>
<div class="itemizedlist"><ul type="disc">
<li><p> <a href="ch09s05.html#tx-propagation" title="9.5.7.&#160;事务传播">事务传播设置</a> 是 <code class="literal">REQUIRED</code></p></li>
<li><p>隔离级别是<code class="literal">DEFAULT</code></p></li>
<li><p>事务是 读/写</p></li>
<li><p>事务超时默认是依赖于事务系统的，或者事务超时没有被支持。</p></li>
<li><p>任何 <code class="exceptionname">RuntimeException</code> 将触发事务回滚，但是任何 checked <code class="exceptionname">Exception</code> 将不触发事务回滚</p></li>
</ul></div>
<p>
      </p>
<p>
            这些默认的设置当然也是可以被改变的。 
            <code class="literal">&lt;tx:advice/&gt;</code> 和 <code class="literal">&lt;tx:attributes/&gt;</code> 标签里的 <code class="literal">&lt;tx:method/&gt;</code> 各种属性设置总结如下：
            </p>
<p>
                </p>
<div class="table">
<a name="id521560"></a><p class="title"><b>表&#160;9.1.&#160;<code class="literal">&lt;tx:method/&gt;</code> 有关的设置</b></p>
<div class="table-contents"><table summary="&lt;tx:method/&gt; 有关的设置" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>属性</th>
<th>是否需要？</th>
<th>默认值</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<td><code class="literal">name</code></td>
<td>是</td>
<td>&#160;</td>
<td>
                                    <p>
                                    与事务属性关联的方法名。通配符（*）可以用来指定一批关联到相同的事务属性的方法。
                                    如：<code class="literal">'get*'</code>、<code class="literal">'handle*'</code>、<code class="literal">'on*Event'</code>等等。
                                    </p>
                </td>
</tr>
<tr>
<td><code class="literal">propagation</code></td>
<td>不</td>
<td>REQUIRED</td>
<td>事务传播行为</td>
</tr>
<tr>
<td><code class="literal">isolation</code></td>
<td>不</td>
<td>DEFAULT</td>
<td>事务隔离级别</td>
</tr>
<tr>
<td><code class="literal">timeout</code></td>
<td>不</td>
<td>-1</td>
<td>事务超时的时间（以秒为单位）</td>
</tr>
<tr>
<td><code class="literal">read-only</code></td>
<td>不</td>
<td>false</td>
<td>事务是否只读？</td>
</tr>
<tr>
<td><code class="literal">rollback-for</code></td>
<td>不</td>
<td>&#160;</td>
<td>
                                    <p>
                                    将被触发进行回滚的 <code class="literal">Exception(s)</code>；以逗号分开。
	                                如：<code class="literal">'com.foo.MyBusinessException,ServletException'</code>
	                                </p>
                                </td>
</tr>
<tr>
<td><code class="literal">no-rollback-for</code></td>
<td>不</td>
<td>&#160;</td>
<td>
                                    <p>
                                    <span class="emphasis"><em>不</em></span> 被触发进行回滚的 <code class="literal">Exception(s)</code>；以逗号分开。
	                                如：<code class="literal">'com.foo.MyBusinessException,ServletException'</code>
	                                </p>
                                </td>
</tr>
</tbody>
</table></div>
</div>
<p><br class="table-break">
            </p>
<p>在写代码的时候，不可能对事务的名字有个很清晰的认识，这里的名字是指会在事务监视器（比如WebLogic的事务管理器）或者日志输出中显示的名字，
			对于声明式的事务设置，事务名字总是包含完整包名的类名加上"."和方法名，比如 <code class="literal">'com.foo.BusinessService.handlePayment'</code>.</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="transaction-declarative-annotations"></a>9.5.6.&#160;使用 <code class="interfacename">@Transactional</code></h3></div></div></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>
					<code class="interfacename">@Transactional</code> 注解及其支持类所提供的功能最低要求使用Java 5（Tiger）。
				</p>
</div>
<p>
			除了基于XML文件的声明式事务配置外，你也可以采用基于注解式的事务配置方法。直接在Java源代码中声明事务语义的做法让事务声明和将受其影响的代码距离更近了，而且一般来说不会有不恰当的耦合的风险，因为，使用事务性的代码几乎总是被部署在事务环境中。
			</p>
<p>下面的例子很好地演示了 <code class="interfacename">@Transactional</code> 注解的易用性，随后解释其中的细节。先看看其中的类定义：</p>
<pre class="code"><em class="lineannotation"><span class="lineannotation">// the service class that we want to make transactional</span></em>
<span class="bold"><strong>@Transactional</strong></span>
public class DefaultFooService implements FooService {

  Foo getFoo(String fooName);

  Foo getFoo(String fooName, String barName);

  void insertFoo(Foo foo);

  void updateFoo(Foo foo);
}</pre>
<p>当上述的POJO定义在Spring IoC容器里时，上述bean实例仅仅通过<span class="emphasis"><em>一</em></span> 行xml配置就可以使它具有事务性的。如下：</p>
<pre class="code"><em class="lineannotation"><span class="lineannotation">&lt;!-- from the file <code class="literal">'context.xml'</code> --&gt;</span></em>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:aop="http://www.springframework.org/schema/aop"
     xmlns:tx="http://www.springframework.org/schema/tx"
     xsi:schemaLocation="
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
     http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;
  
  <em class="lineannotation"><span class="lineannotation">&lt;!-- this is the service object that we want to make transactional --&gt;</span></em>
  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- enable the configuration of transactional behavior based on annotations --&gt;</span></em>
  <span class="bold"><strong>&lt;tx:annotation-driven transaction-manager="txManager"/&gt;</strong></span>

  <em class="lineannotation"><span class="lineannotation">&lt;!-- a <code class="interfacename">PlatformTransactionManager</code> is still required --&gt;</span></em>
  &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
  <em class="lineannotation"><span class="lineannotation">&lt;!-- (this dependency is defined somewhere else) --&gt;</span></em>
  &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
  
  <em class="lineannotation"><span class="lineannotation">&lt;!-- other <code class="literal">&lt;bean/&gt;</code> definitions here --&gt;</span></em>

&lt;/beans&gt;</pre>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">提示</h3>
<p>
                实际上，如果你用  <code class="literal">'transactionManager'</code> 来定义 <code class="interfacename">PlatformTransactionManager</code> bean的名字的话，你就可以忽略 <code class="literal">&lt;tx:annotation-driven/&gt;</code> 标签里的 <code class="literal">'transaction-manager'</code> 属性。
                如果 <code class="interfacename">PlatformTransactionManager</code> bean你要通过其它名称来注入的话，你必须用 <code class="literal">'transaction-manager'</code> 属性来指定它，如上所示。
                </p>
</div>
<div class="sidebar">
<p class="title"><b>方法的可见度和 <code class="interfacename">@Transactional</code></b></p>
<p>
                在使用代理的时候，<code class="interfacename">@Transactional</code> 注解应该只被应用到 <span class="emphasis"><em>public</em></span> 可见度的方法上。
                如果你在 protected、private 或者 package-visible 的方法上使用 <code class="interfacename">@Transactional</code> 注解，系统也不会报错，
                但是这个被注解的方法将不会执行已配置的事务设置。如果你非要注解非公共方法的话，请参考使用AspectJ (参见下面)。
                </p>
</div>
<p>
				<code class="interfacename">@Transactional</code> 注解可以被应用于接口定义和接口方法、类定义和类的 <span class="emphasis"><em>public</em></span> 方法上。
				然而，请注意只是使用 <code class="interfacename">@Transactional</code> 注解并不会启用事务行为，
				它仅仅 <span class="emphasis"><em>是一种元数据</em></span>，能够被可以识别 <code class="interfacename">@Transactional</code> 
				注解和上述的配置适当的具有事务行为的beans所使用。上面的例子中，其实正是 <code class="literal">&lt;tx:annotation-driven/&gt;</code>元素的出现 
				<span class="emphasis"><em>开启</em></span> 了事务行为。</p>
<p>
            Spring团队的建议是你只在具体的类上使用 <code class="interfacename">@Transactional</code> 注解，
            而不要注解在接口上。你当然可以在接口（或接口方法）上使用 <code class="interfacename">@Transactional</code> 注解，
            但是这只有在你使用基于接口的代理时它才会生效。因为注解是 <span class="emphasis"><em>不能继承</em></span> 的，
            这就意味着如果你正在使用基于类的代理时，事务的设置将不能被基于类的代理所识别，而且对象也不会被事务代理所包装
            （这是很<span class="emphasis"><em>糟糕的</em></span>）。
			因此，请接受Spring团队的建议，在具体的类（包括该类的方法）上使用 <code class="interfacename">@Transactional</code> 注解。
            </p>
<p><span class="emphasis"><em>注意：在代理模式下（默认的情况），只有从代理传过来的‘外部’方法调用才会被拦截。</em></span>
	  这就意味着‘自我调用’是不会触发事务的，比如说，一个在目标对象中调用目标对象其他方法的方法是不会触发一个事务的，即使这个方法被标记为 
      <code class="interfacename">@Transactional</code>!</p>
<p>如果你期望‘自我调用’被事务覆盖到，可以考虑使用AspectJ 模式（如下所示）。在这种情况下，一开始就没有任何代理的存在；
      为了把<code class="interfacename">@Transactional</code>的方法变成运行时的行为，目标类会被‘编织’起来（比如修改它的字节码）。
   </p>
<p>
        </p>
<div class="table">
<a name="tx-annotation-driven-settings"></a><p class="title"><b>表&#160;9.2.&#160;<code class="literal">&lt;tx:annotation-driven/&gt;</code> 设置</b></p>
<div class="table-contents"><table summary="&lt;tx:annotation-driven/&gt; 设置" border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>属性</th>
<th>默认值</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<td><code class="literal">transaction-manager</code></td>
<td>transactionManager</td>
<td><p>使用的事务管理器的名字。只有像在上面的例子那样，事务管理器不是 <code class="literal">transactionManager</code>的情况下才需要。</p></td>
</tr>
<tr>
<td><code class="literal">mode</code></td>
<td>proxy</td>
<td><p>默认的模式“proxy”会用Spring的AOP框架来代理注解过的bean（就像在前面讨论过的那样，
				下面代理的语义只对通过代理传递过来的方法调用起效）。
				另一种可行的模式"aspectj"会使用Spring的AspectJ事务切面来编织类（通过修改目标对象的字节码应用到任何方法调用上）。
                AspectJ织入需要在classpath中有spring-aspects.jar这个文件，并且启用装载时织入 (或者编译时织入).
                (关于如何设置装载时编织的详情请参见 <a href="ch06s08.html#aop-aj-ltw-spring" title="6.8.4.5.&#160;Spring配置">第&#160;6.8.4.5&#160;节 “Spring配置”</a> )</p></td>
</tr>
<tr></tr>
<tr><!-- This row intentionally left blank --></tr>
<tr><!-- This row intentionally left blank --></tr>
</tbody>
</table></div>
</div>
<p><br class="table-break">
      </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>在<code class="literal">&lt;tx:annotation-driven/&gt;</code>元素上的"<code class="literal">proxy-target-class</code>" 属性 
       控制了有什么类型的事务性代理会为使用<code class="interfacename">@Transactional</code> 来注解的类创建代理。
	   如果"<code class="literal">proxy-target-class</code>" 属性被设为"<code class="literal">true</code>"，那么基于类的代理就会被创建。
	   如果"<code class="literal">proxy-target-class</code>" 属性被设为"<code class="literal">false</code>"
    或者没设，那么会创建基于接口的标准JDK代理。（关于不同代理类型的解释请参见 <a href="ch06s06.html" title="6.6.&#160;代理机制">第&#160;6.6&#160;节 “代理机制”</a>)</p>
</div>
<p>
            在多数情形下，方法的事务设置将被优先执行。在下列情况下，例如：
            <code class="classname">DefaultFooService</code> 类在类的级别上被注解为只读事务，但是，这个类中的 <code class="methodname">updateFoo(Foo)</code> 方法的 <code class="interfacename">@Transactional</code> 注解的事务设置将优先于类级别注解的事务设置。
      </p>
<pre class="code">@Transactional(readOnly = true)
public class DefaultFooService implements FooService {

  public Foo getFoo(String fooName) {
    <em class="lineannotation"><span class="lineannotation">// do something</span></em>
  }

    <em class="lineannotation"><span class="lineannotation">// <span class="bold"><strong>these</strong></span> settings have precedence for this method</span></em>
    @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
    public void updateFoo(Foo foo) {
        <em class="lineannotation"><span class="lineannotation">// do something
        </span></em>
    }
}</pre>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="transaction-declarative-attransactional-settings"></a>9.5.6.1.&#160;<code class="interfacename">@Transactional</code> 有关的设置</h4></div></div></div>
<p>
                <code class="interfacename">@Transactional</code> 注解是用来指定接口、类或方法必须拥有事务语义的元数据。
                如：“<span class="quote"><span class="emphasis"><em>当一个方法开始调用时就开启一个新的只读事务，并停止掉任何现存的事务</em></span></span>”。
                默认的 <code class="interfacename">@Transactional</code> 设置如下：
                </p>
<div class="itemizedlist"><ul type="disc">
<li><p>事务传播设置是 <code class="literal">PROPAGATION_REQUIRED</code></p></li>
<li><p>事务隔离级别是 <code class="literal">ISOLATION_DEFAULT</code></p></li>
<li><p>事务是 读/写</p></li>
<li><p>事务超时默认是依赖于事务系统的，或者事务超时没有被支持。</p></li>
<li><p>任何 <code class="exceptionname">RuntimeException</code> 将触发事务回滚，但是任何 checked <code class="exceptionname">Exception</code> 将不触发事务回滚</p></li>
</ul></div>
<p>
	            这些默认的设置当然也是可以被改变的。 
	            <code class="interfacename">@Transactional</code> 注解的各种属性设置总结如下：
				</p>
<p>
          </p>
<div class="table">
<a name="tx-attransactional-properties"></a><p class="title"><b>表&#160;9.3.&#160;<code class="interfacename">@Transactional</code> 注解的属性</b></p>
<div class="table-contents"><table summary="@Transactional 注解的属性" border="1">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr></thead>
<tbody>
<tr>
<td>
                    <code class="literal"><a href="ch09s05.html#tx-propagation" title="9.5.7.&#160;事务传播">propagation</a></code>
                  </td>
<td>枚举型：<code class="classname">Propagation</code>
</td>
<td>可选的传播性设置</td>
</tr>
<tr>
<td><code class="literal">isolation</code></td>
<td>枚举型：<code class="classname">Isolation</code>
</td>
<td>可选的隔离性级别（默认值：<code class="literal">ISOLATION_DEFAULT</code>）</td>
</tr>
<tr>
<td><code class="literal">readOnly</code></td>
<td>布尔型</td>
<td>读写型事务 vs. 只读型事务</td>
</tr>
<tr>
<td><code class="literal">timeout</code></td>
<td>int型（以秒为单位）</td>
<td>事务超时</td>
</tr>
<tr>
<td><code class="literal">rollbackFor</code></td>
<td>一组 <code class="classname">Class</code> 类的实例，必须是<code class="classname">Throwable</code> 的子类</td>
<td>一组异常类，遇到时 <span class="bold"><strong>必须</strong></span> 进行回滚。默认情况下checked exceptions不进行回滚，仅unchecked  exceptions（即<code class="classname">RuntimeException</code>的子类）才进行事务回滚。</td>
</tr>
<tr>
<td><code class="literal">rollbackForClassname</code></td>
<td>一组 <code class="classname">Class</code> 类的名字，必须是<code class="classname">Throwable</code>的子类</td>
<td>一组异常类名，遇到时 <span class="bold"><strong>必须</strong></span> 进行回滚</td>
</tr>
<tr>
<td><code class="literal">noRollbackFor</code></td>
<td>一组 <code class="classname">Class</code> 类的实例，必须是<code class="classname">Throwable</code> 的子类</td>
<td>一组异常类，遇到时 <span class="bold"><strong>必须不</strong></span> 回滚。</td>
</tr>
<tr>
<td><code class="literal">noRollbackForClassname</code></td>
<td>一组 <code class="classname">Class</code> 类的名字，必须是<code class="classname">Throwable</code> 的子类</td>
<td>一组异常类，遇到时 <span class="bold"><strong>必须不</strong></span> 回滚</td>
</tr>
</tbody>
</table></div>
</div>
<p><br class="table-break">
        </p>
<p>在写代码的时候，不可能对事务的名字有个很清晰的认识，这里的名字是指会在事务监视器（比如WebLogic的事务管理器）或者日志输出中显示的名字，
			对于声明式的事务设置，事务名字总是全限定名+"."+事务通知的类的方法名。比如<code class="classname">BusinessService</code>类的<code class="methodname">handlePayment(..)</code>方法启动了一个事务，事务的名称是：</p>
<pre class="code">com.foo.BusinessService.handlePayment</pre>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="tx-propagation"></a>9.5.7.&#160;事务传播</h3></div></div></div>
<p><span class="emphasis"><em>请注意这部分的Spring参考文档<span class="emphasis"><em>不是</em></span> 事务传播的介绍，
			而是详细介绍了在Spring中与事务传播相关的一些语义。 </em></span></p>
<p>在由Spring管理的事务中，请记住 <span class="emphasis"><em>物理</em></span> 和 <span class="emphasis"><em>逻辑</em></span> 事务存在的差异，
			以及传播设置是如何影响到这些差异的。 </p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="tx-propagation-required"></a>9.5.7.1.&#160;required</h4></div></div></div>
<p>
					</p>
<div class="mediaobject" align="center">
<img src="images/tx_prop_required.png" align="middle"><div class="caption"><p>PROPAGATION_REQUIRED</p></div>
</div>
<p>
				</p>
<p>当事务传播被设置<code class="literal">PROPAGATION_REQUIRED</code>的时候，
				会为每一个被应用到的方法创建一个<span class="emphasis"><em>逻辑</em></span>事务作用域。
				每一个这样的逻辑事务作用域都可以自主地决定rollback-only状态，当这样的逻辑事务作用域被外部的一个逻辑事务作用域所包含的时候，
				他们在逻辑上是独立的。当然了，对于正常的 <code class="literal">PROPAGATION_REQUIRED</code>设置来说，他会被映射到相同的物理事务上。
				所以一个标记有rollback-only的内部逻辑事务作用域的确会影响到外部的逻辑事务作用域（就像你所预料的那样）。 </p>
<p>然而，当内部的事务作用域标记为rollback-only，同时外部的事务作用域并没有决定要回滚，
				这样的回滚是意料不到的（静悄悄地由内部事务作用域触发的）：
				一个对应的<code class="classname">UnexpectedRollbackException</code> 异常会在这个时候被抛出。这是 <span class="emphasis"><em>可以预料到的行为</em></span>，
				只有这样，这个事务的调用者才不会被误导，在事务没有提交的情况下误以为事务已经提交。所以如果内部的事务（外部的调用者并不知情）标记该事务为
				rollback-only，而外部的调用者却依旧在不知情的情况下提交后，它需要收到一个 <code class="classname">UnexpectedRollbackException</code>
				异常来清楚的了解事务并没有提交而是发生了回滚。
				 </p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="tx-propagation-requires_new"></a>9.5.7.2.&#160;RequiresNew</h4></div></div></div>
<p>
					</p>
<div class="mediaobject" align="center">
<img src="images/tx_prop_requires_new.png" align="middle"><div class="caption"><p>PROPAGATION_REQUIRES_NEW</p></div>
</div>
<p>
				</p>
<p><code class="literal">PROPAGATION_REQUIRES_NEW</code>，与之前相反，为每一个相关的事务作用域使用了一个<span class="emphasis"><em>完全</em></span>
				独立的事务。在这种情况下，物理事务也将是不同的，因此外部事务可以不受内部事务回滚状态的影响独立提交或者回滚。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="tx-propagation-nested"></a>9.5.7.3.&#160;Nested</h4></div></div></div>
<p><code class="literal">PROPAGATION_NESTED</code> 是一个完全不同的设置。它使用了一个<span class="emphasis"><em>单独</em></span>的物理事务，
				这个事务拥有多个可以回滚的保存点。这样部分回滚允许内部事务<span class="emphasis"><em>在它的作用域内</em></span>触发一个回滚，
				并且外部事务能够不受影响的继续。 这通常是对应于JDBC的保存点，所以只会在 JDBC 资源事务管理上起效
				(具体请参见 Spring的<code class="classname">DataSourceTransactionManager</code>).</p>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="transaction-declarative-applying-more-than-just-tx-advice"></a>9.5.8.&#160;通知事务操作</h3></div></div></div>
<p>考虑一下这样的情况，如果你希望 <span class="emphasis"><em>同时</em></span>执行事务性通知（advice）<span class="emphasis"><em>和</em></span>一些基本的剖析（profiling）通知。
			那么，在<code class="literal">&lt;tx:annotation-driven/&gt;</code>环境中该怎么做？</p>
<p>我们调用 <code class="methodname">updateFoo(Foo)</code> 方法时希望这样：</p>
<div class="itemizedlist"><ul type="disc">
<li><p>配置的剖析切面（profiling aspect）开始启动，</p></li>
<li><p>然后进入事务通知（根据配置创建一个新事务或加入一个已经存在的事务），</p></li>
<li><p>然后执行原始对象的方法，</p></li>
<li><p>然后事务提交（我们假定这里一切正常），</p></li>
<li><p>最后剖析切面报告整个事务方法执行过程花了多少时间。</p></li>
</ul></div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>这章不会专门讲述AOP的所有细节（除了应用于事务方面的之外）。
				请参考 <a href="ch06.html" title="第&#160;6&#160;章&#160;使用Spring进行面向切面编程（AOP）">第&#160;6&#160;章 <i>使用Spring进行面向切面编程（AOP）</i></a> 章节以获得对各种AOP配置及其一般概念的详细叙述。
                </p>
</div>
<p>这里有一份简单的剖析切面（profiling aspect）的代码。<span class="emphasis"><em>
			（请注意，通知的顺序是由 <code class="interfacename">Ordered</code> 接口来控制的。
			要想了解更多细节，请参考 <a href="ch06s02.html#aop-ataspectj-advice-ordering" title="6.2.4.7.&#160;通知顺序">第&#160;6.2.4.7&#160;节 “通知顺序”</a> 节。）</em></span>
			</p>
<pre class="code">package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;
import org.springframework.core.Ordered;

public class SimpleProfiler implements Ordered {

  private int order;

  <em class="lineannotation"><span class="lineannotation">// allows us to control the ordering of advice</span></em>
  public int getOrder() {
    return this.order;
  }

  public void setOrder(int order) {
    this.order = order;
  }

  <em class="lineannotation"><span class="lineannotation">// this method <span class="emphasis"><em>is</em></span> the around advice</span></em>
  public Object profile(ProceedingJoinPoint call) throws Throwable {
    Object returnValue;
    StopWatch clock = new StopWatch(getClass().getName());
    try {
      clock.start(call.toShortString());
      returnValue = call.proceed();
    } finally {
      clock.stop();
      System.out.println(clock.prettyPrint());
    }
    return returnValue;
  }
}
</pre>
<pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:aop="http://www.springframework.org/schema/aop"
     xmlns:tx="http://www.springframework.org/schema/tx"
     xsi:schemaLocation="
   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- this is the aspect --&gt;</span></em>
  &lt;bean id="profiler" class="x.y.SimpleProfiler"&gt;
    <em class="lineannotation"><span class="lineannotation">&lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span></em>
    &lt;property name="order" <span class="bold"><strong>value="1"</strong></span>/&gt;
  &lt;/bean&gt;

  &lt;tx:annotation-driven transaction-manager="txManager" <span class="bold"><strong>order="200"</strong></span>/&gt;

  &lt;aop:config&gt;
    <em class="lineannotation"><span class="lineannotation">&lt;!-- this advice will execute <span class="bold"><strong>around</strong></span> the transactional advice --&gt;</span></em>
    &lt;aop:aspect id="profilingAspect" ref="profiler"&gt;
      &lt;aop:pointcut id="serviceMethodWithReturnValue"
              expression="execution(!void x.y..*Service.*(..))"/&gt;
      &lt;aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/&gt;
    &lt;/aop:aspect&gt;
  &lt;/aop:config&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
    &lt;property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/&gt;
    &lt;property name="username" value="scott"/&gt;
    &lt;property name="password" value="tiger"/&gt;
  &lt;/bean&gt;

  &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre>
<p>
            上面配置的结果将获得到一个拥有剖析和事务方面的 <span class="emphasis"><em>按那样的顺序</em></span> 应用于它上面的 <code class="literal">'fooService'</code> bean。
            许多附加的方面的配置将一起达到这样的效果。
            </p>
<p>
            最后，下面的一些示例演示了使用纯XML声明的方法来达到上面一样的设置效果。
            </p>
<pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:aop="http://www.springframework.org/schema/aop"
     xmlns:tx="http://www.springframework.org/schema/tx"
     xsi:schemaLocation="
   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- the profiling advice --&gt;</span></em>
  &lt;bean id="profiler" class="x.y.SimpleProfiler"&gt;
    <em class="lineannotation"><span class="lineannotation">&lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span></em>
    <span class="bold"><strong>&lt;property name="order" value="1</strong></span>"/&gt;
  &lt;/bean&gt;

  &lt;aop:config&gt;

    &lt;aop:pointcut id="entryPointMethod" expression="execution(* x.y..*Service.*(..))"/&gt;

    <em class="lineannotation"><span class="lineannotation">&lt;!-- will execute after the profiling advice (c.f. the order attribute) --&gt;</span></em>
    &lt;aop:advisor
        advice-ref="txAdvice"
        pointcut-ref="entryPointMethod"
        <span class="bold"><strong>order="2</strong></span>"/&gt; <em class="lineannotation"><span class="lineannotation">&lt;!-- order value is higher than the profiling aspect --&gt;</span></em>

    &lt;aop:aspect id="profilingAspect" ref="profiler"&gt;
      &lt;aop:pointcut id="serviceMethodWithReturnValue"
              expression="execution(!void x.y..*Service.*(..))"/&gt;
      &lt;aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/&gt;
    &lt;/aop:aspect&gt;

  &lt;/aop:config&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="get*" read-only="true"/&gt;
      &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  <em class="lineannotation"><span class="lineannotation">&lt;!-- other &lt;bean/&gt; definitions such as a <code class="interfacename">DataSource</code> and a <code class="interfacename">PlatformTransactionManager</code> here --&gt;</span></em>

&lt;/beans&gt;</pre>
<p>上面配置的结果是创建了一个 <code class="literal">'fooService'</code> bean，剖析方面和事务方面被 <span class="emphasis"><em>依照顺序</em></span> 施加其上。如果我们希望剖析通知在目标方法执行之前 <span class="emphasis"><em>后于</em></span> 事务通知执行，而且在目标方法执行之后 <span class="emphasis"><em>先于</em></span> 事务通知，我们可以简单地交换两个通知bean的order值。</p>
<p>如果配置中包含更多的方面，它们将以同样的方式受到影响。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="transaction-declarative-aspectj"></a>9.5.9.&#160;结合AspectJ使用 <code class="interfacename">@Transactional</code></h3></div></div></div>
<p>通过AspectJ切面，你也可以在Spring容器之外使用Spring框架的 <code class="interfacename">@Transactional</code> 功能。要使用这项功能你必须先给相应的类和方法加上 <code class="interfacename">@Transactional</code>注解，然后把 <code class="filename">spring-aspects.jar</code> 文件中定义的 <code class="classname">org.springframework.transaction.aspectj.AnnotationTransactionAspect</code> 切面连接进（织入）你的应用。同样，该切面必须配置一个事务管理器。你当然可以通过Spring框架容器来处理注入，但因为我们这里关注于在Spring容器之外运行应用，我们将向你展示如何通过手动书写代码来完成。</p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>在我们继续之前，你可能需要好好读一下前面的<a href="ch09s05.html#transaction-declarative-annotations" title="9.5.6.&#160;使用 @Transactional">第&#160;9.5.6&#160;节 “使用 <code class="interfacename">@Transactional</code>”</a> 和 <a href="ch06.html" title="第&#160;6&#160;章&#160;使用Spring进行面向切面编程（AOP）">第&#160;6&#160;章 <i>使用Spring进行面向切面编程（AOP）</i></a> 两章。</p>
</div>
<pre class="code"><em class="lineannotation"><span class="lineannotation">// construct an appropriate transaction manager </span></em>
DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());

<em class="lineannotation"><span class="lineannotation">// configure the <code class="classname">AnnotationTransactionAspect</code> to use it; this must be done before executing any transactional methods</span></em>
AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager); </pre>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">注意</h3>
<p>
	            使用此切面（aspect），你必须在 <span class="emphasis"><em>实现</em></span> 类（和/或类里的方法）、而 <span class="emphasis"><em>不是</em></span> 类的任何所实现的接口上面进行注解。AspectJ遵循Java的接口上的注解 <span class="emphasis"><em>不被继承</em></span> 的规则。
	            </p>
</div>
<p>
	        定义在类上的 <code class="interfacename">@Transactional</code> 注解指定了类中所有方法执行时的默认事务语义。
	        </p>
<p>
	        定义在类的方法上的 <code class="interfacename">@Transactional</code> 注解将覆盖掉类上注解的所指定的默认事务语义（如过存在的话）。
	        所有的方法都可以注解，不管它的可见度是什么样的。
	        </p>
<p>
			要把 <code class="classname">AnnotationTransactionAspect</code> 织入你的应用，你或者基于AspectJ构建你的应用（参考 <a href="" target="_top">AspectJ Development Guide</a>），或者采取“载入时织入”（load-time weaving），参考 <a href="ch06s08.html#aop-aj-ltw" title="6.8.4.&#160;在Spring应用中使用AspectJ加载时织入（LTW）">第&#160;6.8.4&#160;节 “在Spring应用中使用AspectJ加载时织入（LTW）”</a> 获得关于使用AspectJ进行“载入时织入”的讨论。
			</p>
</div>
</div>

<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->