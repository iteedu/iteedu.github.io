<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->


<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="portlet-handlermapping"></a>16.5.&#160;处理器映射</h2></div></div></div>
<p>通过处理器映射，可以把进来的portlet请求对应到合适的处理器上。已经有一些
		现成的处理器映射可以使用，比如<code class="classname">PortletModeHandlerMapping</code>。
		但还是让我们先看一下<code class="interfacename">HandlerMapping</code>的一般概念。</p>
<p>注意，我们这里有意使用“处理器”来代替“控制器”。
		<code class="classname">DispatcherPortlet</code>是设计用来和多种方式一起处理请求的，
		而不仅仅是和Spring Portlet MVC自己的控制器。处理器是任意可以处理Portlet请求的对象。
		控制器当然缺省是一种处理器。要将<code class="classname">DispatcherPortlet</code>
		和一些其他的框架一起使用，只需要实现相应的<code class="interfacename">HandlerAdapter</code>就可以了。</p>
<p><code class="interfacename">HandlerMapping</code>提供的基本功能是提供一个
		<code class="classname">HandlerExecutionChain</code>，后者必须包含匹配进来请求的
		的处理器，也可能包含需要应用到请求的处理器拦截器的列表。当一个请求进来时，
		<code class="classname">DispatcherPortlet</code>会把它交给处理器射映，让它来检查
		请求并得到合适的<code class="classname">HandlerExecutionChain</code>。然后
		<code class="classname">DispatcherPortlet</code>会执行处理器以及chain里的拦截器。这些
		概念和Spring Web MVC中的完全一致。</p>
<p>可配置的处理器映射非常强大，它可以包含拦截器(在实际的处理前、后进行预处理或后处理
		或两者都执行)。可以通过自定义一个<code class="interfacename">HandlerMapping</code>来加入许多功能。
		想像一下，一个自定义的处理器映射，它不仅可以根据指定的portlet模式来选择处理器，
		也可以根据请求相联系的session里的指定状态来选择。</p>
<p>在Spring Web MVC里，处理器映射通常是基于URL的。因为在Portlet里确实没有URL，
		必须使用其它的机制来控制映射。最常见的两个是portlet模式和请求参数，
		但在portlet请求里的任何对象都可以用在自定义的处理器映射中。</p>
<p>余下的章节会介绍在Spring Portlet MVC里最常见的三种处理器射映，
		它们都继承<code class="classname">AbstractHandlerMapping</code>并且共享以下的属性：</p>
<div class="itemizedlist"><ul type="disc">
<li><p><code class="literal">interceptors</code>: 需要使用的拦截器列表。
			<code class="interfacename">HandlerInterceptor</code>在 
			<a href="ch16s05.html#portlet-handlermapping-interceptor" title="16.5.4.&#160;增加 HandlerInterceptors">第&#160;16.5.4&#160;节 “增加 <code class="interfacename">HandlerInterceptor</code>s”</a>有讨论。</p></li>
<li><p><code class="literal">defaultHandler</code>: 在找不到匹配的处理器时，缺省的处理器。
			</p></li>
<li><p><code class="literal">order</code>: Spring会按照order属性值
			(见<code class="interfacename">org.springframework.core.Ordered</code>接口)
			对context里的所有处理器映射进行排序，并且应用第一个匹配的处理器。</p></li>
<li><p><code class="literal">lazyInitHandlers</code>: 用来Lazy初始化单例
			处理器(prototype处理器是始终lazy初始化的)。缺省值是false。这个属性是在这三个具体处理器里直接实现。
			</p></li>
</ul></div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="portlet-handlermapping-portletmode"></a>16.5.1.&#160;<code class="classname">PortletModeHandlerMapping</code></h3></div></div></div>
<p>这是一个简单的处理器映射，它是基于当前的portlet模式（比如：'view', 'edit', 'help'）。如下：</p>
<pre class="code">&lt;bean id="portletModeHandlerMapping"
      class="org.springframework.web.portlet.handler.PortletModeHandlerMapping"&gt;
    &lt;property name="portletModeMap"&gt;
        &lt;map&gt;
            &lt;entry key="view" value-ref="viewHandler"/&gt;
            &lt;entry key="edit" value-ref="editHandler"/&gt;
            &lt;entry key="help" value-ref="helpHandler"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="portlet-handlermapping-parameter"></a>16.5.2.&#160;<code class="classname">ParameterHandlerMapping</code></h3></div></div></div>
<p>如果需要在不改变portlet模式的情况下而在多个控制器间切换，
			最简单的方法是把一个请求参数作为key来控制映射。</p>
<p><code class="classname">ParameterHandlerMapping</code>使用一个特定的请求参数来控制映射。
			这个参数的缺省名是<code class="literal">'action'</code>，可以通过<code class="literal">'parameterName'</code>属性来改变。</p>
<p>这个映射的bean设置会是这样：</p>
<pre class="code">&lt;bean id="parameterHandlerMapping"
      class="org.springframework.web.portlet.handler.ParameterHandlerMapping”&gt;
    &lt;property name="parameterMap"&gt;
        &lt;map&gt;
            &lt;entry key="add" value-ref="addItemHandler"/&gt;
            &lt;entry key="edit" value-ref="editItemHandler"/&gt;
            &lt;entry key="delete" value-ref="deleteItemHandler"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="portlet-handlermapping-portletmodeparameter"></a>16.5.3.&#160;<code class="classname">PortletModeParameterHandlerMapping</code></h3></div></div></div>
<p>最强大的内置处理映射
			<code class="classname">PortletModeParameterHandlerMapping</code> 结合了前两者的功能，
			能够在每种portlet模式下进行不同的切换。</p>
<p>同样，参数的缺省名是“action”，但可以通过 <code class="literal">parameterName</code> 来修改。</p>
<p>缺省情况下，同样的参数值不能在两个不同的portlet模式下使用，
			因为如果portlet自己改变了portlet模式，那么请求在映射中将不在有效。
			把 <code class="literal">allowDupParameters</code> 属性设为true可以改变这种行为，但这种做法是不推荐的。</p>
<p>这个映射的bean设置会是这样：</p>
<pre class="code">&lt;bean id="portletModeParameterHandlerMapping"
      class="org.springframework.web.portlet.handler.PortletModeParameterHandlerMapping"&gt;
    &lt;property name="portletModeParameterMap"&gt;
        &lt;map&gt;
            &lt;entry key="view"&gt; <em class="lineannotation"><span class="lineannotation">&lt;!-- 'view' portlet mode --&gt;</span></em>
                &lt;map&gt;
                    &lt;entry key="add" value-ref="addItemHandler"/&gt;
                    &lt;entry key="edit" value-ref="editItemHandler"/&gt;
                    &lt;entry key="delete" value-ref="deleteItemHandler"/&gt;
                &lt;/map&gt;
            &lt;/entry&gt;
            &lt;entry key="edit"&gt; <em class="lineannotation"><span class="lineannotation">&lt;!-- 'edit' portlet mode --&gt;</span></em>
                &lt;map&gt;
                    &lt;entry key="prefs" value-ref="prefsHandler"/&gt;
                    &lt;entry key="resetPrefs" value-ref="resetPrefsHandler"/&gt;
                &lt;/map&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre>
<p>这个映射可以在处理链中放在
		<code class="classname">PortletModeHandlerMapping</code> 前面，它可以为每个模式以及全局提供缺省的映射。
		</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="portlet-handlermapping-interceptor"></a>16.5.4.&#160;增加 <code class="interfacename">HandlerInterceptor</code>s</h3></div></div></div>
<p>Spring的处理器映射机制里有处理器拦截器的概念，在希望对于特定的请求
			应用不同的功能时，它是非常有用。比如，检查用户名（principal）。同样，Spring
			Portlet MVC以Web MVC相同的方式实现了这些概念。</p>
<p>在处理器映射里的拦截器必须实现<code class="literal">org.springframework.web.portlet</code>
			里的<code class="interfacename">HandlerInterceptor</code>接口。
			和servlet的版本一样，这个接口定义了三个方法：一个在实际的处理器执行前被调用
			(<code class="literal">preHandle</code>)，一个在执行后被调用(<code class="literal">postHandle</code>)
			还有一个是在请求完全结束时被调用(<code class="literal">afterCompletion</code>)。
			这三个方法应该可以为各种前置和后置处理提供足够的灵活。</p>
<p><code class="literal">preHandle</code>返回一个布尔值。可以使用这个方法来中断或者继续执行链的处理。
			当返回<code class="literal">true</code>时，处理执行链会继续，当返回<code class="literal">false</code>时，
			<code class="classname">DispatcherPortlet</code>
			假设这个拦截器已经处理请求（比如，显示了合适的视图）并且不需要继续执行其它的
			拦截器和在执行链中实际的处理器。</p>
<p><code class="literal">postHandle</code>只会在<code class="interfacename">RenderRequest</code>
			中被调用。<code class="interfacename">ActionRequest</code>和<code class="interfacename">RenderRequest</code>
			都会调用<code class="literal">preHandle</code>和<code class="literal">afterCompletion</code>方法。
			如果希望只在其中的一种请求中执行你的代码，务必在处理前检查请求的类型。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="portlet-handlermapping-interceptoradapter"></a>16.5.5.&#160;<code class="classname">HandlerInterceptorAdapter</code></h3></div></div></div>
<p>和servlet包类似，portlet包里也有一个 <code class="interfacename">HandlerInterceptor</code>
			的具体实现 <code class="classname">HandlerInterceptorAdapter</code> 。这个类所有方法都是空的，
			所以可以继承它，实现一个或两个你所需要的方法。
			</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="portlet-handlermapping-parameterinterceptor"></a>16.5.6.&#160;<code class="classname">ParameterMappingInterceptor</code></h3></div></div></div>
<p>Portlet包也带一个名为<code class="classname">ParameterMappingInterceptor</code>
			的具体拦截器，它可以和<code class="classname">ParameterHandlerMapping</code>
			以及<code class="classname">PortletModeParameterHandlerMapping</code>一起使用。
			这个拦截器可以把用来控制映射的参数从<code class="interfacename">ActionRequest</code>
			带到随后的<code class="interfacename">RenderRequest</code>，这能够确保
			<code class="interfacename">RenderRequest</code>映射到和
			<code class="interfacename">ActionRequest</code>相同的处理器。这些都是在
			<code class="literal">preHandle</code>方法里完成的，所以在你的处理器里仍然可以改变决定
			<code class="interfacename">RenderRequest</code>映射的参数值。</p>
<p>注意这个拦截器会调用<code class="interfacename">ActionResponse</code>
			的<code class="literal">setRenderParameter</code>方法，这意味着在使用它的时候，
			不能在处理器里调用<code class="literal">sendRedirect</code>。如果确实需要重定向，
			可以手工地把映射参数向前传，或者另写一个拦截器来处理。</p>
</div>
</div>

<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->