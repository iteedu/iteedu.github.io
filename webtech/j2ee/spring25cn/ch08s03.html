<!--hmt-->
<!-- header-start -->
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="/include/js/jquery.min.js" language="javascript"></script>
<script src="/include/js/jquery-ui.min.js" language="javascript"></script>
<link href="/include/css/jquery-ui.min.css" rel="stylesheet" type="text/css" />
<link href="/include/css/main.css" rel="stylesheet" type="text/css" />

<SCRIPT>
	$(document).ready(function() {
		$( "#menu" ).menu({ position: { my: "left top", at: "right-100 top+35" } });
	});
</SCRIPT>

<!-- header-end --><!--end of htmlheader-->

<!-- middle-start -->
﻿
<base target="_blank" />
</head>
<body>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- topmenu-start -->
<header>
    <section id="global-nav">
        <nav>
            <ul class="projects">
                    <li><a href="/">ITeedu.com</a></li>
            </ul>
            <ul class="links">
                    <li><a>快捷导航</a>
                        <ul>
                            <li><a href="/plang/">编程语言</a></li>
                            <li><a href="/webtech/">WEB开发</a></li>
                            <li><a href="/handset/">手机开发</a></li>
                            <li><a href="/database/">数据库</a></li>
                            <li><a href="/os/">操作系统</a></li>
                            <li><a href="/embed/">嵌入式</a></li>
                            <li><a href="/opensource/">开源软件</a></li>
                            <li><a href="/works/">作品</a></li>

                        </ul>
                    </li>
                    <li><a href="/plang/asm/">编辑语言</a>
                        <ul>
                                <li><a href="/plang/asm/">汇编</a></li>
                                <li><a href="/plang/ccpp/">C/C++</a> </li>
                                <li><a href="/plang/java/">JAVA</a> </li>
                                <li><a href="/plang/python/">Python</a> </li>
                                <li><a href="/plang/ruby/">Ruby</a></li>
                        </ul>
                    </li>
                    <li><a href="/webtech/">WEB开发</a>
                        <ul>
                            <li><a href="/webtech/javascript/">javascript</a> </li>
                            <li><a href="/webtech/j2ee/">J2EE</a> </li>
                            <li><a href="/webtech/php/">PHP</a> </li>
                            <li><a href="/webtech/python/djangocn2/">Django</a> </li>
                        </ul>
                    </li>
					<li><a href="/me/contactme.htm">关于</a></li>
            </ul>
        </nav>
    </section>
</header>
<!-- topmenu-end -->

<div id="container" style="margin: 35px 120px 0px 120px;">
	<div id="logo-wapper">
		<div style="float:left;width:150px;" ><h1 class="logo">ITEEDU</h1></div>
		<div style="float:right;width:760px">

		</div>
		<div style="clear:both;"></div>
	</div>
<nav id="main-nav">
<!-- menunav-start -->
<div id="menu">
    <li><a href="/plang/">编程语言</a>
        <ul>
            <LI><a href="/plang/asm/">汇编</a></LI>
            <LI><a href="/plang/ccpp/">C/C++</a> </LI>
            <LI><a href="/plang/java/">JAVA</a> </LI>
            <LI><a href="/plang/python/">Python</a> </LI>
            <LI><a href="/plang/ruby/">Ruby</a></LI>
        </ul>
    </li>
    <li><a href="/webtech/index.php">WEB开发</a>
        <ul>
            <LI><a href="/webtech/j2ee/">J2EE</a></LI>
            <LI><a href="/webtech/php/">PHP</a> </LI>
            <LI><a href="/webtech/python/djangocn2/">djangocn2</a> </LI>
        </ul>
    </li>
    <li><a href="/handset/index.php">手机开发</a>
        <ul>
            <LI><a href="/handset/android/">android</a></LI>
            <LI><a href="/handset/iphone/">iphone</a> </LI>
        </ul>
    </li>
    <li><a href="/database/index.php">数据库</a>
        <ul>
            <LI><a href="/database/mysql/">MYSQL</a></LI>
            <LI><a href="/database/sqlite/">sqlite</a></LI>
    	</ul>
    </li>
    <li><a href="/os/">操作系统</a>
        <ul>
        	<LI><a href="/os/linux/">Linux</a></LI>
        	<LI><a href="/os/grub/">GRUB</a></LI>
    	</ul>
     </li>
     <li><a href="/embed/">嵌入式</a></li>
     <li><a href="/opensource/">开源软件</a></li>
</div>
<!-- menunav-end -->
</nav>
<div id="content-wrapper">
<div id="file-wrapper">


<!-- middle-end -->
<!--end of htmlmiddle-->


<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="integration-testing"></a>8.3.&#160;集成测试</h2></div></div></div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="integration-testing-overview"></a>8.3.1.&#160;概览</h3></div></div></div>
<p>能够无需部署到你的应用服务器上或连接其它企业架构就实现集成测试是非常重要的。这可以让你来进行以下测试：</p>
<div class="itemizedlist"><ul type="disc">
<li><p>正确配置Spring IoC 容器上下文。</p></li>
<li><p>使用JDBC或ORM工具的数据访问。可能包括如SQL脚本，Hibernate query，JPA 实体映射等的正确性验证。</p></li>
</ul></div>
<p>Spring框架提供集成测试的一流支持，相关类打包在<code class="filename">spring-test.jar</code>类库中。在这个类库中，你可以找到<code class="literal">org.springframework.test</code>包，有很多方便使用Spring容器进行集成测试的类，而且同时不依赖应用服务器或其它部署环境。这些测试会比单元测试慢，但会比Cactus（译者注：Apache测试服务端Java代码的工具http://jakarta.apache.org/cactus/index.html ）测试或依靠部署到一个应用服务器上来进行远程测试要快捷的多。</p>
<p>在2.5版本之前，Spring已经提供了<a href="ch08s03.html#junit38-legacy-support" title="8.3.6.&#160;JUnit 3.8遗留支持">面向JUnit 3.8的单元测试支持</a>.
      在2.5版本中, Spring 提供了单元和集成测试支持 <a href="ch08s03.html#testcontext-framework" title="8.3.7.&#160;Spring TestContext Framework">Spring TestContext框架</a>。
      它是实际测试框架的混合体，因此能够帮助在多个测试环境包括JUnit 3.8,JUnit 4.4, TestNG等中进行测试。 <span class="emphasis"><em>注意Spring TestContext框架需要Java 5+支持.</em></span></p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="integration-testing-which-framework"></a>8.3.2.&#160;使用哪个支持框架</h3></div></div></div>
<p>Spring团队推荐使用<a href="ch08s03.html#testcontext-framework" title="8.3.7.&#160;Spring TestContext Framework">Spring TestContext框架</a>
      来进行所有新的单元测试和集成测试，以包括<code class="classname">ApplicationContext</code>或需要事务管理的情况。
      但如果你开发在Java5之前的环境上，就需要继续使用<a href="ch08s03.html#junit38-legacy-support" title="8.3.6.&#160;JUnit 3.8遗留支持">JUnit 3.8遗留支持</a>. 另外，显式
      <a href="ch08s03.html#junit38-legacy-jpa-tests" title="8.3.6.5.2.&#160;JPA支持类">JPA集成测试支持</a>
       依赖于<span class="emphasis"><em>shadow class载入</em></span>来进行JPA类测试(class instrumentation)目前只能与JUnit 3.8遗留支持相容。
       如果你要测试的JPA提供者不需要class instrumentation，就推荐使用TestContext框架。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="integration-testing-common-goals"></a>8.3.3.&#160;通用目标</h3></div></div></div>
<p>Spring集成测试支持框架提供了一些通用目标，包括：</p>
<div class="itemizedlist"><ul type="disc">
<li><p>跨越各个测试案例执行期的<a href="ch08s03.html#testing-ctx-management" title="8.3.3.1.&#160;上下文管理及缓存">Spring IoC容器缓存</a>。</p></li>
<li><p><a href="ch08s03.html#testing-fixture-di" title="8.3.3.2.&#160;测试fixtures依赖注入">测试fixture实例的依赖注入</a> (这很爽)。</p></li>
<li><p>适合集成测试的<a href="ch08s03.html#testing-tx" title="8.3.3.3.&#160;事务管理">事务管理</a>(这更加爽)。</p></li>
<li><p><a href="ch08s03.html#testing-support-classes" title="8.3.3.4.&#160;集成测试支持类">Spring特有的支持类</a>在编写集成测试时真的很有用。</p></li>
</ul></div>
<p>下面的章节具体描述每一个目标并提供指向特定支持框架的信息的链接。</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="testing-ctx-management"></a>8.3.3.1.&#160;上下文管理及缓存</h4></div></div></div>
<p>Spring集成测试支持框架提供了<code class="classname">ApplicationContext</code>的持久化载入和这些上下文的缓存机制。
        对已载入上下文的缓存是很重要的，因为如果你是在一个大型的项目中，启动时间会成为一个问题——不是因为Spring本身的开销，
        而是因为靠Spring容器来初始化的对象需要很长时间。比如一个有50-100 Hibernate映射文件的项目可能需要10-20秒来载入映射文件，
        而每次单一测试fixture的每个单一测试前都要这样的时间开销，减慢了整体的测试进度进而降低效率。</p>
<p>测试类通常会提供一个数组来包含XML配置元数据的资源路径——通常是classpath——来配置应用。这通常和<code class="literal">web.xml</code>或其它部署描述中指定的配置路径是相同或相近的。</p>
<p>默认情况下,一旦载入，<code class="interfacename">ApplicationContext</code>将在每次测试中重用。
        这样启动的开销将只需要一次（每个测试fixture），接下来的测试执行就会快得多。
        在一些少见的会“污染”应用上下文的案例中需要重新载入—— 例如，改变一个bean定义或应用对象的状态——
        Spring的测试支持提供了在执行下一个测试前让测试fixture重新载入配置并重建应用上下文的机制。</p>
<p>上下文管理和缓存使用：</p>
<div class="itemizedlist"><ul type="disc">
<li><p><a href="ch08s03.html#junit38-legacy-ctx-management" title="8.3.6.1.&#160;上下文管理及缓存">JUnit 3.8遗留支持</a></p></li>
<li><p><a href="ch08s03.html#testcontext-ctx-management" title="8.3.7.2.&#160;上下文管理和缓存">TestContext框架</a></p></li>
</ul></div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="testing-fixture-di"></a>8.3.3.2.&#160;测试fixtures依赖注入</h4></div></div></div>
<p>当Spring集成测试支持框架载入你的应用上下文时，它们能通过依赖注入选择性配置测试类实例。
        这提供了一个方便的机制来使用预先在应用上下文中配置的bean来搭建测试fixture。
        很大的好处就是你可以在各种测试场景中重用应用上下文(例如配置Spring管理的对象图，
        事务代理<code class="classname">DataSource</code>等)，从而能避免为单个的测试案例重复进行测试fixture搭建。</p>
<p>作为例子，考虑一个场景：我们有一个<code class="classname">HibernateTitleDao</code>类来实现数据访问逻辑，假设是<code class="classname">Title</code>域对象。我们希望编写测试所有以下方面的集成测试：</p>
<div class="itemizedlist"><ul type="disc">
<li><p>Spring配置: 最基本的，是否所有与<code class="classname">HibernateTitleDao</code> bean相关的配置都是正确和存在的？</p></li>
<li><p>Hibernate映射配置文件: 是否所有映射都是正确的并且lazy-loading设置也到位了？</p></li>
<li><p><code class="classname">HibernateTitleDao</code>逻辑：是否类的已配置示例的实现与预期相同？</p></li>
</ul></div>
<p>测试fixtures依赖注入使用：</p>
<div class="itemizedlist"><ul type="disc">
<li><p><a href="ch08s03.html#junit38-legacy-fixture-di" title="8.3.6.2.&#160;测试fixture依赖注入">JUnit 3.8 遗留支持</a></p></li>
<li><p><a href="ch08s03.html#testcontext-fixture-di" title="8.3.7.3.&#160;测试fixture的依赖注入">TestContext框架</a></p></li>
</ul></div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="testing-tx"></a>8.3.3.3.&#160;事务管理</h4></div></div></div>
<p>访问实际数据库的测试的一个通常问题是对持久化状态的影响。
        即使你使用开发数据库，状态的改变也可能影响后面的测试。而且很多操作 —— 
        如插入或修改持久化数据 —— 不能在事务外完成（或验证）。</p>
<p>Spring集成测试支持框架满足了这些需求。默认情况下，对每次测试它们会创建并回滚事务。
        你编写代码可以假定事务已经存在。如果你在测试中调用事务代理对象，它们将根据配置的事务语义正常响应。
        另外，如果测试方法在事务内删除了选定表的数据，这个事务会默认回滚，数据库也将回到测试执行前的状态。
        事务支持通过在测试应用上下文中定义的<code class="classname">PlatformTransactionManager</code> bean提供。</p>
<p>如果你希望事务被提交 —— 不常见,但可能你希望特定的测试插入或修改数据库 —— Spring集成测试支持框架
        可以通过调用一个继承下来的钩子(Hook)方法或声明特定注解来让事务提交而不是回滚。</p>
<p>事务管理使用:</p>
<div class="itemizedlist"><ul type="disc">
<li><p><a href="ch08s03.html#junit38-legacy-tx" title="8.3.6.3.&#160;事务管理">JUnit 3.8 遗留支持</a></p></li>
<li><p><a href="ch08s03.html#testcontext-tx" title="8.3.7.4.&#160;事务管理">TestContext框架</a></p></li>
</ul></div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="testing-support-classes"></a>8.3.3.4.&#160;集成测试支持类</h4></div></div></div>
<p>Spring集成测试支持框架提供了几个<code class="literal">abstract</code>支持类来简化编写集成测试。
        这些测试基类提供了定义良好的测试框架钩子，比如方便的变量实例和方法，来访问以下对象：</p>
<div class="itemizedlist"><ul type="disc">
<li><p><code class="literal">ApplicationContext</code>: 用来进行显式bean查找或整体测试上下文状态。</p></li>
<li><p><code class="classname">JdbcTemplate</code>或<code class="classname">SimpleJdbcTemplate</code>: 用来查询并确认状态。 
            例如，你可能需要在创建对象并通过ORM工具持久化到数据库中的测试案例运行前后进行查询，以确认数据在数据库中存在了。
            (Spring将确保查询在同一个事务范围内运行。) 你需要通知ORM工具来'flush'变化以确保正常工作，
            例如使用Hibernate <code class="interfacename">Session</code>接口的<code class="methodname">flush()</code>方法。</p></li>
</ul></div>
<p>你经常会提供一个应用范围的超类来为多个集成测试提供有用的实例变量。</p>
<p>支持类：</p>
<div class="itemizedlist"><ul type="disc">
<li><p><a href="ch08s03.html#junit38-legacy-support-classes" title="8.3.6.4.&#160;JUnit 3.8 遗留支持类">JUnit 3.8遗留支持</a></p></li>
<li><p><a href="ch08s03.html#testcontext-support-classes" title="8.3.7.5.&#160;TestContext支持类">TestContext框架</a></p></li>
</ul></div>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="integration-testing-support-jdbc"></a>8.3.4.&#160;JDBC测试支持</h3></div></div></div>
<p><code class="literal">org.springframework.test.jdbc</code>包含有<code class="classname">SimpleJdbcTestUtils</code>类，它
      是一个基于Java5的JDBC相关工具方法集，用来简化标准数据库测试场景。<span class="emphasis"><em>注意<a href="ch08s03.html#testcontext-support-classes-junit38" title="8.3.7.5.1.&#160;JUnit 3.8支持类"><code class="classname">AbstractTransactionalJUnit38SpringContextTests</code></a>,
      <a href="ch08s03.html#testcontext-support-classes-junit44" title="8.3.7.5.2.&#160;JUnit 4.4支持类"><code class="classname">AbstractTransactionalJUnit4SpringContextTests</code></a>,
      和<a href="ch08s03.html#testcontext-support-classes-testng" title="8.3.7.5.4.&#160;TestNG支持类"><code class="classname">AbstractTransactionalTestNGSpringContextTests</code></a>
      提供了简便的方法来内部代理到<code class="classname">SimpleJdbcTestUtils</code>。</em></span></p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="integration-testing-common-annotations"></a>8.3.5.&#160;常用注解</h3></div></div></div>
<p>Spring框架在<code class="literal">org.springframework.test.annotation</code>
      包中提供了常用的<span class="emphasis"><em>Spring特定的</em></span>注解集，如果你在Java5或以上版本开发，可以在测试中使用它。</p>
<div class="itemizedlist"><ul type="disc">
<li>
<p><span class="bold"><strong><code class="interfacename">@IfProfileValue</code></strong></span></p>
<p>提示一下，注解测试只针对特定的测试环境。
          如果配置的<code class="classname">ProfileValueSource</code>类返回对应的提供者的<code class="literal">名称</code><code class="literal">值</code>，
          这个测试就可以启动。这个注解可以应用到一个类或者单独的方法。</p>
<pre class="code">@IfProfileValue(name="java.vendor", value="Sun Microsystems Inc.")
public void testProcessWhichRunsOnlyOnSunJvm() {
    <em class="lineannotation"><span class="lineannotation">// some logic that should run only on Java VMs from Sun Microsystems</span></em>
}</pre>
<p>同时<code class="interfacename">@IfProfileValue</code>可配置一个<code class="literal">值</code>列表
          (使用<span class="emphasis"><em>OR</em></span> 语义) 来在JUnit环境中获得TestNG的<span class="emphasis"><em>测试组</em></span>支持。
          看下面的例子：</p>
<pre class="code">@IfProfileValue(name="test-groups", values={"unit-tests", "integration-tests"})
public void testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    <em class="lineannotation"><span class="lineannotation">// some logic that should run only for unit and integration test groups</span></em>
}</pre>
</li>
<li>
<p><span class="bold"><strong><code class="interfacename">@ProfileValueSourceConfiguration</code></strong></span></p>
<p>类级别注解用来指定当通过<code class="interfacename">@IfProfileValue</code>注解获取已配置的<span class="emphasis"><em>profile值</em></span>时使用何种<code class="literal">ProfileValueSource</code>。
          如果<code class="interfacename">@ProfileValueSourceConfiguration</code>没有在测试中声明，将默认使用<code class="classname">SystemProfileValueSource</code>。</p>
<pre class="code">@ProfileValueSourceConfiguration(CustomProfileValueSource.class)
public class CustomProfileValueSourceTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>
</li>
<li>
<p><span class="bold"><strong><code class="interfacename">@DirtiesContext</code></strong></span></p>
<p>在测试方法上出现这个注解时，表明底层Spring容器在该方法的执行中被“污染”，从而必须在方法执行结束后重新创建（无论该测试是否通过）。</p>
<pre class="code">@DirtiesContext
public void testProcessWhichDirtiesAppCtx() {
    <em class="lineannotation"><span class="lineannotation">// some logic that results in the Spring container being dirtied</span></em>
}</pre>
</li>
<li>
<p><span class="bold"><strong><code class="interfacename">@ExpectedException</code></strong></span></p>
<p>表明被注解方法预期在执行中抛出一个异常。预期异常的类型在注解中给定。如果该异常的实例在测试方法执行中被抛出，
          则测试通过。同样的如果该异常实例<span class="emphasis"><em>没有</em></span>在测试方法执行时抛出，则测试失败。</p>
<pre class="code">@ExpectedException(SomeBusinessException.class)
public void testProcessRainyDayScenario() {
    <em class="lineannotation"><span class="lineannotation">// some logic that should result in an <code class="classname">Exception</code> being thrown</span></em>
}</pre>
</li>
<li>
<p><span class="bold"><strong><code class="interfacename">@Timed</code></strong></span></p>
<p>表明被注解的测试方法必须在规定的时间区间内执行完成（以毫秒记）。如果测试执行时间超过了规定的时间区间，测试就失败了。</p>
<p>注意该时间区间包括测试方法本身的执行，任何重复测试（参见 <code class="interfacename">@Repeat</code>），还有任何测试fixture的<span class="emphasis"><em>set up</em></span>或<span class="emphasis"><em>tear down</em></span>时间。</p>
<pre class="code">@Timed(millis=1000)
public void testProcessWithOneSecondTimeout() {
    <em class="lineannotation"><span class="lineannotation">// some logic that should not take longer than 1 second to execute</span></em>
}</pre>
</li>
<li>
<p><span class="bold"><strong><code class="interfacename">@Repeat</code></strong></span></p>
<p>表明被注解的测试方法必须重复执行。执行的次数在注解中声明。</p>
<p>注意重复执行范围包括包括测试方法本身的执行，以及任何测试fixture的<span class="emphasis"><em>set up</em></span>或<span class="emphasis"><em>tear down</em></span>。</p>
<pre class="code">@Repeat(10)
public void testProcessRepeatedly() {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
</li>
<li>
<p><span class="bold"><strong><code class="interfacename">@Rollback</code></strong></span></p>
<p>表明被注解方法的事务在完成后是否需要被<span class="emphasis"><em>回滚</em></span>。
          如果<code class="literal">true</code>，事务将被回滚，否则事务将被提交。
          使用<code class="interfacename">@Rollback</code>接口来在类级别覆写配置的默认回滚标志。</p>
<pre class="code">@Rollback(false)
public void testProcessWithoutRollback() {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
</li>
<li>
<p><span class="bold"><strong><code class="interfacename">@NotTransactional</code></strong></span></p>
<p>出现该注解表明测试方法必须<span class="emphasis"><em>不</em></span>在事务中执行。</p>
<pre class="code">@NotTransactional 
public void testProcessWithoutTransaction() {
    <em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
</li>
</ul></div>
<p>注解支持：</p>
<div class="itemizedlist"><ul type="disc">
<li><p><a href="ch08s03.html#junit38-legacy-java5-support" title="8.3.6.5.&#160;Java 5+ 专有支持">JUnit 3.8遗留支持</a>：
          所有上面列举的注解都被支持，但<span class="emphasis"><em>必须</em></span>与<code class="classname">AbstractAnnotationAwareTransactionalTests</code>类联合使用，以保证这些注解能起作用。</p></li>
<li><p><a href="ch08s03.html#testcontext-annotations" title="8.3.7.6.&#160;TestContext框架注解支持">TestContext框架</a>：
          支持上面列举的所有注解，而且提供了额外的TestContext特定注解
          (例如<code class="interfacename">@ContextConfiguration</code>、<code class="interfacename">@BeforeTransaction</code>等等)。
          注意，但是一些注解只有与JUnit联合使用时(例如，基于<a href="ch08s03.html#testcontext-junit4-runner" title="8.3.7.5.3.&#160;定制JUnit 4.4运行器">SpringJUnit4ClassRunner</a>
          或<a href="ch08s03.html#testcontext-support-classes-junit38" title="8.3.7.5.1.&#160;JUnit 3.8支持类">JUnit 3.8</a>以及<a href="ch08s03.html#testcontext-support-classes-junit44" title="8.3.7.5.2.&#160;JUnit 4.4支持类">JUnit 4.4</a>的测试类)。
          详细内容参见<span class="emphasis"><em>TestContext框架</em></span>章节。</p></li>
</ul></div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="junit38-legacy-support"></a>8.3.6.&#160;JUnit 3.8遗留支持</h3></div></div></div>
<p>Spring JUnit 3.8 遗留支持类打包在<code class="literal">org.springframework.test</code>包中。
      这个包提供了有用的JUnit <code class="classname">TestCase</code>超类，
      扩展它可以在容器外集成测试中引入Spring <code class="classname">ApplicationContext</code>类或在测试方法级别获得事务支持。</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="junit38-legacy-ctx-management"></a>8.3.6.1.&#160;上下文管理及缓存</h4></div></div></div>
<p><code class="classname">AbstractSingleSpringContextTests</code>为基于JUnit 3.8的测试案例提供了上下文管理和缓存支持。
        它暴露了一个<code class="literal">protected</code>方法来给子类覆写以提供上下文定义文件的路径：</p>
<pre class="code">protected String[] getConfigLocations()</pre>
<p>这个方法的实现必须提供包含XML配置元数据的资源路径 —— 通常是类路径 —— 的一个数组。
        这和在<code class="literal">web.xml</code>或其它部署配置中的资源路径是相同的或基本相同的。
        作为可选方案，你也可以覆写下面的方法。详细内容参见相关JavaDoc。</p>
<pre class="code">protected String[] getConfigPaths()</pre>
<pre class="code">protected String getConfigPath()</pre>
<p>默认情况下，一旦配置文件被载入就会在每个测试案例中重用。
        这样构建的开销只会产生一次（每个测试fixture），然后后面的测试执行会快速的多。
        在较少的情况下测试可能“污染”应用上下文，需要重新载入 —— 例如，
        改变一个bean定义或应用对象状态 —— 你可以调用<code class="classname">AbstractSingleSpringContextTests</code>类中的
        <code class="methodname">setDirty()</code>方法来让测试fixture在执行下一个测试案例时重新载
        <a href="ch08s03.html#junit38-legacy-annotation-aware-tests" title="8.3.6.5.1.&#160;使用注解的事务相关测试"><code class="classname">AbstractAnnotationAwareTransactionalTests</code></a>类，
        你可以使用<code class="interfacename">@DirtiesContext</code>来对测试方法进行注解以达到同样的效果。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="junit38-legacy-fixture-di"></a>8.3.6.2.&#160;测试fixture依赖注入</h4></div></div></div>
<p>当<code class="classname">AbstractDependencyInjectionSpringContextTests</code>类(及其子类)载入你的应用上下文时，
        它们可以通过Setter注入选择性配置你的测试类实例。你需要做的仅仅是定义实例变量和相应的setter方法。
        <code class="classname">AbstractDependencyInjectionSpringContextTests</code>将在<code class="methodname">getConfigLocations()</code>方法定义的配置文件集中自动查找相应对象。</p>
<p>假定这样一个场景，我们有一个<code class="classname">HibernateTitleDao</code>类(在<a href="ch08s03.html#testing-fixture-di" title="8.3.3.2.&#160;测试fixtures依赖注入">通常目标</a>章节详述)。
        让我们看基于JUnit 3.8 的测试类实现本身(我们很快将看看配置本身)。</p>
<pre class="code">public final class HibernateTitleDaoTests <span class="bold"><strong>extends AbstractDependencyInjectionSpringContextTests</strong></span>  {

    <em class="lineannotation"><span class="lineannotation">// this instance will be (automatically) dependency injected</span></em>    
    private HibernateTitleDao titleDao;

    <em class="lineannotation"><span class="lineannotation">// a setter method to enable DI of the 'titleDao' instance variable</span></em>
    public void setTitleDao(HibernateTitleDao titleDao) {
        this.titleDao = titleDao;
    }

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }

    <em class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></em>
    protected String[] getConfigLocations() {
        return new String[] { "classpath:com/foo/daos.xml" };
    }

}</pre>
<p>这个文件被<code class="methodname">getConfigLocations()</code>方法指定(比如，<code class="literal">"classpath:com/foo/daos.xml"</code>) 像这样：</p>
<pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" 
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    <em class="lineannotation"><span class="lineannotation">&lt;!-- this bean will be injected into the <code class="classname">HibernateTitleDaoTests</code> class --&gt;</span></em>
    &lt;bean id="<span class="bold"><strong>titleDao</strong></span>" class="<span class="bold"><strong>com.foo.dao.hibernate.HibernateTitleDao</strong></span>"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
        <em class="lineannotation"><span class="lineannotation">&lt;!-- dependencies elided for clarity --&gt;</span></em>
    &lt;/bean&gt;

&lt;/beans&gt;</pre>
<p><code class="classname">AbstractDependencyInjectionSpringContextTests</code>类使用<a href="ch03s03.html#beans-factory-autowire" title="3.3.5.&#160;自动装配（autowire）协作者"><span class="emphasis"><em>按类型自动装配</em></span></a>。
        因此如果你有多个bean定义是相同的类型，就不能在这些bean中使用这种方法。
        这种情况下，你可以使用继承的<code class="literal">applicationContext</code>实例变量并实现显式的查找（比如），
        调用<code class="methodname">applicationContext.getBean("titleDao")</code>方法。</p>
<p>如果你不希望在测试案例中使用依赖注入，只要不声明任何<code class="literal">public</code> setter方法就可以简单实现。
        作为替代的，你可以扩展<code class="classname">AbstractSpringContextTests</code> - 在<code class="literal">org.springframework.test</code>
        包中的JUnit 3.8集成测试支持类层次的根 - 它仅仅包含了一些载入Spring上下文的简单方法，而且不在测试fixture中使用依赖注入。</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h5 class="title">
<a name="junit38-legacy-fixture-di-field"></a>8.3.6.2.1.&#160;字段级别（Field Level）注入</h5></div></div></div>
<p>如果不管何种原因，你的测试fixture中没有setter方法，Spring可以对<code class="literal">protected</code>字段进行依赖注入。
          下面是前面使用字段级注入示例的新版本（Spring XML文件无需改变，仅仅需要改变测试fixture）。</p>
<pre class="code">public final class HibernateTitleDaoTests <span class="bold"><strong>extends AbstractDependencyInjectionSpringContextTests</strong></span>  {

    public HibernateTitleDaoTests() {
        <em class="lineannotation"><span class="lineannotation">// switch on field level injection</span></em>
        setPopulateProtectedVariables(true);
    }

    <em class="lineannotation"><span class="lineannotation">// this instance will be (automatically) dependency injected</span></em>
    <em class="lineannotation"><span class="lineannotation"><span class="emphasis"><em>protected</em></span></span></em> HibernateTitleDao <em class="lineannotation"><span class="lineannotation"><span class="emphasis"><em>titleDao</em></span></span></em>;

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }

    <em class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></em>
    protected String[] getConfigLocations() {
        return new String[] { "classpath:com/foo/daos.xml" };
    }

}</pre>
<p>在字段注入的情况下，不能使用自动装配：<code class="literal">protected</code> 实例变量被作为已配置的Spring容器的bean 查找名。</p>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="junit38-legacy-tx"></a>8.3.6.3.&#160;事务管理</h4></div></div></div>
<p><code class="classname">AbstractTransactionalSpringContextTests</code>类
        依赖于应用上下文中定义的<code class="classname">PlatformTransactionManager</code> bean。
        名字是无关紧要的，因为使用了<a href="ch03s03.html#beans-factory-autowire" title="3.3.5.&#160;自动装配（autowire）协作者"><span class="emphasis"><em>按类型自动装配</em></span></a>.</p>
<p>通常你会扩展其子类<code class="classname">AbstractTransactionalDataSourceSpringContextTests</code>。
        这个类也需要在应用上下文中有一个<code class="classname">DataSource</code> bean定义(同样可以是任意名称)。
        它创建一个<code class="classname">JdbcTemplate</code>实例变量，可以用来方便的查询和删除选定表的内容（
        请记住默认情况下事务将被回滚，因而这样做是安全的）。</p>
<p>如果你希望<span class="emphasis"><em>编程式</em></span>提交事务 —— 不常见但对于特殊的插入数据库的测试很有用 ——
         你可以调用继承自<code class="classname">AbstractTransactionalSpringContextTests</code>类的<code class="methodname">setComplete()</code> 方法。
         这将使事务提交而不是回滚。作为可替代的，如果你在Java 5或更高环境中开发扩展<a href="ch08s03.html#junit38-legacy-annotation-aware-tests" title="8.3.6.5.1.&#160;使用注解的事务相关测试"><code class="classname">AbstractAnnotationAwareTransactionalTests</code></a>类，
        你可以使用<code class="interfacename">@Rollback(false)</code>来注解测试方法，以通过<span class="emphasis"><em>配置</em></span>获得相同的效果。</p>
<p>通过调用<code class="methodname">endTransaction()</code>方法，这里可以在测试案例完成时中止一个事务。
        默认将回滚事务，除非前面调用了<code class="methodname">setComplete()</code>方法。
        这个特性当你希望测试‘断连接’的 数据对象行为是很有用，比如事务外的web或远程使用的Hibernate映射实体。
        通常懒加载错误只有通过UI测试发现。如果你调用<code class="methodname">endTransaction()</code>方法
        可以保证JUnit测试时UI操作的正确性。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="junit38-legacy-support-classes"></a>8.3.6.4.&#160;JUnit 3.8 遗留支持类</h4></div></div></div>
<p>当你扩展
        <code class="classname">AbstractTransactionalDataSourceSpringContextTests</code>类时，你将需要访问下面<code class="literal">protected</code> 实例变量:</p>
<div class="itemizedlist"><ul type="disc">
<li><p><code class="literal">applicationContext</code>(<code class="interfacename">ConfigurableApplicationContext</code>):
            继承自<code class="classname">AbstractSingleSpringContextTests</code>类。使用它可以进行显式bean查找或测试整个的上下文状态。</p></li>
<li><p><code class="literal">jdbcTemplate</code>: 继承自<code class="classname">AbstractTransactionalDataSourceSpringContextTests</code>类，用于查询已确认状态。
            例如,应用代码要创建一个对象，然后使用ORM工具将其持久化，这时你想在测试代码执行前后对其进行查询，以确定数据是否插入到数据库中（Spring会保证该查询运行在相同事务内）。你需要告诉你的ORM工具‘清空’其改变以正确完成任务，例如，使用Hibernate<code class="classname">Session</code>接口的<code class="methodname">flush()</code>方法。</p></li>
</ul></div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="junit38-legacy-java5-support"></a>8.3.6.5.&#160;Java 5+ 专有支持</h4></div></div></div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h5 class="title">
<a name="junit38-legacy-annotation-aware-tests"></a>8.3.6.5.1.&#160;使用注解的事务相关测试</h5></div></div></div>
<p>在上述<a href="ch08s03.html#integration-testing-common-annotations" title="8.3.5.&#160;常用注解">常用注解</a>之外，
          <code class="literal">org.springframework.test.annotation</code>包也有一个<code class="literal">抽象</code> JUnit
          <code class="classname">TestCase</code>类来提供注解驱动的集成测试支持。</p>
<p><code class="classname">AbstractAnnotationAwareTransactionalTests</code>类扩展了<code class="classname">AbstractTransactionalDataSourceSpringContextTests</code>类，
          并通过扩展fixture引入一些（Spring专有）的注解。<code class="classname">AbstractAnnotationAwareTransactionalTests</code>
          支持所有<a href="ch08s03.html#integration-testing-common-annotations" title="8.3.5.&#160;常用注解">常用注解</a>章节中列举的注解，
          而且包括Spring的<code class="interfacename">@Transactional</code>注解，以显式配置事务语义。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h5 class="title">
<a name="junit38-legacy-jpa-tests"></a>8.3.6.5.2.&#160;JPA支持类</h5></div></div></div>
<p><code class="literal">org.springframework.test.jpa</code>包提供了基于Java 持久化API(JPA)的测试支持类。</p>
<div class="itemizedlist"><ul type="disc">
<li><p><code class="classname">AbstractJpaTests</code>是一个方便的JPA相关测试的支持类，
              它提供了和<code class="classname">AbstractTransactionalDataSourceSpringContextTests</code>相同的功能和即使在进行JPA规范需要的性能测试时也相同的性能。
              它暴露了一个<code class="interfacename">EntityManagerFactory</code>接口和一个共享的<code class="interfacename">EntityManager</code>接口。
              需要注入一个<code class="interfacename">EntityManagerFactory</code>接口，
              以及通过超类获得<code class="interfacename">DataSource</code>接口和<code class="interfacename">JpaTransactionManager</code>接口。</p></li>
<li><p><code class="classname">AbstractAspectjJpaTests</code>类是<code class="classname">AbstractJpaTests</code>的子类，
              它激活了AspectJ 的装载期织入并能够让AspectJ指定一个自定义的<code class="literal">aop.xml</code>文件路径。</p></li>
</ul></div>
</div>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="testcontext-framework"></a>8.3.7.&#160;Spring TestContext Framework</h3></div></div></div>
<p><span class="emphasis"><em>Spring <code class="classname">TestContext</code> Framework</em></span> (在<code class="literal">org.springframework.test.context</code>包中)
	  提供了一般的、注解驱动的单元和集成测试支持，它对使用的测试框架不做要求，可以使用JUnit 3.8、JUnit 4.4, TestNG 5.5等等。
	  TestContext框架也强调了<span class="emphasis"><em>约定优于配置</em></span>的重要性，它提供了合理的默认值，同时也可以通过基于注解的配置进行改写。</p>
<p>除了一般的测试基础设施外，TestContext框架还以<code class="literal">抽象</code>支持类的形式对JUnit 3.8、JUnit 4.4和TestNG 5.5提供了显式的支持。
	  针对JUnit 4.4，该框架还提供了一个自定义的<code class="interfacename">Runner</code>，这使得用户无需继承特定的类就可以编写测试类了。 </p>
<p>以下章节给出了TestContext框架的内部概览。
	  如果你仅仅关注如何使用该框架而不是使用你自己的监听器去扩展它，那么请直接跳到配置(<a href="ch08s03.html#testcontext-ctx-management" title="8.3.7.2.&#160;上下文管理和缓存">上下文管理和缓存</a>、
	  <a href="ch08s03.html#testcontext-fixture-di" title="8.3.7.3.&#160;测试fixture的依赖注入">依赖注入</a>、<a href="ch08s03.html#testcontext-tx" title="8.3.7.4.&#160;事务管理">事务管理</a>)、
	  <a href="ch08s03.html#testcontext-support-classes" title="8.3.7.5.&#160;TestContext支持类">支持类</a>及<a href="ch08s03.html#testcontext-annotations" title="8.3.7.6.&#160;TestContext框架注解支持">注解支持</a>章节。</p>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="testcontext-key-abstractions"></a>8.3.7.1.&#160;主要的抽象</h4></div></div></div>
<p>框架的核心包括<code class="classname">TestContext</code>和<code class="classname">TestContextManager</code>类以及<code class="interfacename">TestExecutionListener</code>接口。
        每次测试都会创建<code class="classname">TestContextManager</code>。<code class="classname">TestContextManager</code>管理了一个<code class="classname">TestContext</code>，
        它负责持有当前测试的上下文。<code class="classname">TestContextManager</code>还负责在测试执行过程中更新<code class="classname">TestContext</code>的状态并代理到<code class="interfacename">TestExecutionListener</code>，
        它用来监测测试实际的执行（如提供依赖注入、管理事务等等）。请查看JavaDoc及Spring测试套件以获得进一步的信息和各种配置示例。</p>
<div class="itemizedlist"><ul type="disc">
<li><p><code class="classname">TestContext</code>：封装测试执行的上下文，与当前使用的测试框架无关。</p></li>
<li><p><code class="classname">TestContextManager</code>：<span class="emphasis"><em>Spring TestContext Framework</em></span>的主入口点，
            负责管理单独的<code class="classname">TestContext</code>并在定义好的执行点上向所有注册的<code class="interfacename">TestExecutionListener</code>发出事件通知：
            测试实例的准备，先于特定的测试框架的<span class="emphasis"><em>前置方法</em></span>，迟于<span class="emphasis"><em>后置方法</em></span>。</p></li>
<li>
<p><code class="interfacename">TestExecutionListener</code>：定义了一个<span class="emphasis"><em>监听器</em></span>API与<code class="classname">TestContextManager</code>发布的测试执行事件进行交互，
            而该监听器就是注册到这个<code class="classname">TestContextManager</code>上的。</p>
<p>Spring提供了<code class="interfacename">TestExecutionListener</code>的三个实现，
            他们都是使用默认值进行配置的(通过<code class="interfacename">@TestExecutionListeners</code>注解)：
            <code class="classname">DependencyInjectionTestExecutionListener</code>、<code class="classname">DirtiesContextTestExecutionListener</code>及<code class="classname">TransactionalTestExecutionListener</code>，
            他们对测试实例提供了依赖注入支持，处理<code class="interfacename">@DirtiesContext</code>注解，并分别使用默认的回滚语义对测试提供事务支持。</p>
</li>
</ul></div>
<p>以下三个章节讲述了如何通过注解配置<code class="classname">TestContext</code>框架并提供了使用该框架编写真实的单元和集成测试的示例。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="testcontext-ctx-management"></a>8.3.7.2.&#160;上下文管理和缓存</h4></div></div></div>
<p>每个<code class="classname">TestContext</code>都会为其所负责的测试实例提供上下文和缓存管理。
        测试实例不会自动访问配置好的<code class="classname">ApplicationContext</code>；然而，如果一个测试类实现了<code class="interfacename">ApplicationContextAware</code>接口，
        那么测试实例就会拥有一个对<code class="classname">ApplicationContext</code>的引用（假如默认已经配置好了<code class="classname">DependencyInjectionTestExecutionListener</code>）。
        <code class="classname">AbstractJUnit38SpringContextTests</code>、
        <code class="classname">AbstractJUnit4SpringContextTests</code>及<code class="classname">AbstractTestNGSpringContextTests</code>已经实现了<code class="interfacename">ApplicationContextAware</code>，
        因此自带了上述功能。</p>
<p>与JUnit 3.8遗留支持不同，使用TestContext框架的测试类无需重写任何<code class="literal">protected</code>成员方法来配置应用上下文。
        只需在类层次上声明<code class="interfacename">@ContextConfiguration</code>注解就可以完成配置。
        如果你的测试类没有显式声明任何应用上下文资源的<code class="literal">位置</code>，那么配置好的<code class="interfacename">ContextLoader</code>就会决定如何以及是否从默认的集合位置上加载一个上下文。
        例如，<code class="classname">GenericXmlContextLoader</code> - 默认的<code class="interfacename">ContextLoader</code> - 会基于测试类的名字产生一个默认的位置。
        如果类名叫做<code class="literal">com.example.MyTest</code>，那么<code class="classname">GenericXmlContextLoader</code>就会从<code class="literal">"classpath:/com/example/MyTest-context.xml"</code>加载应用上下文。</p>
<pre class="code">package com.example;

@RunWith(SpringJUnit4ClassRunner.class)
<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from <code class="literal">"classpath:/com/example/MyTest-context.xml"</code></span></em>
<span class="bold"><strong>@ContextConfiguration</strong></span>
public class MyTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>
<p>如果默认位置不适合你的需求，你可以使用一个包含了XML配置元数据的资源位置的数组来配置<code class="interfacename">@ContextConfiguration</code>的<code class="literal">locations</code>属性
        （假如已经配置好了一个可以使用XML的<code class="interfacename">ContextLoader</code>）- 一般在classpath上，该属性被用来配置应用程序。
        这就和在<code class="literal">web.xml</code>或者其他部署配置中指定配置列表时，方法完全一样，或者几乎一样。
        作为另外一种选择，你可以实现并配置自己的<code class="interfacename">ContextLoader</code>
        </p>
<pre class="code">@RunWith(SpringJUnit4ClassRunner.class)
<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from <code class="literal">"/applicationContext.xml"</code> and <code class="literal">"/applicationContext-test.xml"</code></span></em>
<em class="lineannotation"><span class="lineannotation">// in the root of the classpath</span></em>
<span class="bold"><strong>@ContextConfiguration(locations={"/applicationContext.xml", "/applicationContext-test.xml"})</strong></span>
public class MyTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>
<p><code class="interfacename">@ContextConfiguration</code>还提供了一个boolean类型的<code class="literal">inheritLocations</code>属性以表明是否<span class="emphasis"><em>继承</em></span>父类的locations。
        其默认值是<code class="literal">true</code>，表明一个被注解的类会<span class="emphasis"><em>继承</em></span>被注解的父类中定义的资源位置。
        特别地，一个被注解的类的资源位置会附加到其被注解的父类中的资源位置列表上。这样子类就可以<span class="emphasis"><em>继承</em></span>资源位置列表。
        在下面的例子中，将按顺序从"/base-context.xml"<span class="bold"><strong>和</strong></span>"/extended-context.xml"中加载针对<code class="classname">ExtendedTest</code>的<code class="interfacename">ApplicationContext</code>。
        所以定义在"/extended-context.xml"中的Beans会覆盖掉定义在"/base-context.xml"中的Beans。</p>
<pre class="code">@RunWith(SpringJUnit4ClassRunner.class)
<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from <code class="literal">"/base-context.xml"</code> in the root of the classpath</span></em>
<span class="bold"><strong>@ContextConfiguration(locations={"/base-context.xml"})</strong></span>
public class BaseTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}

<em class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from <code class="literal">"/base-context.xml"</code> and <code class="literal">"/extended-context.xml"</code></span></em>
<em class="lineannotation"><span class="lineannotation">// in the root of the classpath</span></em>
<span class="bold"><strong>@ContextConfiguration(locations={"/extended-context.xml"})</strong></span>
public class ExtendedTest extends BaseTest {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>
<p>如果将<code class="literal">inheritLocations</code>设为<code class="literal">false</code>，那么就会<span class="emphasis"><em>屏蔽掉</em></span>父类的资源位置，然后可以替换父类中定义的任何资源位置。</p>
<p>默认情况下, 配置好的<code class="interfacename">ApplicationContext</code>一旦被加载就会重用到每个测试上。这样设置的成本仅产生一次（每个测试fixture），
        随后测试的执行就会很快了。在某些不太可能发生的情况下，一个测试可能会<span class="emphasis"><em>破坏</em></span>应用上下文，
        这时它需要重新加载 - 例如，通过改变应用对象的bean定义或者状态 - 你可以使用<code class="interfacename">@DirtiesContext</code>
        （假设默认已经配置了<code class="classname">DirtiesContextTestExecutionListener</code>）来注解测试方法使得测试fixture重新加载配置文件并在测试下次执行前重新构建应用上下文。</p>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="testcontext-fixture-di"></a>8.3.7.3.&#160;测试fixture的依赖注入</h4></div></div></div>
<p>当你配置<code class="classname">DependencyInjectionTestExecutionListener</code>时 - 它会被默认配置 - 通过<code class="interfacename">@TestExecutionListeners</code>注解，
        你的测试实例依赖的bean会被<span class="emphasis"><em>注入</em></span>，而这些bean是通过<code class="interfacename">@ContextConfiguration</code>使用Setter注入、Field注入或者两者都有来注入的，
        到底使用哪种方式取决于你选择的注解以及你将它们放到setter方法中还是属性中。为了与Spring 2.5的注解保持一致，
        你可以选择Spring的<code class="interfacename">@Autowired</code>注解或者JSR 250中的<code class="interfacename">@Resource</code>注解。其语义对于Spring框架来说都是一致的。
        例如， 如果你喜欢 <a href="ch03s03.html#beans-factory-autowire" title="3.3.5.&#160;自动装配（autowire）协作者"><span class="emphasis"><em>按类型自动织入</em></span></a>，
        那么请使用<code class="interfacename">@Autowired</code>来注解你的settter方法或者属性。另一方面，如果你喜欢<span class="emphasis"><em>按名字</em></span>注入，
        那么请使用<code class="interfacename">@Resource</code>来注解你的settter方法或者属性。</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">提示</h3>
<p>TestContext框架没有监测测试实例的实例化方式。所以对构造方法使用<code class="interfacename">@Autowired</code>将毫无意义。</p>
</div>
<p>既然<code class="interfacename">@Autowired</code>执行<a href="ch03s03.html#beans-factory-autowire" title="3.3.5.&#160;自动装配（autowire）协作者"><span class="emphasis"><em>按类型自动编织</em></span></a>，
        那么如果你有相同类型的多个bean定义的话，对那些特定的bean就不能使用该方式。在这种情况下，
        你可以使用<code class="interfacename">@Resource</code><span class="emphasis"><em>按名字</em></span>注入。另外，如果你的测试类实现了<code class="classname">ApplicationContextAware</code>，
        就可以直接访问<code class="classname">ApplicationContext</code>并调用<code class="methodname">applicationContext.getBean("titleDao")</code>执行一个显式的查找。</p>
<p>如果你不想让你的测试实例使用依赖注入，只要不将<code class="interfacename">@Autowired</code>或者<code class="interfacename">@Resource</code>注解到任何属性或者setter方法上就行了。
        另一种方式，你可以使用<code class="interfacename">@TestExecutionListeners</code>并忽略掉监听器列表中的<code class="literal">DependencyInjectionTestExecutionListener.class</code>就可以完全禁用依赖注入。</p>
<p>考虑如下场景：我们有一个类，名字叫<code class="classname">HibernateTitleDao</code>（<a href="ch08s03.html#testing-fixture-di" title="8.3.3.2.&#160;测试fixtures依赖注入">通用目标</a>章节已经进行了介绍）。
        首先，让我们看看基于JUnit 4.4的测试类的实现，它使用<code class="interfacename">@Autowired</code>进行属性注入（在所有示例代码之后我们会查看应用上下文的配置）。
        <span class="emphasis"><em>注意：下面代码的依赖注入行为并不是特定于JUnit 4.4的。同样的依赖注入技术可以使用在任何测试框架中。</em></span></p>
<pre class="code">@RunWith(SpringJUnit4ClassRunner.class)
<em class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></em>
<span class="bold"><strong>@ContextConfiguration(locations={"daos.xml"})</strong></span>
public final class HibernateTitleDaoTests {

    <em class="lineannotation"><span class="lineannotation">// this instance will be dependency injected <span class="bold"><strong>by type</strong></span></span></em>
    <span class="bold"><strong>@Autowired</strong></span>    
    private HibernateTitleDao titleDao;

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }
}</pre>
<p>此外，我们可以使用<code class="interfacename">@Autowired</code>进行setter注入。</p>
<pre class="code">@RunWith(SpringJUnit4ClassRunner.class)
<em class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></em>
<span class="bold"><strong>@ContextConfiguration(locations={"daos.xml"})</strong></span>
public final class HibernateTitleDaoTests {

    <em class="lineannotation"><span class="lineannotation">// this instance will be dependency injected <span class="bold"><strong>by type</strong></span></span></em>
    private HibernateTitleDao titleDao;

    <span class="bold"><strong>@Autowired</strong></span>
    public void setTitleDao(HibernateTitleDao titleDao) {
        this.titleDao = titleDao;
    }

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }
}</pre>
<p>现在让我们看看使用<code class="interfacename">@Resource</code>进行属性注入的一个示例。</p>
<pre class="code">@RunWith(SpringJUnit4ClassRunner.class)
<em class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></em>
<span class="bold"><strong>@ContextConfiguration(locations={"daos.xml"})</strong></span>
public final class HibernateTitleDaoTests {

    <em class="lineannotation"><span class="lineannotation">// this instance will be dependency injected <span class="bold"><strong>by name</strong></span></span></em>
    <span class="bold"><strong>@Resource</strong></span>
    private HibernateTitleDao titleDao;

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }
}</pre>
<p>最后，这是使用<code class="interfacename">@Resource</code>进行setter注入的一个示例。</p>
<pre class="code">@RunWith(SpringJUnit4ClassRunner.class)
<em class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></em>
<span class="bold"><strong>@ContextConfiguration(locations={"daos.xml"})</strong></span>
public final class HibernateTitleDaoTests {

    <em class="lineannotation"><span class="lineannotation">// this instance will be dependency injected <span class="bold"><strong>by name</strong></span></span></em>
    private HibernateTitleDao titleDao;
    
    <span class="bold"><strong>@Resource</strong></span>
    public void setTitleDao(HibernateTitleDao titleDao) {
        this.titleDao = titleDao;
    }

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }
}</pre>
<p>上面的代码使用了相同的XML上下文文件，<code class="interfacename">@ContextConfiguration</code>注解使用了这些信息(如 <code class="literal">"daos.xml"</code>)，它是这样的：</p>
<pre class="code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" 
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    <em class="lineannotation"><span class="lineannotation">&lt;!-- this bean will be injected into the <code class="classname">HibernateTitleDaoTests</code> class --&gt;</span></em>
    &lt;bean id="<span class="bold"><strong>titleDao</strong></span>" class="<span class="bold"><strong>com.foo.dao.hibernate.HibernateTitleDao</strong></span>"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
        <em class="lineannotation"><span class="lineannotation">&lt;!-- dependencies elided for clarity --&gt;</span></em>
    &lt;/bean&gt;

&lt;/beans&gt;</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="testcontext-tx"></a>8.3.7.4.&#160;事务管理</h4></div></div></div>
<p>在TestContext框架中，事务是由<code class="classname">TransactionalTestExecutionListener</code>进行管理的，
        默认情况下这是通过<code class="interfacename">@TestExecutionListeners</code>注解进行配置的，
        即使你没有在测试类中显式声明 <code class="interfacename">@TestExecutionListeners</code>注解。
        为了支持事务，你必须通过<code class="interfacename">@ContextConfiguration</code>在应用上下文中加载一个<code class="classname">PlatformTransactionManager</code> bean。
        此外，你必须在类或方法层次上声明一个<code class="interfacename">@Transactional</code>。
        </p>
<p>请参考<a href="ch08s03.html#testcontext-annotations" title="8.3.7.6.&#160;TestContext框架注解支持">TestContext框架的注解支持</a>中的<code class="interfacename">@TransactionConfiguration</code>以了解类层次的事务配置（例如为事务管理器设置bean名称以及默认的回滚标志）。</p>
<p>为每个测试方法配置事务时有几种选项。如果对于整个类来说事务不可用，那么可以使用<code class="interfacename">@Transactional</code>来显式注解方法。
        与此类似，如果对于整个类来说事务<span class="emphasis"><em>可用</em></span>，那么可以使用<code class="interfacename">@NotTransactional</code>来注解方法表明不为该方法增加事务。
        你可以使用<code class="interfacename">@Rollback</code>注解覆盖类级别的默认的回滚设置进而针对一个特定的测试方法控制其事务的提交。</p>
<p><span class="emphasis"><em>请注意，<a href="ch08s03.html#testcontext-support-classes-junit38" title="8.3.7.5.1.&#160;JUnit 3.8支持类"><code class="classname">AbstractTransactionalJUnit38SpringContextTests</code></a>、
        <a href="ch08s03.html#testcontext-support-classes-junit44" title="8.3.7.5.2.&#160;JUnit 4.4支持类"><code class="classname">AbstractTransactionalJUnit4SpringContextTests</code></a> 及 
        <a href="ch08s03.html#testcontext-support-classes-testng" title="8.3.7.5.4.&#160;TestNG支持类"><code class="classname">AbstractTransactionalTestNGSpringContextTests</code></a>已经在类级别预先配置好了事务支持。
        </em></span></p>
<p>偶尔你需要在一个事务性测试方法前、后执行某些代码，而这些代码是处在事务上下文之外的，例如，
        在测试执行前去验证初始的数据库状态或者在测试执行后验证期待的事务提交行为（举例来说，该测试被配置为不进行回滚的）。
        支持<code class="interfacename">@BeforeTransaction</code>和<code class="interfacename">@AfterTransaction</code>注解的<code class="classname">TransactionalTestExecutionListener</code>正好适用于这种情况。
        使用这些注解之一来注解测试类中任何的<code class="literal">public void</code>方法，
        同时<code class="classname">TransactionalTestExecutionListener</code>会保证你的<span class="emphasis"><em>事务方法之前的代码</em></span>或者<span class="emphasis"><em>事务方法之后的代码</em></span>会在正确的时间执行。</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">提示</h3>
<p>任意<span class="emphasis"><em>前置方法</em></span> (如使用JUnit 4的@Before所注解的方法)和<span class="emphasis"><em>后置方法</em></span> (如使用JUnit 4的@After所注解的方法)都会<span class="bold"><strong>在</strong></span>一个事务中得到执行。
          此外，使用 <code class="interfacename">@NotTransactional</code>注解的测试不会执行<code class="interfacename">@BeforeTransaction</code>或<code class="interfacename">@AfterTransaction</code>所注解的方法。</p>
</div>
<p>下面的基于JUnit 4的示例展示了一个假想的集成测试场景，重点阐述了事务相关的注解。请查看参考手册的<a href="ch08s03.html#testcontext-annotations" title="8.3.7.6.&#160;TestContext框架注解支持">TestContext框架注解支持</a>章节以了解进一步的信息和配置示例。</p>
<pre class="code">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
<span class="bold"><strong>@TransactionConfiguration(transactionManager="txMgr", defaultRollback=false)</strong></span>
<span class="bold"><strong>@Transactional</strong></span>
public class FictitiousTransactionalTest {

	<span class="bold"><strong>@BeforeTransaction</strong></span>
	public void verifyInitialDatabaseState() {
		<em class="lineannotation"><span class="lineannotation">// logic to verify the initial state before a transaction is started</span></em>
	}

	@Before
	public void setUpTestDataWithinTransaction() {
		<em class="lineannotation"><span class="lineannotation">// set up test data within the transaction</span></em>
	}

	@Test
	<em class="lineannotation"><span class="lineannotation">// overrides the class-level defaultRollback setting</span></em>
	<span class="bold"><strong>@Rollback(true)</strong></span>
	public void modifyDatabaseWithinTransaction() {
		<em class="lineannotation"><span class="lineannotation">// logic which uses the test data and modifies database state</span></em>
	}

	@After
	public void tearDownWithinTransaction() {
		<em class="lineannotation"><span class="lineannotation">// execute "tear down" logic within the transaction</span></em>
	}

	<span class="bold"><strong>@AfterTransaction</strong></span>
	public void verifyFinalDatabaseState() {
		<em class="lineannotation"><span class="lineannotation">// logic to verify the final state after transaction has rolled back</span></em>
	}

	@Test
	<span class="bold"><strong>@NotTransactional</strong></span>
	public void performNonDatabaseRelatedAction() {
		<em class="lineannotation"><span class="lineannotation">// logic which does not modify database state</span></em>
	}
}</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="testcontext-support-classes"></a>8.3.7.5.&#160;TestContext支持类</h4></div></div></div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h5 class="title">
<a name="testcontext-support-classes-junit38"></a>8.3.7.5.1.&#160;JUnit 3.8支持类</h5></div></div></div>
<p><code class="literal">org.springframework.test.context.junit38</code>包为基于JUnit 3.8的测试用例提供了支持类。</p>
<div class="itemizedlist"><ul type="disc">
<li>
<p><code class="classname">AbstractJUnit38SpringContextTests</code>：</p>
<p>对集成了<span class="emphasis"><em>Spring TestContext Framework</em></span>与JUnit 3.8环境中的<code class="classname">ApplicationContext</code>测试支持的<code class="classname">TestCase</code>进行了抽象。
              当你继承<code class="classname">AbstractJUnit38SpringContextTests</code>类时，你就可以访问到<code class="literal">protected</code>的成员变量：</p>
<div class="itemizedlist"><ul type="circle"><li><p><code class="literal">applicationContext</code>：使用它进行显式的bean查找或者测试整个上下文的状态。</p></li></ul></div>
</li>
<li>
<p><code class="classname">AbstractTransactionalJUnit38SpringContextTests</code>：</p>
<p>对为JDBC访问增加便捷功能的<code class="classname">AbstractJUnit38SpringContextTests</code>的<span class="emphasis"><em>事务</em></span>扩展进行抽象。
              需要在<code class="classname">ApplicationContext</code>中定义一个<code class="classname">javax.sql.DataSource</code> bean和一个<code class="interfacename">PlatformTransactionManager</code> bean。
              当你继承<code class="classname">AbstractTransactionalJUnit38SpringContextTests</code>类时，你就可以访问到<code class="literal">protected</code>的成员变量：</p>
<div class="itemizedlist"><ul type="circle">
<li><p><code class="literal">applicationContext</code>：从<code class="classname">AbstractJUnit38SpringContextTests</code>父类继承。使用它执行bean的查找或者测试整个上下文的状态</p></li>
<li><p><code class="literal">simpleJdbcTemplate</code>：在查询以确认状态时非常有用。例如，应用代码要创建一个对象，然后使用ORM工具将其持久化，
                  这时你想在测试代码执行前后对其进行查询，以确定数据是否插入到数据库中（Spring会保证该查询运行在相同事务内）。
                  你需要告诉你的ORM工具‘flush’其改变以正确完成任务，例如，使用Hibernate<code class="classname">Session</code>接口的<code class="methodname">flush()</code>方法。</p></li>
</ul></div>
</li>
</ul></div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h5 class="title">
<a name="testcontext-support-classes-junit44"></a>8.3.7.5.2.&#160;JUnit 4.4支持类</h5></div></div></div>
<p><code class="literal">org.springframework.test.context.junit4</code>包为基于JUnit 4.4的测试用例提供了支持类。</p>
<div class="itemizedlist"><ul type="disc">
<li>
<p><code class="classname">AbstractJUnit4SpringContextTests</code>：</p>
<p>对集成了<span class="emphasis"><em>Spring TestContext Framework</em></span>与JUnit 4.4环境中的<code class="classname">ApplicationContext</code>测试支持的基本测试类进行了抽取。</p>
<p>当你继承<code class="classname">AbstractJUnit4SpringContextTests</code>时，你就可以访问到<code class="literal">protected</code>的成员变量：</p>
<div class="itemizedlist"><ul type="circle"><li><p><code class="literal">applicationContext</code>：使用它进行显式的bean查找或者测试整个上下文的状态。</p></li></ul></div>
</li>
<li>
<p><code class="classname">AbstractTransactionalJUnit4SpringContextTests</code>：</p>
<p>对为JDBC访问增加便捷功能的<code class="classname">AbstractJUnit4SpringContextTests</code>的<span class="emphasis"><em>事务</em></span>扩展进行抽象。
              需要在<code class="classname">ApplicationContext</code>中定义一个<code class="classname">javax.sql.DataSource</code> bean和一个<code class="interfacename">PlatformTransactionManager</code> bean。</p>
<p>当你继承<code class="classname">AbstractTransactionalJUnit4SpringContextTests</code>类时，你就可以访问到下列<code class="literal">protected</code>的成员变量：</p>
<div class="itemizedlist"><ul type="circle">
<li><p><code class="literal">applicationContext</code>：继承自父类<code class="classname">AbstractJUnit4SpringContextTests</code>。
                  使用它执行bean的查找或者测试整个上下文的状态</p></li>
<li><p><code class="literal">simpleJdbcTemplate</code>：当通过查询来确认状态时非常有用。例如，应用代码要创建一个对象，
                  然后使用ORM工具将其持久化，这时你想在测试代码执行前后对其进行查询，以确定数据是否插入到数据库中。
                  （Spring会保证该查询运行在相同事务内。）你需要告诉你的ORM工具‘flush’其改变以正确完成任务，例如，
                  使用Hibernate<code class="classname">Session</code>接口的<code class="methodname">flush()</code>方法。</p></li>
</ul></div>
</li>
</ul></div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">提示</h3>
<p>这些类仅仅为扩展提供了方便。 如果你不想将你的测试类绑定到Spring的类上 - 例如，如果你要直接扩展你想测试的类 - 只需要通过<code class="interfacename">@RunWith(SpringJUnit4ClassRunner.class)</code>、
            <code class="interfacename">@ContextConfiguration</code>、<code class="interfacename">@TestExecutionListeners</code>等注解来配置你自己的测试类就可以了。</p>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h5 class="title">
<a name="testcontext-junit4-runner"></a>8.3.7.5.3.&#160;定制JUnit 4.4运行器</h5></div></div></div>
<p><span class="emphasis"><em>Spring TestContext Framework</em></span>通过一个可定制的运行器提供了与JUnit 4.4的完全集成。
          通过使用<code class="literal">@Runwith(SpringJUnit4ClassRunner.class)</code>来注解测试类，开发者可以实现标准的JUnit 4.4单元和集成测试，
          同时还能获得TestContext框架的好处，如对加载应用上下文的支持，测试实例的依赖注入，执行事务性测试方法等等。
          下面的代码清单显示了使用定制的Spring Runner来配置一个测试类的最小需求。
          <span class="emphasis"><em>注意，我们使用一个空的列表来配置<code class="interfacename">@TestExecutionListeners</code>以便禁用默认的监听器，
          否则需要通过<code class="interfacename">@ContextConfiguration</code>配置一个 <code class="interfacename">ApplicationContext</code>。</em></span></p>
<pre class="code">@RunWith(SpringJUnit4ClassRunner.class)
@TestExecutionListeners({})
public class SimpleTest {

	@Test
	public void testMethod() {
		<em class="lineannotation"><span class="lineannotation">// execute test logic...</span></em>
	}
}</pre>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h5 class="title">
<a name="testcontext-support-classes-testng"></a>8.3.7.5.4.&#160;TestNG支持类</h5></div></div></div>
<p><code class="literal">org.springframework.test.context.testng</code>包为基于TestNG的测试用例提供了支持类。</p>
<div class="itemizedlist"><ul type="disc">
<li>
<p><code class="classname">AbstractTestNGSpringContextTests</code>：</p>
<p>对集成了<span class="emphasis"><em>Spring TestContext Framework</em></span>与TestNG环境中的<code class="classname">ApplicationContext</code>测试支持的基础测试类进行了抽象。</p>
<p>当你继承<code class="classname">AbstractTestNGSpringContextTests</code>时，就可以访问到下列<code class="literal">protected</code>的成员变量：</p>
<div class="itemizedlist"><ul type="circle"><li><p><code class="literal">applicationContext</code>：使用它进行显式的bean查找或者测试整个上下文的状态。</p></li></ul></div>
</li>
<li>
<p><code class="classname">AbstractTransactionalTestNGSpringContextTests</code>：</p>
<p>对为JDBC访问增加便捷功能的<code class="classname">AbstractTestNGSpringContextTests</code>的<span class="emphasis"><em>事务</em></span>扩展进行抽象。
              需要在<code class="classname">ApplicationContext</code>中定义一个<code class="classname">javax.sql.DataSource</code> bean和一个<code class="interfacename">PlatformTransactionManager</code> bean。</p>
<p>当你继承<code class="classname">AbstractTransactionalTestNGSpringContextTests</code>类时，就可以访问下列<code class="literal">protected</code>的成员变量：</p>
<div class="itemizedlist"><ul type="circle">
<li><p><code class="literal">applicationContext</code>：继承自父类<code class="classname">AbstractTestNGSpringContextTests</code>。使用它执行bean的查找或者测试整个上下文的状态。</p></li>
<li><p><code class="literal">simpleJdbcTemplate</code>：当通过查询来确认状态时非常有用。例如，应用代码要创建一个对象，
                  然后使用ORM工具将其持久化，这时你想在测试代码执行前后对其进行查询，以确定数据是否插入到数据库中。（Spring会保证该查询运行在相同事务内。）
                  你需要告诉你的ORM工具‘flush’其改变以正确完成任务，例如，使用Hibernate<code class="classname">Session</code>接口的<code class="methodname">flush()</code>方法。</p></li>
</ul></div>
</li>
</ul></div>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">提示</h3>
<p>这些类仅仅为扩展提供了方便。 如果你不想将你的测试类绑定到Spring的类上 - 例如，如果你要直接扩展你想测试的类 - 只需要通过
            <code class="interfacename">@ContextConfiguration</code>、<code class="interfacename">@TestExecutionListeners</code>等注解来配置你自己的测试类就可以了。
            并使用<code class="classname">TestContextManager</code>来手工监测你的测试类。
            请查看<code class="classname">AbstractTestNGSpringContextTests</code>的源代码以了解如何检测你自己的测试类。</p>
</div>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h4 class="title">
<a name="testcontext-annotations"></a>8.3.7.6.&#160;TestContext框架注解支持</h4></div></div></div>
<p>Spring TestContext Framework支持<a href="ch08s03.html#integration-testing-common-annotations" title="8.3.5.&#160;常用注解">通用注解</a>章节提到的所有注解。
        然而下面的这些注解<span class="emphasis"><em>只有配合JUnit才能使用（比如搭配<a href="ch08s03.html#testcontext-junit4-runner" title="8.3.7.5.3.&#160;定制JUnit 4.4运行器">SpringJUnit4ClassRunner</a>或者
        <a href="ch08s03.html#testcontext-support-classes-junit38" title="8.3.7.5.1.&#160;JUnit 3.8支持类">JUnit 3.8</a>及<a href="ch08s03.html#testcontext-support-classes-junit44" title="8.3.7.5.2.&#160;JUnit 4.4支持类">JUnit 4.4</a>支持类）。</em></span></p>
<div class="itemizedlist"><ul type="disc">
<li><p><code class="interfacename">@IfProfileValue</code></p></li>
<li><p><code class="interfacename">@ProfileValueSourceConfiguration</code></p></li>
<li>
<p><code class="interfacename">@ExpectedException</code></p>
<p>协同使用Spring的<code class="interfacename">@ExpectedException</code>注解与JUnit 4的<code class="interfacename">@Test(expected=...)</code>会导致一个不可避免的冲突。
            因此当与JUnit 4集成时，开发者必须选择其中一个，在这种情况下建议使用显式的JUnit 4配置。</p>
</li>
<li>
<p><code class="interfacename">@Timed</code></p>
<p>Spring的<code class="interfacename">@Timed</code>注解与JUnit 4的<code class="interfacename">@Test(timeout=...)</code>支持具有不同的语义。
            特别地，鉴于JUnit 4处理测试执行超时（如通过在一个单独的<code class="interfacename">线程</code>中执行测试方法）的方式，
            我们不可能在一个事务上下文中的测试方法上使用JUnit的<code class="interfacename">@Test(timeout=...)</code>配置。因此，
            如果你想将一个测试方法配置成<span class="emphasis"><em>计时</em></span>且<span class="emphasis"><em>具事务性</em></span>的，
            你就必须联合使用Spring的<code class="interfacename">@Timed</code>及<code class="interfacename">@Transactional</code>注解。
            还值得注意的是<code class="interfacename">@Test(timeout=...)</code>只管测试方法本身执行的次数，如果超出的话立刻就会失败；
            然而，<code class="interfacename">@Timed</code>关注的是测试执行的总时间（包括建立和销毁操作以及重复），并且不会令测试失败。
            </p>
</li>
<li><p><code class="interfacename">@Repeat</code></p></li>
</ul></div>
<p>Spring TestContext Framework还支持下面这些非特定于测试的注解，并且保持其语义不变。</p>
<div class="itemizedlist"><ul type="disc">
<li><p><code class="interfacename">@Autowired</code></p></li>
<li><p><code class="interfacename">@Qualifier</code></p></li>
<li><p><code class="interfacename">@Resource</code> (javax.annotation)<span class="emphasis"><em>如果JSR-250可用</em></span></p></li>
<li><p><code class="interfacename">@PersistenceContext</code> (javax.persistence)<span class="emphasis"><em>如果JPA可用</em></span></p></li>
<li><p><code class="interfacename">@PersistenceUnit</code> (javax.persistence)<span class="emphasis"><em>如果JPA可用</em></span></p></li>
<li><p><code class="interfacename">@Required</code></p></li>
<li><p><code class="interfacename">@Transactional</code></p></li>
</ul></div>
<p>下面的列表包含了特定于Spring TestContext Framework的所有注解。请查看相应的JavaDoc以了解进一步的信息，包括默认的属性值等等。</p>
<div class="itemizedlist"><ul type="disc">
<li>
<p><span class="bold"><strong><code class="interfacename">@ContextConfiguration</code></strong></span></p>
<p>定义类级别的元数据以决定如何加载和配置<code class="interfacename">ApplicationContext</code>。特别地，
            @ContextConfiguration定义了要加载的应用上下文资源<code class="literal">位置</code>以及用来加载上下文的<code class="interfacename">ContextLoader</code>策略。</p>
<pre class="code">@ContextConfiguration(locations={"example/test-context.xml"}, loader=CustomContextLoader.class)
public class CustomConfiguredApplicationContextTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>
<p>注意：<code class="interfacename">@ContextConfiguration</code>默认情况下为<span class="emphasis"><em>继承</em></span>的资源位置提供了支持。
            查看<a href="ch08s03.html#testcontext-ctx-management" title="8.3.7.2.&#160;上下文管理和缓存">上下文管理和缓存</a>章节及JavaDoc来了解更多的示例和细节信息。</p>
</li>
<li>
<p><span class="bold"><strong><code class="interfacename">@TestExecutionListeners</code></strong></span></p>
<p>定义类级别的元数据，<code class="interfacename">TestExecutionListener</code>s会使用<code class="classname">TestContextManager</code>进行注册。
            通常，<code class="interfacename">@TestExecutionListeners</code>与<code class="interfacename">@ContextConfiguration</code>会搭配使用。</p>
<pre class="code">@ContextConfiguration
@TestExecutionListeners({CustomTestExecutionListener.class, AnotherTestExecutionListener.class})
public class CustomTestExecutionListenerTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>
<p>注意：<code class="interfacename">@TestExecutionListeners</code>默认情况下为<span class="emphasis"><em>继承</em></span>的监听器提供了支持。查看JavaDoc来了解更多的示例和细节信息。</p>
</li>
<li>
<p><span class="bold"><strong><code class="interfacename">@TransactionConfiguration</code></strong></span></p>
<p>为配置事务性测试定义了类级别的元数据。特别地，如果需要的PlatformTransactionManager不是“transactionManager”的话，
            那么可以显式配置驱动事务的<code class="interfacename">PlatformTransactionManager</code>的bean名字。此外，
            可以将<code class="literal">defaultRollback</code>标志改为<code class="literal">false</code>。通常，
            <code class="interfacename">@TransactionConfiguration</code>与<code class="interfacename">@ContextConfiguration</code>搭配使用。</p>
<pre class="code">@ContextConfiguration
@TransactionConfiguration(transactionManager="txMgr", defaultRollback=false)
public class CustomConfiguredTransactionalTests {
    <em class="lineannotation"><span class="lineannotation">// class body...</span></em>
}</pre>
</li>
<li>
<p><span class="bold"><strong><code class="interfacename">@BeforeTransaction</code></strong></span></p>
<p>表明被注解的<code class="literal">public void</code>方法应该在测试方法的事务开始<span class="emphasis"><em>之前</em></span>执行，
            该事务是通过<code class="interfacename">@Transactional</code>注解来配置的。
           </p>
<pre class="code">@BeforeTransaction
public void beforeTransaction() {
    <em class="lineannotation"><span class="lineannotation">// logic to be executed before a transaction is started</span></em>
}</pre>
</li>
<li>
<p><span class="bold"><strong><code class="interfacename">@AfterTransaction</code></strong></span></p>
<p>表明被注解的<code class="literal">public void</code>方法应该在测试方法的事务结束<span class="emphasis"><em>之后</em></span>执行，
            该事务是通过<code class="interfacename">@Transactional</code>注解来配置的。
           </p>
<pre class="code">@AfterTransaction
public void afterTransaction() {
    <em class="lineannotation"><span class="lineannotation">// logic to be executed after a transaction has ended</span></em>
}</pre>
</li>
</ul></div>
</div>
</div>
<div class="section" lang="zh-cn">
<div class="titlepage"><div><div><h3 class="title">
<a name="testing-examples-petclinic"></a>8.3.8.&#160;PetClinic示例</h3></div></div></div>
<p>在Spring的完整发行包里包含了PetClinic示例应用，它以JUnit 4.4环境阐述了<span class="emphasis"><em>Spring TestContext Framework</em></span>的几个特性。
      大多数功能包含在<code class="classname">AbstractClinicTests</code>里，部分内容列举如下：</p>
<pre class="code"><span class="bold"><strong>@ContextConfiguration</strong></span>
public abstract class AbstractClinicTests <span class="bold"><strong>extends AbstractTransactionalJUnit4SpringContextTests</strong></span> {

	<span class="bold"><strong>@Autowired</strong></span>
	protected Clinic clinic;

	@Test
	public void getVets() {
		Collection&lt;Vet&gt; vets = this.clinic.getVets();
		assertEquals("JDBC query must show the same number of vets",
			<span class="bold"><strong>super.countRowsInTable("VETS")</strong></span>, vets.size());
		Vet v1 = EntityUtils.getById(vets, Vet.class, 2);
		assertEquals("Leary", v1.getLastName());
		assertEquals(1, v1.getNrOfSpecialties());
		assertEquals("radiology", (v1.getSpecialties().get(0)).getName());
		<em class="lineannotation"><span class="lineannotation">// ...</span></em>
	}
	
	<em class="lineannotation"><span class="lineannotation">// ...</span></em>
}</pre>
<p>注意：</p>
<div class="itemizedlist"><ul type="disc">
<li><p>该测试用例继承了<code class="classname">AbstractTransactionalJUnit4SpringContextTests</code>类，
          从这里它继承了针对依赖注入的配置（通过<code class="classname">DependencyInjectionTestExecutionListener</code>）和事务性行为（通过<code class="classname">TransactionalTestExecutionListener</code>）。</p></li>
<li><p><code class="literal">clinic</code>成员变量 - 要测试的应用程序对象 - 是通过<code class="interfacename">@Autowired</code>进行依赖注入的。</p></li>
<li><p><code class="methodname">testGetVets()</code>方法说明如何使用继承下来的<code class="methodname">countRowsInTable()</code>方法来轻松验证表中的行数，
          进而测试应用代码的正确行为。这点允许实现更强大的测试，减少了对确切测试数据的依赖。例如，无需打断测试就可以向数据库中增加新行。</p></li>
<li><p>像很多使用数据库的集成测试一样，<code class="classname">AbstractClinicTests</code>中的大多数测试依赖于测试运行前数据库中已有的最小量的数据。
          但是你可能在测试用例中改变数据库——当然，在同一个事务中。</p></li>
</ul></div>
<p>PetClinic应用支持三种数据访问技术 - JDBC、Hibernate及JPA。无需任何特定的资源位置，
      只要声明了<code class="interfacename">@ContextConfiguration</code>，那么<code class="classname">AbstractClinicTests</code>类就会从默认位置加载其应用上下文，
      该默认位置为<code class="literal">"AbstractClinicTests-context.xml"</code>，这里声明了一个通用的<code class="classname">DataSource</code>。
      子类指定了额外的上下文位置，这就要求它必须声明一个<code class="interfacename">PlatformTransactionManager</code>和<code class="interfacename">Clinic</code>的一个具体实现。</p>
<p>例如，PetClinic测试的Hibernate实现包含以下实现。针对这个例子请注意，<code class="classname">HibernateClinicTests</code>没有包含一行代码：
      我们只需声明<code class="interfacename">@ContextConfiguration</code>并且测试继承于<code class="classname">AbstractClinicTests</code>。
      既然无需任何特定的资源位置就可以声明<code class="interfacename">@ContextConfiguration</code>，
      那么<span class="emphasis"><em>Spring TestContext Framework</em></span>就会从<code class="literal">"AbstractClinicTests-context.xml"</code> (例如继承的位置)和
      <code class="literal">"HibernateClinicTests-context.xml"</code>中加载应用上下文，
      同时<code class="literal">"HibernateClinicTests-context.xml"</code> 中定义的bean会覆盖掉<code class="literal">"AbstractClinicTests-context.xml"</code>中定义的bean。</p>
<pre class="code"><span class="bold"><strong>@ContextConfiguration</strong></span>
public class HibernateClinicTests extends AbstractClinicTests { }
</pre>
<p>正如你在PetClinic应用中所看到的，Spring配置文件被划分成多个文件。对于大型应用来说都是这样做的，
      配置位置通常被指定在一个针对该应用程序集成测试的通用基类中。
      这样的基类还可以增加有用的实例变量 - 很自然地由依赖注入组装 - 例如使用Hibernate的应用中的<code class="classname">HibernateTemplate</code>。</p>
<p>从长远来看，集成测试中的Spring配置文件应该与部署环境中的一样。一个可能的不同点是数据库连接池和事务基础设施。
      如果你正部署到一个完整的应用服务器上，那你可能会使用其连接池（通过JNDI访问）和JTA实现。
      这样依赖，在生产阶段你会使用<code class="classname">JndiObjectFactoryBean</code>来获得<code class="classname">DataSource</code>和<code class="classname">JtaTransactionManager</code>。
      在容器外的集成测试中无法使用JNDI和JTA，因此你应该为他们使用一个替代的组合，
      如Commons DBCP <code class="classname">BasicDataSource</code>和<code class="classname">DataSourceTransactionManager</code>或者<code class="classname">HibernateTransactionManager</code>。
      你可以将这种不同的行为放到一个单独的XML文件中，在应用服务器和独立于其他配置的'本地'配置中自由选择，这不会在测试和产品环境中造成差异。
      此外，建议使用属性文件来存放连接信息：请查看PetClinic应用以了解这些。</p>
</div>
</div>

<!--start of htmlend-->

<!-- tail-start -->
﻿
<div style="clear:both;"></div>

</div>
<!--end of file-wrpper-->
</div>
<!--end of content-wrapper-->
</div>
<!--end of container-->


<footer>
<p class="copyright">版权所有 2014 <a href="http://www.iteedu.com">ITEEDU</a>, 京ICP备16069454号</p>
</footer>

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.8.0/highlight.min.js"></script>

<!--百度统计js-->
<p style="display:none">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fa5213b08a76d4fc6b8a80eb382490e0b' type='text/javascript'%3E%3C/script%3E"));
</script>
</p>

</body>

</html>


<!-- tail-end -->